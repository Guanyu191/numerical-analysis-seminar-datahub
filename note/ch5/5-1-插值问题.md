# 5-1-插值问题 (The interpolation problem)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 插值问题**

> **Definition:** Interpolation problem
> Given $n+1$ distinct points $(t_0,y_0),(t_1,y_1),\dots,(t_n,y_n)$ with $t_0<t_1<\cdots<t_n$, called nodes, the interpolation problem is to find a function $p(x)$, called the interpolant, such that $p(t_k)=y_k$ for $k=0,\dots,n$.

在本章里，我们用 $t_k$ 表示插值节点，用 $x$ 表示连续自变量. 节点下标从 0 到 $n$ 编号.

> **Note:** 原文专门提醒了编程语言下标的差异；在 Python 里数组下标同样从 0 开始，因此我们可以直接让代码下标与公式中的 $k$ 一致，不需要额外做 "+1" 的偏移.

**#2 多项式：最自然但也最危险的候选**

多项式是插值函数的最自然候选：它易于求值与求导，并且在 **2-1-多项式插值** 里我们已经见过，给定 $n+1$ 个点，可以通过解线性系统来确定一个通过所有点的 $n$ 次多项式.

但多项式插值并不总是可靠：很容易构造出一些例子，使得插值多项式在节点之间出现大幅振荡，从而变得不可用.

> **Demo:** Polynomial interpolation at equally spaced nodes
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> def data(n):
>     t = np.linspace(-1.0, 1.0, n + 1)
>     y = t**2 + t + 0.05 * np.sin(20 * t)
>     return t, y
>
> def poly_interp(t, y, n):
>     c = np.polyfit(t, y, deg=n)
>     return lambda x: np.polyval(c, x)
>
> # A small degree looks reasonable.
> n = 5
> t, y = data(n)
> p = poly_interp(t, y, n)
> xx = np.linspace(-1.0, 1.0, 600)
> plt.scatter(t, y, label="data")
> plt.plot(xx, p(xx), label="interpolant")
> plt.title("Polynomial interpolant (n=5)")
> plt.legend()
> plt.grid(True, alpha=0.3)
> plt.show()
>
> # A higher degree at equally spaced nodes can oscillate wildly.
> n = 18
> t, y = data(n)
> p = poly_interp(t, y, n)
> xx = np.linspace(-1.0, 1.0, 2000)
> plt.scatter(t, y, s=12, label="data")
> plt.plot(xx, p(xx), label="interpolant")
> plt.title("Polynomial interpolant (n=18)")
> plt.legend()
> plt.grid(True, alpha=0.3)
> plt.show()
> ```
> The second plot typically exhibits large oscillations between nodes, despite the data being smooth and unremarkable.

> **Observation:** Conditioning of polynomial interpolation on equally spaced nodes
> Interpolation by a polynomial at equally spaced nodes is ill-conditioned as the degree of the polynomial grows.

这些大幅振荡现象会在 Chapter 9 被更系统地分析；结论是：想让多项式插值稳定可用，我们往往需要放弃 "等距节点" 或放弃 "全局高次多项式" 其中之一. 在本章后续内容里，我们会尽量保持每一段多项式的次数较小，并允许节点自由选择.

**#3 分段多项式：小次数拼成大规模插值**

当数据点很多时，想把多项式次数压低，又想通过所有节点，一个自然的选择是 **piecewise polynomials**：在每个子区间 $[t_{k-1},t_k]$ 上分别用一个低次多项式.

也就是说，插值函数 $p$ 要求在每个子区间 $[t_{k-1},t_k]$ (对 $k=1,\dots,n$ ) 上都是一个多项式.

> **Example:** Piecewise polynomials on a node set
> For nodes $t_0=-2,t_1=0,t_2=1,t_3=4$, the functions
> $$
> p_1(x)=x+1,\quad p_2(x)=\operatorname{sign}(x),\quad p_3(x)=|x-1|^3,\quad p_4(x)=(\max\{0,x\})^4
> $$
> are examples of piecewise polynomials on appropriate node sets.

通常我们会预先指定每段多项式的最大次数 $d$. 一个很重要的结构性质是：次数不超过 $d$ 的分段多项式构成一个向量空间，线性组合仍然是同一类函数.

> **Observation:** Vector space property
> Piecewise polynomials of degree $d$ form a vector space: any linear combination of such functions is again a piecewise polynomial of degree $d$ (on the same node set).

> **Demo:** Piecewise interpolants vs a global polynomial
> We revisit the data in the previous Demo with $n=18$, and compare a piecewise linear interpolant and a cubic spline.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> from scipy.interpolate import CubicSpline
>
> n = 18
> t = np.linspace(-1.0, 1.0, n + 1)
> y = t**2 + t + 0.05 * np.sin(20 * t)
>
> # Global polynomial interpolant.
> c = np.polyfit(t, y, deg=n)
> p_poly = lambda x: np.polyval(c, x)
>
> # Piecewise linear interpolant.
> p_lin = lambda x: np.interp(x, t, y)
>
> # Piecewise cubic interpolant (cubic spline).
> p_spline = CubicSpline(t, y)
>
> xx = np.linspace(-1.0, 1.0, 2000)
> plt.scatter(t, y, s=12, label="data")
> plt.plot(xx, p_poly(xx), label="polynomial")
> plt.plot(xx, p_lin(xx), label="piecewise linear")
> plt.plot(xx, p_spline(xx), label="piecewise cubic spline")
> plt.legend(loc="best")
> plt.grid(True, alpha=0.3)
> plt.title("Global vs piecewise interpolation")
> plt.show()
> ```
> Piecewise interpolants can avoid the large oscillations of a high-degree global polynomial.

我们会在 **5-2-分段线性插值** 更详细讨论分段线性插值，并在 **5-3-三次样条** 讨论分段三次插值.

**#4 插值的条件性: cardinal 函数与条件数界**

插值问题的输入是 $y_k$，输出是一个定义在区间 $[a,b]$ 上的函数 $p(x)$ (其中 $a=t_0,b=t_n$ ). 这里我们把节点 $t_k$ 视为固定，只把数据向量

$$
\mathbf{y}=(y_0,\dots,y_n)^T
$$

当作变量.

设 $\mathbf{I}$ 表示某个插值方法：它把数据向量映射为插值函数 $p=\mathbf{I}(\mathbf{y})$，并且满足 $p(t_k)=y_k$. 本章讨论的插值方法都是线性的，也就是

> **Observation:** Linearity of interpolation methods
> $$
> \mathbf{I}(\alpha\mathbf{y}+\beta\mathbf{z})=\alpha\mathbf{I}(\mathbf{y})+\beta\mathbf{I}(\mathbf{z})
> $$
> for all vectors $\mathbf{y},\mathbf{z}$ and scalars $\alpha,\beta$.

线性意味着：把 $\mathbf{y}$ 展开成标准基向量 $\mathbf{e}_k$ 的线性组合，

$$
\mathbf{y}=\sum_{k=0}^n y_k\mathbf{e}_k,
$$

就能得到

$$
\mathbf{I}(\mathbf{y})
=
\sum_{k=0}^n y_k\,\mathbf{I}(\mathbf{e}_k).
$$

这引出一组具有特殊意义的基函数: **cardinal functions**.

> **Definition:** Cardinal function
> A cardinal function $\phi_k$ for a node set $t_0,\dots,t_n$ is the function that interpolates the value $(t_k,1)$ and $(t_j,0)$ for all $j\ne k$.

对任意给定的一组 $n+1$ 个节点，都有 $n+1$ 个 cardinal functions $\phi_0,\dots,\phi_n$. 用它们可以把插值函数写成

$$
p(x)=\mathbf{I}(\mathbf{y})(x)=\sum_{k=0}^n y_k\phi_k(x).
$$

为了讨论条件数，我们采用无穷范数

$$
\|f\|_\infty=\max_{x\in[a,b]}|f(x)|.
$$

> **Theorem:** Conditioning of interpolation
> Suppose that $\mathbf{I}$ is a linear interpolation method on nodes $t_0,\dots,t_n$. Then with respect to the infinity norm, the absolute condition number satisfies
> $$
> \max_{0\le k\le n}\|\phi_k\|_\infty \le \kappa(\mathbf{y}) \le \sum_{k=0}^n \|\phi_k\|_\infty,
> $$
> where the $\phi_k$ are cardinal interpolating functions.
>
> **Proof:** By linearity, a perturbation $\delta\mathbf{y}$ gives $\delta p=\sum_k \delta y_k\,\phi_k$. Use $\|\delta p\|_\infty\le \sum_k |\delta y_k|\,\|\phi_k\|_\infty\le \|\delta\mathbf{y}\|_\infty \sum_k \|\phi_k\|_\infty$ for the upper bound. For the lower bound, choose $\delta\mathbf{y}=\mathbf{e}_j$ to get $\delta p=\phi_j$.

**#5 Cardinal 函数：局部插值与全局多项式的对照**

我们在前面的 Demo 已经看到：同样一组节点与数据，全局多项式插值可能会非常糟糕，而分段插值却看起来稳定得多. 这件事也能通过 cardinal functions 很清楚地看出来: cardinal functions 的形状直接影响上面定理中的条件数界.

> **Demo:** Cardinal functions for splines vs polynomials
> We build the data vector for a single cardinal function (one entry is 1, the rest are 0), then interpolate it by a cubic spline and by a degree-$n$ polynomial.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> from scipy.interpolate import CubicSpline
>
> n = 18
> t = np.linspace(-1.0, 1.0, n + 1)
> y = np.zeros(n + 1)
> y[9] = 1.0   # a representative cardinal function
>
> spline_phi = CubicSpline(t, y)
> poly_c = np.polyfit(t, y, deg=n)
> poly_phi = lambda x: np.polyval(poly_c, x)
>
> xx = np.linspace(-1.0, 1.0, 2000)
> spline_vals = spline_phi(xx)
> poly_vals = poly_phi(xx)
>
> print("max |phi| (spline) =", np.max(np.abs(spline_vals)))
> print("max |phi| (poly)   =", np.max(np.abs(poly_vals)))
>
> plt.figure()
> plt.scatter(t, y, s=16, label="data")
> plt.plot(xx, spline_vals, label="spline")
> plt.title("Piecewise cubic cardinal function")
> plt.xlabel("x")
> plt.ylabel(r"$\\phi(x)$")
> plt.grid(True, alpha=0.3)
> plt.legend()
> plt.show()
>
> plt.figure()
> plt.scatter(t, y, s=16, label="data")
> plt.plot(xx, poly_vals, label="polynomial")
> plt.title("Polynomial cardinal function")
> plt.xlabel("x")
> plt.ylabel(r"$\\phi(x)$")
> plt.grid(True, alpha=0.3)
> plt.legend()
> plt.show()
> ```
> The spline cardinal function typically stays within magnitude 1, while the polynomial cardinal function can become very large, indicating poor conditioning.
