# 5-3-三次样条 (Cubic splines)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 分段三次插值与三次样条**

分段线性插值函数是连续的，但它的导数会有跳跃. 我们往往希望插值函数更光滑，也就是至少有若干个连续导数. 在实践中最常用的选择是分段三次函数.

> **Definition:** Cubic spline
> A cubic spline is a piecewise cubic function that has two continuous derivatives everywhere.

我们用 $S(x)$ 表示三次样条插值函数. 与前面一样，给定互异节点 $t_0<t_1<\cdots<t_n$ (不要求等距) 以及对应数据 $y_0,\ldots,y_n$. 对任意 $k=1,\ldots,n$，样条在区间 $[t_{k-1},t_k]$ 上是一段三次多项式 $S_k(x)$，写成

$$
S_k(x)
=
a_k+b_k(x-t_{k-1})+c_k(x-t_{k-1})^2+d_k(x-t_{k-1})^3,
\quad k=1,\ldots,n.
$$

其中 $a_k,b_k,c_k,d_k$ 是待定系数. 总共有 $4n$ 个未知系数需要确定.

**#2 光滑条件**

为了保证 $S$ 在整个区间上至少有二阶连续导数，我们对这些分段三次多项式施加约束.

**插值条件：每一段在两端点插值**

在每个区间端点，我们要求

$$
S_k(t_{k-1})=y_{k-1},\qquad S_k(t_k)=y_k,\qquad k=1,\ldots,n.
$$

用上面的三次形式展开，得到

$$
a_k=y_{k-1},
$$

以及

$$
a_k+b_k h_k+c_k h_k^2+d_k h_k^3=y_k,
$$

其中

$$
h_k=t_k-t_{k-1},\qquad k=1,\ldots,n.
$$

$h_k$ 完全由节点决定. 关键点是：这些约束对未知系数都是线性的，因此可以写成线性代数形式. 令

$$
\mathbf{a}=
\begin{bmatrix}
a_1\\ \vdots\\ a_n
\end{bmatrix},\quad
\mathbf{b}=
\begin{bmatrix}
b_1\\ \vdots\\ b_n
\end{bmatrix},\quad
\mathbf{c}=
\begin{bmatrix}
c_1\\ \vdots\\ c_n
\end{bmatrix},\quad
\mathbf{d}=
\begin{bmatrix}
d_1\\ \vdots\\ d_n
\end{bmatrix},
$$

并把未知量拼成

$$
\mathbf{z}=
\begin{bmatrix}
\mathbf{a}\\
\mathbf{b}\\
\mathbf{c}\\
\mathbf{d}
\end{bmatrix}
\in\mathbb{R}^{4n}.
$$

左端点插值约束等价于

$$
\begin{bmatrix}
\mathbf{I} & \mathbf{0} & \mathbf{0} & \mathbf{0}
\end{bmatrix}
\mathbf{z}
=
\begin{bmatrix}
y_0\\
\vdots\\
y_{n-1}
\end{bmatrix},
$$

其中 $\mathbf{I}$ 是 $n\times n$ 单位矩阵.

右端点插值约束可以写成

$$
\begin{bmatrix}
\mathbf{I} & \mathbf{H} & \mathbf{H}^2 & \mathbf{H}^3
\end{bmatrix}
\mathbf{z}
=
\begin{bmatrix}
y_1\\
\vdots\\
y_n
\end{bmatrix},
$$

这里 $\mathbf{H}$ 是对角矩阵

$$
\mathbf{H}=\operatorname{diag}(h_1,h_2,\ldots,h_n).
$$

这两组方程一共给出了 $2n$ 个标量约束.

**一阶导连续：内部节点处左右斜率相同**

我们不知道节点处的斜率应该是多少，但我们希望从左、从右逼近该节点时斜率一致. 因此在内部节点 $t_1,\ldots,t_{n-1}$，要求

$$
S_k'(t_k)=S_{k+1}'(t_k),\qquad k=1,\ldots,n-1.
$$

由三次多项式可得

$$
b_k+2c_k h_k+3d_k h_k^2=b_{k+1},\qquad k=1,\ldots,n-1.
$$

把未知量移到左边后，可以写成线性系统

$$
\mathbf{E}
\begin{bmatrix}
\mathbf{0} & \mathbf{J} & 2\mathbf{H} & 3\mathbf{H}^2
\end{bmatrix}
\mathbf{z}
=
\mathbf{0},
$$

其中

$$
\mathbf{J}
=
\begin{bmatrix}
1 & -1 \\
 & 1 & -1 \\
 &  & \ddots & \ddots \\
 &  &  & 1 & -1 \\
 &  &  &  & 1
\end{bmatrix}
\in\mathbb{R}^{n\times n},
$$

而 $\mathbf{E}$ 是把单位矩阵的最后一行删掉得到的 $(n-1)\times n$ 矩阵：

$$
\mathbf{E}
=
\begin{bmatrix}
\mathbf{I}_{n-1} & \mathbf{0}
\end{bmatrix}.
$$

左乘 $\mathbf{E}$ 的效果是删除任何矩阵或向量的最后一行，因此这组方程一共给出 $n-1$ 个约束 (对应 $n-1$ 个内部节点).

**二阶导连续：内部节点处左右曲率相同**

同样在内部节点 $t_1,\ldots,t_{n-1}$，要求

$$
S_k''(t_k)=S_{k+1}''(t_k),\qquad k=1,\ldots,n-1.
$$

由三次多项式可得

$$
2c_k+6d_k h_k=2c_{k+1},\qquad k=1,\ldots,n-1.
$$

把两边同时除以 2，可写成线性系统

$$
\mathbf{E}
\begin{bmatrix}
\mathbf{0} & \mathbf{0} & \mathbf{J} & 3\mathbf{H}
\end{bmatrix}
\mathbf{z}
=
\mathbf{0}.
$$

到这里为止，我们一共得到了

$$
2n+(n-1)+(n-1)=4n-2
$$

个线性约束，但未知数是 $4n$ 个，因此还需要再补两条约束.

**#3 端点条件**

目前为止的方程构成了 $4n-2$ 个线性条件. 为了得到方阵系统，我们必须再添加两个约束. 如果应用问题给出了端点处 $S'$ 或 $S''$ 的取值，就可以直接加入；否则常见的两种选择是：

**Natural spline**

$$
S_1''(t_0)=S_n''(t_n)=0.
$$

**Not-a-knot spline**

$$
S_1'''(t_1)=S_2'''(t_1),\qquad S_{n-1}'''(t_{n-1})=S_n'''(t_{n-1}).
$$

自然样条有一些重要的理论性质，但 not-a-knot 样条在逐点精度上更好，因此后面只考虑 not-a-knot.

在 not-a-knot 样条中，$S_1$ 与 $S_2$ 在节点 $t_1$ 处函数值以及一到三阶导数都相同，因此它们必须是同一个三次多项式. 同理，$S_{n-1}$ 与 $S_n$ 在 $t_{n-1}$ 处也必须是同一个三次多项式. 三次多项式的三阶导数是常数：

$$
S_k'''(x)=6d_k,
$$

因此 not-a-knot 条件等价于

$$
d_1=d_2,\qquad d_{n-1}=d_n.
$$

把这两条方程追加到前面的线性系统中，就得到规模为 $4n$ 的方阵线性系统. 这与分段线性插值很不同：分段线性插值不需要解线性系统. 对三次样条而言，虽然存在类似 "帽函数" 的一组基，但无法用闭式构造出 cardinal 基，因此解线性系统是绕不开的.

**#4 一个实现**

> **Function:** spinterp
> **Cubic not-a-knot spline interpolation**
> ```Python
> import numpy as np
>
> def spinterp(t, y):
>     """
>     Construct a cubic not-a-knot spline interpolating function for data y at nodes t.
>     Returns a callable S(x) that evaluates the spline.
>     """
>     t = np.asarray(t, dtype=float)
>     y = np.asarray(y, dtype=float)
>     if t.ndim != 1 or y.ndim != 1:
>         raise ValueError("t and y must be 1D arrays.")
>     if t.size != y.size:
>         raise ValueError("t and y must have the same length.")
>     if np.any(np.diff(t) <= 0):
>         raise ValueError("t must be strictly increasing.")
>
>     n = t.size - 1
>     if n < 3:
>         raise ValueError("not-a-knot spline needs at least 4 nodes.")
>
>     h = t[1:] - t[:-1]
>     Z = np.zeros((n, n))
>     In = np.eye(n)
>     E = In[:-1, :]                       # delete last row
>     J = np.diag(np.ones(n)) + np.diag(-np.ones(n - 1), k=1)
>     H = np.diag(h)
>     H2 = np.diag(h**2)
>     H3 = np.diag(h**3)
>
>     # Left endpoint interpolation.
>     AL = np.hstack([In, Z, Z, Z])
>     vL = y[:-1]
>
>     # Right endpoint interpolation.
>     AR = np.hstack([In, H, H2, H3])
>     vR = y[1:]
>
>     # Continuity of first derivative.
>     A1 = E @ np.hstack([Z, J, 2 * H, 3 * H2])
>     v1 = np.zeros(n - 1)
>
>     # Continuity of second derivative.
>     A2 = E @ np.hstack([Z, Z, J, 3 * H])
>     v2 = np.zeros(n - 1)
>
>     # Not-a-knot conditions: d1 = d2, d_{n-1} = d_n.
>     nakL = np.hstack([np.zeros((1, 3 * n)), np.array([[1.0, -1.0] + [0.0] * (n - 2)])])
>     nakR = np.hstack([np.zeros((1, 3 * n)), np.array([[0.0] * (n - 2) + [1.0, -1.0]])])
>
>     A = np.vstack([AL, AR, A1, A2, nakL, nakR])
>     v = np.concatenate([vL, vR, v1, v2, np.array([0.0, 0.0])])
>     z = np.linalg.solve(A, v)
>
>     a = z[0:n]
>     b = z[n:2 * n]
>     c = z[2 * n:3 * n]
>     d = z[3 * n:4 * n]
>
>     def S(x):
>         x = np.asarray(x, dtype=float)
>         out = np.full_like(x, np.nan, dtype=float)
>         mask = (x >= t[0]) & (x <= t[-1])
>         if np.any(mask):
>             xin = x[mask]
>             k = np.searchsorted(t, xin, side="right") - 1
>             k = np.clip(k, 0, n - 1)
>             dx = xin - t[k]
>             out[mask] = ((d[k] * dx + c[k]) * dx + b[k]) * dx + a[k]
>         return out.item() if x.ndim == 0 else out
>
>     return S
> ```

为了清晰起见，这份实现紧贴上面的推导：把所有约束写成一个线性系统，组装并求解一次，然后用求得的系数反复评估样条. 这样我们就不会在每次求值时重复做线性代数运算.

**#5 条件性与收敛性**

> **Demo:** Cubic spline interpolation and convergence.
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> f = lambda x: np.exp(np.sin(7.0 * x))
>
> # A spline interpolant using just a few nodes.
> t = np.array([0.0, 0.075, 0.25, 0.55, 0.7, 1.0])
> y = f(t)
> S = spinterp(t, y)
>
> xplot = np.linspace(0.0, 1.0, 1000)
> plt.plot(xplot, f(xplot), label="function")
> plt.plot(t, y, "o", label="values at nodes")
> plt.plot(xplot, S(xplot), label="spline")
> plt.xlabel("x")
> plt.ylabel("y")
> plt.title("Cubic not-a-knot spline interpolation")
> plt.grid(True)
> plt.legend()
> plt.show()
>
> # Convergence as the number of nodes increases.
> x = np.linspace(0.0, 1.0, 10001)
> ns = np.round(2 ** np.arange(3.0, 7.5, 0.5)).astype(int)
> errs = []
> for n in ns:
>     t = np.linspace(0.0, 1.0, n + 1)
>     S = spinterp(t, f(t))
>     errs.append(np.max(np.abs(f(x) - S(x))))
>
> errs = np.array(errs)
> for n, e in zip(ns, errs):
>     print(n, e)
>
> ref = errs[0] * (ns / ns[0]) ** (-4)
> plt.loglog(ns, errs, "o-", label="error")
> plt.loglog(ns, ref, "--", label="4th order")
> plt.xlabel("n")
> plt.ylabel(r"$||f-S||_\infty$")
> plt.title("Convergence of spline interpolation")
> plt.grid(True, which="both")
> plt.legend()
> plt.show()
> ```
> On a log-log plot, the error curve is expected to have slope -4 if fourth-order convergence is observed.

除了比分段线性插值更光滑以外，not-a-knot 三次样条还把精度阶数提升到了 4. 更具体地说，在等距节点下有下面的误差界.

> **Theorem:** Convergence of spline interpolation
> Suppose that $f$ has four continuous derivatives in $[a,b]$ (i.e., $f\in C^4[a,b]$). Let $S_n$ be the not-a-knot cubic spline interpolant of $f$ for the data $(t_i,f(t_i))$, $i=0,\ldots,n$, where $t_i=a+ih$ and $h=(b-a)/n$. Then for all sufficiently small $h$, there is a constant $C>0$ such that
> $$
> \|f-S_n\|_\infty \le C h^4.
> $$

样条插值的条件性比前一节的分段线性情形复杂得多. 一方面，由于所有分段多项式的系数需要同时求解，数据 $\{y_i\}$ 中的每个值都会影响整个区间上的 $S$. 另一方面，$S$ 的取值幅度可能比所有的 $\{y_i\}$ 都更大. 更深入的讨论通常需要参考更高级的教材.
