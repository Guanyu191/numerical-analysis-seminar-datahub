# 5-2-分段线性插值 (Piecewise linear interpolation)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 分段线性插值就是 "连点成线"**

分段线性插值本质上就是一个 "connect-the-dots" 游戏：把数据点两两相连，得到折线.

> **Definition:** Piecewise linear interpolant
> Given nodes $t_0<t_1<\cdots<t_n$, the piecewise linear interpolant $p(x)$ is defined by
> $$
> p(x)=y_k+\frac{y_{k+1}-y_k}{t_{k+1}-t_k}(x-t_k),\qquad x\in[t_k,t_{k+1}],
> $$
> for $k=0,\dots,n-1$.

从这个定义可以直接看出：在每个区间 $[t_k,t_{k+1}]$ 上，$p(x)$ 是通过 $(t_k,y_k)$ 与 $(t_{k+1},y_{k+1})$ 的一次函数.

**#2 Hat 函数：分段线性空间的一组基**

直接按上面的分段公式实现当然可以，但更有结构性的做法是：像 **2-1-多项式插值** 里那样，把插值函数写成一组预先选定基函数的线性组合.

在分段线性的语境里，我们引入一组只依赖于节点位置的基函数: **hat functions** (也常被称为 **piecewise linear basis functions**). 对 $k=0,\dots,n$，定义

$$
H_k(x)=
\begin{cases}
\dfrac{x-t_{k-1}}{t_k-t_{k-1}}, & x\in[t_{k-1},t_k],\\[6pt]
\dfrac{t_{k+1}-x}{t_{k+1}-t_k}, & x\in[t_k,t_{k+1}],\\[6pt]
0, & \text{otherwise}.
\end{cases}
$$

其中端点处的定义要按自然方式理解：例如 $H_0$ 只有下降的那一段，$H_n$ 只有上升的那一段.

每个 $H_k$ 都是全局连续的，并且在每个子区间内线性. 因此它们的任意线性组合也有相同性质. 更重要的是：任意一个对节点集 $t$ 连续且分段线性的函数，都能唯一表示成

$$
p(x)=\sum_{k=0}^n c_k H_k(x).
$$

> **Function:** hatfun
> **Create a piecewise linear hat function**
> ```Python
> import numpy as np
>
> def hatfun(t, k):
>     """
>     hatfun(t, k)
>
>     t: sorted array of n+1 interpolation nodes
>     k: index 0..n
>     returns: callable H_k(x)
>     """
>     t = np.asarray(t, dtype=float)
>     n = len(t) - 1
>
>     def H(x):
>         x = np.asarray(x, dtype=float)
>         v = np.zeros_like(x)
>
>         if k > 0:
>             m = (x >= t[k-1]) & (x <= t[k])
>             v[m] = (x[m] - t[k-1]) / (t[k] - t[k-1])
>
>         if k < n:
>             m = (x >= t[k]) & (x <= t[k+1])
>             v[m] = (t[k+1] - x[m]) / (t[k+1] - t[k])
>
>         return float(v) if v.shape == () else v
>
>     return H
> ```

> **Demo:** Plotting hat functions
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> t = np.array([0.0, 0.55, 0.7, 1.0])
> n = len(t) - 1
>
> xx = np.linspace(0.0, 1.0, 600)
> fig, axes = plt.subplots(n + 1, 1, sharex=True, figsize=(6, 7))
>
> for k in range(n + 1):
>     Hk = hatfun(t, k)
>     axes[k].plot(xx, Hk(xx))
>     axes[k].scatter(t, Hk(t), s=18)
>     axes[k].set_ylim(-0.1, 1.1)
>     axes[k].text(t[k], 0.25, f"H_{k}")
>     axes[k].set_yticks([])
>
> axes[-1].set_xlabel("x")
> fig.suptitle("Hat functions")
> plt.show()
> ```

**#3 Cardinality 条件与 plinterp**

hat 函数有一个特别方便的性质：它们满足 cardinality 条件

$$
H_k(t_i)=
\begin{cases}
1,& i=k,\\
0,& i\ne k.
\end{cases}
$$

这意味着 hat 函数就是 **5-1-插值问题** 里说的 cardinal functions (对分段线性插值而言). 因而当我们要求 $p(t_k)=y_k$ 时，展开系数直接就是数据值本身：

$$
p(x)=\sum_{k=0}^n y_k H_k(x).
$$

> **Function:** plinterp
> **Construct a piecewise linear interpolant**
> ```Python
> import numpy as np
>
> def plinterp(t, y):
>     """
>     plinterp(t, y)
>
>     Construct a piecewise linear interpolating function for data y given at nodes t.
>     Returns a callable p(x).
>     """
>     t = np.asarray(t, dtype=float)
>     y = np.asarray(y, dtype=float)
>     n = len(t) - 1
>     H = [hatfun(t, k) for k in range(n + 1)]
>
>     def p(x):
>         x = np.asarray(x, dtype=float)
>         s = np.zeros_like(x)
>         for k in range(n + 1):
>             s = s + y[k] * H[k](x)
>         return float(s) if s.shape == () else s
>
>     return p
> ```

> **Demo:** Piecewise linear interpolation
> We sample $f(x)=e^{\\sin(7x)}$ at a set of nodes, then build a callable interpolant and plot it.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> f = lambda x: np.exp(np.sin(7 * x))
>
> t = np.array([0.0, 0.075, 0.25, 0.55, 0.7, 1.0])
> y = f(t)
>
> p = plinterp(t, y)
>
> xx = np.linspace(0.0, 1.0, 800)
> plt.plot(xx, f(xx), label="function")
> plt.scatter(t, y, label="values at nodes")
> plt.plot(xx, p(xx), label="interpolant")
> plt.title("PL interpolation")
> plt.xlabel("x")
> plt.ylabel("y")
> plt.grid(True, alpha=0.3)
> plt.legend()
> plt.show()
> ```

> **Note:** 这里把插值的输出也实现成一个可调用的函数 `p(x)`，对应数学观点 "插值的结果是一个函数".

**#4 条件性与收敛性**

在 **5-1-插值问题** 里，我们用 cardinal functions 给出了插值条件数的界. 对分段线性插值而言，cardinal functions 就是 hat 函数. 更进一步，我们甚至能得到一个非常简单的精确结论：它在无穷范数下的绝对条件数等于 1.

> **Theorem:** Conditioning of PL interpolation
> Let $\mathbf{I}$ be the piecewise linear interpolation operator. Then
> $$
> \|\mathbf{I}(\mathbf{y}+\mathbf{z})-\mathbf{I}(\mathbf{y})\|_\infty=\|\mathbf{z}\|_\infty.
> $$
> (The norm on the left is on functions, while the norm on the right is on vectors.)

接下来关心收敛性：如果我们把某个 "足够光滑" 的函数 $f$ 在节点上采样得到数据 $y_k=f(t_k)$，再用分段线性插值构造 $p_n$，那么 $p_n$ 能否逼近 $f$？在等距节点的情形下，有一个经典的二阶误差界.

> **Theorem:** Convergence of PL interpolation
> Suppose that $f$ has a continuous second derivative on $[a,b]$.
> Let $p_n$ be the piecewise linear interpolant of $f$ at equally spaced nodes $t_i=a+ih$, $i=0,\dots,n$, where $h=(b-a)/n$.
> Then
> $$
> \|f-p_n\|_\infty \le M h^2,
> $$
> where $M=\|f''\|_\infty$.

这里的关键不是常数 $M$ 的精确系数，而是误差随 $h\to 0$ 呈 $O(h^2)$.

如果一个近似的误差是 $O(h^m)$，我们称它具有 **algebraic convergence**；若误差不是 $O(h^{m+1})$，则 $m$ 称为 **order of accuracy**.

> **Definition:** Algebraic convergence
> If an approximation has error that is $O(h^m)$ as $h\to 0$ for an integer $m$ and a discretization size parameter $h$, then we say the approximation has algebraic convergence. If the error is not also $O(h^{m+1})$, then $m$ is the order of accuracy.

> **Demo:** Measuring the convergence rate
> We measure the convergence rate for piecewise linear interpolation of $f(x)=e^{\\sin(7x)}$ on $[0,1]$.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> f = lambda x: np.exp(np.sin(7 * x))
>
> xfine = np.linspace(0.0, 1.0, 10001)
> ns = np.array([10, 20, 40, 80, 160, 320, 640, 1280], dtype=int)
> errs = []
>
> for n in ns:
>     t = np.linspace(0.0, 1.0, n + 1)
>     p = plinterp(t, f(t))
>     errs.append(np.max(np.abs(f(xfine) - p(xfine))))
>
> errs = np.array(errs)
> h = 1.0 / ns
>
> # Reference O(h^2) line.
> ref = errs[0] * (h / h[0])**2
>
> plt.loglog(h, errs, marker="o", label="error")
> plt.loglog(h, ref, ls="--", label=r"$O(h^2)$")
> plt.gca().invert_xaxis()  # traditional: h decreases left-to-right
> plt.xlabel("h")
> plt.ylabel(r"$||f-p||_\infty$")
> plt.title("Convergence of PL interpolation")
> plt.grid(True, which="both", alpha=0.3)
> plt.legend()
> plt.show()
> ```
> On a log-log plot, second-order convergence appears as an approximately straight line with slope 2.
