# 2-1-多项式插值 (Polynomial interpolation)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记比较特殊，主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 多项式插值问题**

美国每 10 年进行一次人口普查. 如果我们想知道两次普查之间某一年的近似人口，或者想预测未来人口，一个常见技巧是找一条穿过所有数据点的多项式曲线.

> **Definition:** **Polynomial interpolation.**
> Given $n$ points $(t_1,y_1),\dots,(t_n,y_n)$, where the $t_i$ are all distinct, the polynomial interpolation problem is to find a polynomial $p$ of degree less than $n$ such that $p(t_i)=y_i$ for all $i$.

由前面的 Definition，**多项式插值问题**有唯一解. 一旦找到插值多项式，我们就可以在任意位置对它求值，用来做估计或预测.

> **Note:** "$p$ 的次数小于 $n$" 等价于 "$p$ 的次数至多为 $n-1$".

> **Note:** 这里要求 $t_i$ 互不相同，是为了避免约束退化. 如果某个 $t$ 重复出现但对应不同的 $y$，则不存在多项式能同时穿过这些点；如果某个 $t$ 重复出现且对应相同的 $y$，则这些重复点不提供额外约束，在仍允许 $p$ 的次数小于 $n$ 的前提下，插值多项式不再唯一.

> **Note:** 我们几乎可以确定，现实中的人口普查机构会使用比这里更复杂的建模方法.

**#2 把插值写成线性系统**

给定数据 $(t_i,y_i)$，其中 $i=1,\dots,n$，我们希望找到一个多项式

$$
p(t)=c_1+c_2 t+c_3 t^2+\cdots+c_n t^{n-1},
$$

使得对所有 $i$ 都满足 $y_i=p(t_i)$. 这些条件用来确定系数 $c_1,\dots,c_n$.

把条件逐个写开，我们得到

$$
\begin{aligned}
c_1+c_2 t_1+c_3 t_1^2+\cdots+c_n t_1^{n-1} &= y_1,\\
c_1+c_2 t_2+c_3 t_2^2+\cdots+c_n t_2^{n-1} &= y_2,\\
&\vdots\\
c_1+c_2 t_n+c_3 t_n^2+\cdots+c_n t_n^{n-1} &= y_n.
\end{aligned}
$$

这是一组关于系数 $c_1,\dots,c_n$ 的线性方程. 写成矩阵形式就是

$$
\begin{bmatrix}
1&t_1&\cdots&t_1^{n-2}&t_1^{n-1}\\
1&t_2&\cdots&t_2^{n-2}&t_2^{n-1}\\
\vdots&\vdots&&\vdots&\vdots\\
1&t_n&\cdots&t_n^{n-2}&t_n^{n-1}
\end{bmatrix}
\begin{bmatrix}
c_1\\
c_2\\
\vdots\\
c_n
\end{bmatrix}
=
\begin{bmatrix}
y_1\\
y_2\\
\vdots\\
y_n
\end{bmatrix}.
$$

我们也可以把它简写为 $\mathbf{V}\mathbf{c}=\mathbf{y}$. 这里的矩阵 $\mathbf{V}$ 是一种特殊的矩阵.

> **Note:** 如果我们用 $i$ 表示行指标，$j$ 表示列指标，并且让 $j=1$ 对应常数项，那么上面的矩阵元素就是 $(\mathbf{V})_{ij}=t_i^{j-1}$. 在 Demo 里，`np.vander(t, N=n, increasing=True)` 生成的正是列按 $t^0,t^1,\dots,t^{n-1}$ 排列的 Vandermonde 矩阵；如果不加 `increasing=True`，列顺序会反过来.

> **Definition:** **Vandermonde matrix.**
> Given distinct values $t_1,\dots,t_n$, a Vandermonde matrix for these values is the $n\times n$ matrix appearing above.

因此，多项式插值可以被表述为一个带 **Vandermonde matrix** (Vandermonde 矩阵) 的线性方程组.

> **Note:** Vandermonde 矩阵的行列式有显式公式.
> $$
> \det(\mathbf{V})=\prod_{1\le i<j\le n}(t_j-t_i).
> $$
> 当 $t_i$ 互不相同时，$\det(\mathbf{V})\ne 0$，因此 $\mathbf{V}$ 可逆，这也解释了前面 "插值解唯一" 的结论.

> **Note:** 下面的 Demo 默认在同一个 Python 环境中运行，并且已经安装 `numpy` 与 `matplotlib`.

给出一个具体例子. 我们用中国人口的普查数据构造插值多项式. 这里有 4 个数据点，因此 $n=4$，我们要找一个三次插值多项式，并用它来估计某一年的人口.

> **Demo:** Polynomial interpolation for China's population.
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> from numpy.polynomial import Polynomial
>
> # Census years and population (millions).
> year = np.array([1982, 2000, 2010, 2015], dtype=float)
> pop = np.array([1008.18, 1262.64, 1337.82, 1374.62], dtype=float)
>
> # Shift time so that t=0 corresponds to year 1980.
> t = year - 1980.0
> y = pop
>
> # Vandermonde matrix for a cubic interpolant (degree 3).
> V = np.vander(t, N=4, increasing=True)
> print("V =\n", V)
>
> # Solve V c = y for the coefficients in increasing-degree order.
> c = np.linalg.solve(V, y)
> print("c =", c)
>
> # Check the residual.
> r = y - V @ c
> print("residual =", r)
>
> # Compare the relative residual to machine epsilon.
> eps_mach = np.finfo(float).eps
> rel_res = np.linalg.norm(r, np.inf) / np.linalg.norm(y, np.inf)
> print("relative residual =", rel_res)
> print("eps_mach =", eps_mach)
>
> # Build the interpolating polynomial and evaluate it.
> p = Polynomial(c)
> print("population estimate for 2005 =", p(2005 - 1980))
>
> # Plot the data and the interpolant on [0, 35].
> tt = np.linspace(0, 35, 500)
> yy = p(tt)
> for val in yy[:4]:
>     print(val)
>
> plt.scatter(t, y, label="actual")
> plt.plot(tt, yy, label="interpolant")
> plt.xlabel("years since 1980")
> plt.ylabel("population (millions)")
> plt.title("Population of China")
> plt.legend()
> plt.show()
> ```
> The residual is not exactly zero in floating-point arithmetic.
> The official population value for 2005 was 1303.72, so this estimate is rather good.

> **Note:** 这里把自变量做一次平移：令 $t=s-1980$，其中 $s$ 表示原始年份. 插值多项式写成 $p(t)$；把它写回到年份 $s$ 上就是 $q(s)=p(s-1980)$. 因此预测年份 $s$ 时，需要代入 $t=s-1980$. 平移使得 Vandermonde 矩阵的数值量级变小，条件数降低，从而提高了线性系统求解的稳定性.

> **Note:** 下面的代码用于对比平移前后 Vandermonde 矩阵的条件数 (参见 **1-2-问题与条件数** 里的条件数概念).
> ```Python
> V_year = np.vander(year, N=4, increasing=True)
> V_shift = np.vander(t, N=4, increasing=True)
> print("cond(V_year) =", np.linalg.cond(V_year))
> print("cond(V_shift) =", np.linalg.cond(V_shift))
> ```
> In this example, the condition number drops by many orders of magnitude after the time shift.

> **Note:** 这里的三行 Python 代码分别对应教材 Julia 的 "点运算"、"comprehension 构造矩阵"、"反斜杠求解线性系统"：
> - `year - 1980.0`：逐元素减法.
> - `np.vander(t, N=4, increasing=True)`：构造 Vandermonde 矩阵.
> - `np.linalg.solve(V, y)`：求解线性系统 $\mathbf{V}\mathbf{c}=\mathbf{y}$.

线性系统求解器内部使用的算法是本章的主要主题. 作为对解的一个检验，我们可以计算 **残差** $\mathbf{r}=\mathbf{y}-\mathbf{V}\mathbf{c}$. 在浮点数计算中，我们不太可能得到完全为零的残差；我们更关注相对残差是否能达到与 $\epsilon_{\rm mach}$ 同数量级的水平.

> **Note:** 这里的 $\epsilon_{\rm mach}$ 是 **1-1-浮点数** 里定义的机器精度，即 $1$ 的下一个更大浮点数与 $1$ 的差值.
