# 2-2-矩阵计算 (Computing with matrices)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记比较特殊，主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 记号约定**

在进一步讨论线性系统之前，我们先把本章会反复用到的矩阵与向量记号整理清楚.

在数值计算里，**矩阵** 既可以被看成 "一张遵循代数规则的数表"，也更常被看成 **"作用在向量上的线性算子"**. 另一方面，**向量** 也远不止微积分里常见的三维物理量表示，在计算里它通常用来承载 **高维数据**.

我们用粗体大写字母表示矩阵，例如 $\mathbf{A}$；用粗体小写字母表示向量，例如 $\mathbf{x}$. 在后续讨论里，我们把向量默认理解为列向量. 记号 $\mathbf{0}$ 可能表示零向量或零矩阵 (由上下文决定)，而标量 0 只表示数值零.

为了引用矩阵的某个元素，我们用去掉粗体的矩阵名并加上下标，例如 $A_{24}$ 表示 $\mathbf{A}$ 的第 (2,4) 个元素 (第 2 行、第 4 列). 为了引用向量的某个元素，我们用一个下标，例如 $x_3$.

> **Note:** 这里用 $A_{24}$ 而不是更常见的 $a_{24}$，是为了更接近代码里的写法.

我们经常需要把 **矩阵的列** 当作向量来引用. 约定是：用矩阵名对应的小写粗体字母加下标表示列号. 例如 $\mathbf{a}_1,\mathbf{a}_2,\dots,\mathbf{a}_n$ 表示 $m\times n$ 矩阵 $\mathbf{A}$ 的各列. 反过来，如果我们定义了一组向量 $\mathbf{v}_1,\dots,\mathbf{v}_p$，也可以把它们视为某个矩阵 $\mathbf{V}$ 的列，并在需要强调时写作 $\mathbf{V}=[\mathbf{v}_j]$.

矩阵的 **转置** 记为 $\mathbf{A}^{T}$，无论 $\mathbf{A}$ 是实矩阵还是复矩阵. 对复矩阵，更常用的是 **共轭转置** (**adjoint**) $\mathbf{A}^{*}$，它等于转置后再对每个元素取共轭. 若 $\mathbf{A}$ 为实矩阵，则 $\mathbf{A}^{*}=\mathbf{A}^{T}$. 若 $\mathbf{A}$ 为方阵并满足 $\mathbf{A}^{T}=\mathbf{A}$，则称其为对称矩阵.

> **Note:** 复数 $a+bi$ 的共轭是 $a-bi$，也就是把虚数单位 $i$ 替换为 $-i$.

大小为 $n$ 的单位矩阵记为 $\mathbf{I}$，必要时也写作 $\mathbf{I}_n$. 单位矩阵的列向量记为 $\mathbf{e}_j$ (这与我们给矩阵列向量命名的惯例略有不同).

**#2 分块矩阵表达式**

我们经常把一个矩阵拆成若干块来写，例如

$$
\mathbf{A}=
\begin{bmatrix}
\mathbf{A}_{11}&\mathbf{A}_{12}&\mathbf{A}_{13}\\
\mathbf{A}_{21}&\mathbf{A}_{22}&\mathbf{A}_{23}
\end{bmatrix},
\qquad
\mathbf{B}=
\begin{bmatrix}
\mathbf{B}_1\\
\mathbf{B}_2\\
\mathbf{B}_3
\end{bmatrix}.
$$

这里默认理解：上下叠放的块具有相同列数，左右并排的块具有相同行数. 在维度兼容时，分块矩阵可以像标量一样做乘法. 例如上面的 $\mathbf{A}$ 是 block-$2\times 3$，$\mathbf{B}$ 是 block-$3\times 1$，于是

$$
\mathbf{A}\mathbf{B}=
\begin{bmatrix}
\mathbf{A}_{11}\mathbf{B}_1+\mathbf{A}_{12}\mathbf{B}_2+\mathbf{A}_{13}\mathbf{B}_3\\
\mathbf{A}_{21}\mathbf{B}_1+\mathbf{A}_{22}\mathbf{B}_2+\mathbf{A}_{23}\mathbf{B}_3
\end{bmatrix},
$$

前提是每一个块乘积本身都有定义. 转置也可以逐块进行，例如

$$
\mathbf{A}^{T}=
\begin{bmatrix}
\mathbf{A}_{11}^{T}&\mathbf{A}_{21}^{T}\\
\mathbf{A}_{12}^{T}&\mathbf{A}_{22}^{T}\\
\mathbf{A}_{13}^{T}&\mathbf{A}_{23}^{T}
\end{bmatrix}.
$$

**#3 Python 中的向量与矩阵**

在 Python 生态里，我们通常用 NumPy 的数组来表示向量与矩阵. 下面的 Demo 只覆盖最常用的一组操作，后续章节会不断用到它们.

> **Demo:** Basic vectors and matrices in Python (NumPy).
> ```Python
> import numpy as np
>
> # A 3x5 matrix.
> A = np.array(
>     [
>         [1, 2, 3, 4, 5],
>         [50, 40, 30, 20, 10],
>         [np.pi, np.sqrt(2), np.e, (1 + np.sqrt(5)) / 2, np.log(3)],
>     ],
>     dtype=float,
> )
> print(A)
> print("shape(A) =", A.shape)
>
> # A length-5 vector (1D array).
> x = np.array([3, 3, 0, 1, 0], dtype=int)
> print(x)
> print("shape(x) =", x.shape)
>
> # Block-style concatenation.
> print(np.column_stack([x, x]))        # 5x2
> print(np.concatenate([x, x]))         # length 10
>
> # Zeros / ones.
> B = np.hstack([np.zeros((3, 2)), np.ones((3, 1))])
> print(B)
>
> # Transpose.
> print(A.T)
> print(x.reshape(1, -1))               # a 1x5 "row-shaped" view
>
> # Evenly spaced grids.
> y = np.arange(1, 5)                   # 1,2,3,4
> z = np.arange(0, 13, 3)               # 0,3,6,9,12
> s = np.linspace(-1, 1, 5)             # 5 points in [-1,1]
> print(y, z, s)
>
> # Indexing and slicing.
> a = A[1, -2]                           # second row, second-to-last column
> print("a =", a)
> print(A[0:2, -3:])                     # first two rows, last three columns
> print(A[:, 0::2])                      # columns 1,3,5 in 1-based indexing
>
> # Matrix operations: use @ for matrix product, * for elementwise product.
> D = np.diag([-1, 0, -5])
> print(D @ A)
> print(A * (-A))
>
> # Elementwise power and broadcasting of functions.
> print(x**2)
> print(2**x)
> print(np.cos(np.pi * x))
> print(np.cos(np.pi * (x + 1) ** 3))
> ```
> In NumPy, `@` is matrix multiplication and `*` is elementwise multiplication.

> **Note:** Python 的下标从 0 开始，且切片遵循 "左闭右开" 的规则，例如 `A[0:2, -3:]` 表示第 0,1 行与最后 3 列. 对照数学里常用的 1-based 下标时，我们需要在心里做一次 "1-based -> 0-based" 的转换.

> **Note:** `np.arange(start, stop, step)` 生成等差序列 (不包含 `stop`)，`np.linspace(a, b, m)` 生成包含端点的等分网格. 它们都常用来构造离散采样点.

> **Note:** `np.cos(np.pi * x)` 这类写法依赖 NumPy 的 **broadcasting** 规则：标量或低维数组会被自动扩展到与目标数组兼容的形状，然后逐元素计算.

**#4 行与列操作**

矩阵乘法里一个关键恒等式是

$$
\mathbf{A}\mathbf{e}_j=\mathbf{a}_j.
$$

> **Observation:** Multiplication on the right by column $j$ of the identity reproduces the $j$th column of a matrix.

进一步地，表达式 $\mathbf{A}[\mathbf{e}_1\ \mathbf{e}_3\ \mathbf{e}_5]$ 会提取出第 1,3,5 列. 在 Python 里，对应的写法通常是用列切片 (例如 `A[:, 0::2]`).

同样的思想也可以用于行. 令 $\mathbf{B}=\mathbf{A}^{T}$ 的列为 $\mathbf{b}_j$，则

$$
(\mathbf{b}_j)^{T}=(\mathbf{B}\mathbf{e}_j)^{T}=\mathbf{e}_j^{T}\mathbf{B}^{T}=\mathbf{e}_j^{T}\mathbf{A}.
$$

这里 $\mathbf{e}_j^{T}$ 是 $\mathbf{I}$ 的第 $j$ 行，而 $(\mathbf{b}_j)^{T}$ 正是 $\mathbf{A}$ 的第 $j$ 行. 因此，左乘 $\mathbf{e}_j^{T}$ 会提取第 $j$ 行. 进一步地，从矩阵中取出单个元素 $(i,j)$ 可以写成

$$
\mathbf{e}_i^{T}\mathbf{A}\mathbf{e}_j.
$$

能够抽取指定的行与列后，我们就可以方便地做面向行或列的运算 (例如线性组合).

> **Example:** Say that $\mathbf{A}$ has five columns. Adding twice the third column of $\mathbf{A}$ to its first column is done by $\mathbf{A}(\mathbf{e}_1+2\mathbf{e}_3)$. Suppose we want to do this operation "in place," meaning replacing the first column of $\mathbf{A}$ with this value and leaving the other four columns of $\mathbf{A}$ alone. We can replace $\mathbf{A}$ with $\mathbf{A}[\mathbf{e}_1+2\mathbf{e}_3\ \mathbf{e}_2\ \mathbf{e}_3\ \mathbf{e}_4\ \mathbf{e}_5]$.

> **Note:** 在 Python 里，这类 "就地更新某一列" 的写法通常是 `A[:, 0] += 2 * A[:, 2]`，直接在原数组上运算在数值线性代数里非常常见，因为它往往可以减少额外的内存分配，也更贴近后续的消元过程.
