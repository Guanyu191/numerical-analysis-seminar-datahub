# 2-6-行主元 (Row pivoting)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 为什么需要行交换**

在 **2-4-LU 分解** 里，我们的分解 $\mathbf{A}=\mathbf{L}\mathbf{U}$ 不一定是稳定的 (即便 $\mathbf{A}$ 本身非奇异). 具体来说，普通的 LU 分解有两类问题：

- 分解不一定存在：算法可能在某一步遇到 0 主元 (pivot)，不得不做除以 0 的运算.
- 即使能做完，数值上也可能很不稳定.

下面的 Demo 展示第一类问题：一个矩阵本来可以顺利做出 LU 分解，但只要把两行交换，算法就会因为 0 主元而卡住. 这说明 LU 分解对行顺序很敏感，因此我们要对行顺序进行调整，确保每次都选到非 0 主元.

> **Note:** **Pivot (主元)** 是指在 LU 分解中，每次消元时用来除的那个元素 $U_{kk}$，它一般是 $U$ 的对角元.

> **Demo:** Unpivoted LU can fail after a row swap.
> ```Python
> import numpy as np
>
> def lufact(A):
>     """Compute A = L U without pivoting. Raises if a zero pivot appears."""
>     A = np.array(A, dtype=float, copy=True)
>     n = A.shape[0]
>     L = np.eye(n)
>     U = np.zeros((n, n), dtype=float)
>     Ak = A.copy()
>
>     for k in range(n - 1):
>         U[k, :] = Ak[k, :]
>         if U[k, k] == 0:
>             raise ZeroDivisionError(f"zero pivot encountered at k={k}")
>         L[:, k] = Ak[:, k] / U[k, k]
>         Ak = Ak - np.outer(L[:, k], U[k, :])
>
>     U[-1, -1] = Ak[-1, -1]
>     return L, U
>
> A = np.array(
>     [
>         [2, 0, 4, 3],
>         [-4, 5, -7, -10],
>         [1, 15, 2, -4.5],
>         [-2, 0, 2, -13],
>     ],
>     dtype=float,
> )
>
> L, U = lufact(A)
> print("||A-LU||_inf =", np.linalg.norm(A - L @ U, np.inf))
>
> A2 = A.copy()
> A2[[1, 3], :] = A2[[3, 1], :]
> try:
>     lufact(A2)
> except ZeroDivisionError as e:
>     print("factorization failed:", e)
> ```
> The failure is caused by a zero pivot, even though the matrix remains nonsingular.

> **Note:** 在代码里做一次行交换 `A2[[i, j], :] = A2[[j, i], :]`，等价于在数学上左乘一个置换矩阵 $\mathbf{P}$，得到 $\mathbf{A}_2=\mathbf{P}\mathbf{A}$. 虽然 $\mathbf{A}$ 与 $\mathbf{P}\mathbf{A}$ 表示的是同一个线性系统 (只是把方程顺序重排了)，但普通的 LU 分解算法可能中途遇到 0 主元导致失效.

**#2 选主元的规则**

为了避免 0 主元，我们允许在消元过程中对行进行交换. 在 **第 $j$ 列做消元时**，我们从当前可用的行里挑一个主元，用它作为 $U$ 的第 $j$ 行的来源. 一个自然且非常有效的规则是：选绝对值最大的那个作为主元.

> **Algorithm:** **Row pivoting.**
> When performing elimination in column $j$, choose as the pivot the element in column $j$ that is largest in absolute value. (In case of ties, choose the lowest row index.)

这个规则表面上是在 "避免除以 0"，但更重要的原因是稳定性：较大的主元通常能减少倍乘子放大误差的风险 (见后面的 **#4 稳定性**).

**#3 置换与 PLU 分解**

Row pivoting (行主元) 会产生一串被选中的行号. 如果我们把原矩阵 $\mathbf{A}$ 的行一次性按这个顺序重排成 $\tilde{\mathbf{A}}$，那么后续就可以像 **2-4-LU 分解** 那样做普通的 LU 分解.

> **Definition:** **PLU factorization.**
> Given $n\times n$ matrix $\mathbf{A}$, the PLU factorization is a unit lower triangular $\mathbf{L}$, an upper triangular $\mathbf{U}$, and a permutation of the rows such that
> $$
> \tilde{\mathbf{A}} = \mathbf{L}\mathbf{U},
> $$
> where rows $1,\dots,n$ of $\tilde{\mathbf{A}}$ are rows $i_1,\dots,i_n$ of $\mathbf{A}$ for some permutation $i_1,\dots,i_n$ of $1,\dots,n$.

在代码里，我们通常用一个置换向量 `p` 表示 $\tilde{\mathbf{A}}$ 的行来自 $\mathbf{A}$ 的哪些行，写为 `A_tilde = A[p, :]`，这等价于在数学上左乘一个置换矩阵 $\mathbf{P}$，即 $\tilde{\mathbf{A}} = \mathbf{P}\mathbf{A}$. 接下来我们从代码和公式分别来理解 PLU.

若 `p` 表示行的新顺序，`A_tilde = A[p, :]`，那么我们需要把右端项也做同样的行置换，得到 `b_tilde = b[p]`，再解 `A_tilde @ x = b_tilde`，这相当于重排线性系统的方程顺序，因此不会改变解.

对应地，原线性系统 $\mathbf{A}\mathbf{x}=\mathbf{b}$ 改写为 $\mathbf{P}\mathbf{A}\mathbf{x}=\mathbf{P}\mathbf{b}$，解不变. 

但注意，在求解时，我们是对 $\tilde{\mathbf{A}} = \mathbf{P}\mathbf{A}$ 做了 LU 分解. 所以我们要先算 $\tilde{\mathbf{b}}=\mathbf{P}\mathbf{b}$，再依次解 $\mathbf{L}\mathbf{z}=\tilde{\mathbf{b}}$ 与 $\mathbf{U}\mathbf{x}=\mathbf{z}$.

> **Theorem:** **Row pivoting.**
> The row-pivoted LU factorization runs to completion if and only if the original matrix is invertible.

> **Note:** 这里的 "runs to completion" 指的是在每一步都能找到可用主元，因此不会出现 "no available pivot" 这类失败情形. 证明 "能跑完 $\Leftrightarrow$ $\mathbf{A}$ 可逆" 需要更深入的线性代数工具，这里先把它当作事实. 若 $\mathbf{A}$ 奇异，则线性系统可能无解或有无穷多解，因此需要不同于 LU 分解的处理方式.

下面的 Demo 给出一个具体的例子：它返回 $\tilde{\mathbf{A}}=\mathbf{L}\mathbf{U}$ 的三元组 `(L, U, p)`，并展示如何用它来解线性系统.

> **Demo:** A simple PLU factorization (`plufact`) and linear-system solve.
> ```Python
> import numpy as np
>
> def forwardsub(L, b):
>     n = L.shape[0]
>     x = np.zeros(n, dtype=float)
>     x[0] = b[0] / L[0, 0]
>     for i in range(1, n):
>         x[i] = (b[i] - np.dot(L[i, :i], x[:i])) / L[i, i]
>     return x
>
> def backsub(U, b):
>     n = U.shape[0]
>     x = np.zeros(n, dtype=float)
>     x[-1] = b[-1] / U[-1, -1]
>     for i in range(n - 2, -1, -1):
>         x[i] = (b[i] - np.dot(U[i, i + 1 :], x[i + 1 :])) / U[i, i]
>     return x
>
> def plufact(A):
>     """Row-pivoted LU producing A[p,:] = L U (L is unit lower triangular)."""
>     A = np.array(A, dtype=float, copy=True)
>     n = A.shape[0]
>     L = np.zeros((n, n), dtype=float)
>     U = np.zeros((n, n), dtype=float)
>     p = np.zeros(n, dtype=int)
>     Ak = A.copy()
>
>     for k in range(n - 1):
>         p[k] = int(np.argmax(np.abs(Ak[:, k])))
>         U[k, :] = Ak[p[k], :]
>         if U[k, k] == 0:
>             raise ZeroDivisionError("no available pivot")
>         L[:, k] = Ak[:, k] / U[k, k]
>         Ak = Ak - np.outer(L[:, k], U[k, :])
>
>     p[-1] = int(np.argmax(np.abs(Ak[:, -1])))
>     U[-1, -1] = Ak[p[-1], -1]
>     if U[-1, -1] == 0:
>         raise ZeroDivisionError("no available pivot in last column")
>     L[:, -1] = Ak[:, -1] / U[-1, -1]
>
>     # Reorder rows of L into triangular form.
>     L = L[p, :]
>     return L, U, p
>
> rng = np.random.default_rng(0)
> A = rng.integers(1, 20, size=(4, 4)).astype(float)
> L, U, p = plufact(A)
> print("||A[p,:] - L@U||_inf =", np.linalg.norm(A[p, :] - L @ U, np.inf))
>
> b = rng.standard_normal(4)
> z = forwardsub(L, b[p])
> x = backsub(U, z)
> print("||b - A@x||_inf =", np.linalg.norm(b - A @ x, np.inf))
> ```
> The same row permutation must be applied to `b` before the triangular solves.

> **Note:** 这里 `p` 是 0-based 下标，因此 `A[p, :]` 与 `b[p]` 都是在 Python 里直接可用的置换. 若用数学记号 $i_1,\dots,i_n$ 则是 1-based 的下标.

在实践中，如果要用同一个 $\mathbf{A}$ 反复解不同的右端项 $\mathbf{b}$，我们也可以把分解结果缓存起来，以提高计算效率.

> **Demo:** Reusing an LU factorization for many right-hand sides (SciPy).
> ```Python
> import time
> import numpy as np
> from scipy.linalg import lu_factor, lu_solve
>
> rng = np.random.default_rng(0)
> n = 400
> A = rng.standard_normal((n, n))
> B = rng.standard_normal((n, 30))  # 30 right-hand sides
>
> # Solve by refactorizing each time.
> t0 = time.perf_counter()
> X1 = np.column_stack([np.linalg.solve(A, B[:, k]) for k in range(B.shape[1])])
> t1 = time.perf_counter()
>
> # Solve by factoring once.
> lu, piv = lu_factor(A)
> t2 = time.perf_counter()
> X2 = np.column_stack([lu_solve((lu, piv), B[:, k]) for k in range(B.shape[1])])
> t3 = time.perf_counter()
>
> print("refactor each solve:", t1 - t0)
> print("factor once + solves:", (t2 - t1) + (t3 - t2))
> print("||X1-X2||_inf =", np.linalg.norm(X1 - X2, np.inf))
> ```
> Factoring once is typically much faster when there are many right-hand sides.

**#4 稳定性**

行主元为什么不直接选一个非零元，而要选绝对值最大的元素？答案是数值稳定性.

下面的例子非常典型：原问题本身是良态的，但如果我们用普通的 LU 去解，它会把一个温和的问题拆成两个非常病态的三角子问题，从而让浮点误差被放大得很厉害.

> **Demo:** Unpivoted LU can be highly unstable even when the system is well-conditioned.
> ```Python
> import numpy as np
> from scipy.linalg import lu_factor, lu_solve
>
> def lufact(A):
>     A = np.array(A, dtype=float, copy=True)
>     n = A.shape[0]
>     L = np.eye(n)
>     U = np.zeros((n, n), dtype=float)
>     Ak = A.copy()
>     for k in range(n - 1):
>         U[k, :] = Ak[k, :]
>         L[:, k] = Ak[:, k] / U[k, k]
>         Ak = Ak - np.outer(L[:, k], U[k, :])
>     U[-1, -1] = Ak[-1, -1]
>     return L, U
>
> def forwardsub(L, b):
>     x = np.zeros_like(b, dtype=float)
>     x[0] = b[0] / L[0, 0]
>     for i in range(1, len(b)):
>         x[i] = (b[i] - np.dot(L[i, :i], x[:i])) / L[i, i]
>     return x
>
> def backsub(U, b):
>     x = np.zeros_like(b, dtype=float)
>     x[-1] = b[-1] / U[-1, -1]
>     for i in range(len(b) - 2, -1, -1):
>         x[i] = (b[i] - np.dot(U[i, i + 1 :], x[i + 1 :])) / U[i, i]
>     return x
>
> for eps in [1e-12, 1e-20]:
>     A = np.array([[-eps, 1.0], [1.0, -1.0]])
>     b = A @ np.array([1.0, 1.0])
>
>     L, U = lufact(A)
>     x_unpivoted = backsub(U, forwardsub(L, b))
>
>     lu, piv = lu_factor(A)
>     x_pivoted = lu_solve((lu, piv), b)
>
>     print("eps =", eps)
>     print("unpivoted LU:", x_unpivoted)
>     print("pivoted solve:", x_pivoted)
> ```
> Pivoting recovers the correct solution `[1, 1]`, while the unpivoted LU route can lose many digits.

> **Note:** 上面这个现象不是因为 $\mathbf{A}\mathbf{x}=\mathbf{b}$ 本身病态. 例如当 $\epsilon=10^{-12}$ 或 $\epsilon=10^{-20}$ 时，$\kappa_2(\mathbf{A})\approx 2.618$，它是数量级为 $O(1)$ 的条件数.
> 
> 问题在于普通的第一步 pivot 是 $-\epsilon$ (非常小)，倍乘子会出现 $\epsilon^{-1}$ 的量级. 对这个 $2\times 2$ 的例子，我们甚至可以把普通的 LU 写出来：
> $$
> \mathbf{A}=
> \begin{bmatrix}
> -\epsilon & 1\\
> 1 & -1
> \end{bmatrix},
> \qquad
> \mathbf{L}=
> \begin{bmatrix}
> 1 & 0\\
> -\epsilon^{-1} & 1
> \end{bmatrix},
> \qquad
> \mathbf{U}=
> \begin{bmatrix}
> -\epsilon & 1\\
> 0 & -1+\epsilon^{-1}
> \end{bmatrix}.
> $$
> 这里 $\epsilon^{-1}$ 进入了 $\mathbf{L},\mathbf{U}$ 的元素规模，因此两次三角代回会强烈放大舍入误差. 在 **2-8-线性系统的条件数** 里，我们会用条件数与反向误差把这件事说得更详细一些.

在一般线性系统里，带行主元的 LU (即 PLU) 依然是最常用的直接法. 虽然它在理论上存在构造性的不稳定例子，但在实际应用中极少出问题，因此仍是默认选择.

> **Note:** 在数值线性代数的语境里，单说 "LU 分解" 往往默认指带 **行主元的版本**，因为普通的 LU 很少能作为通用求解器直接使用.
