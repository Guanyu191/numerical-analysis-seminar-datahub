# 2-4-LU 分解 (LU factorization)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 外积与矩阵乘法**

数值线性代数里一个非常常用的策略是把一个矩阵分解成若干个 "更容易处理" 的因子. 这一节我们要推导一种把方阵写成两个三角矩阵乘积的方法. 这样有个好处：如果我们把线性系统 $\mathbf{A}\mathbf{x}=\mathbf{b}$ 的矩阵 $\mathbf{A}$ 分解成 $\mathbf{A}=\mathbf{L}\mathbf{U}$，那么解系统可以被拆成一次前代和一次回代 (前代和回代见 **2-3-线性方程组**).

我们先看一个有意思且重要的性质：矩阵乘法可以用向量外积来表示.

若 $\mathbf{u}\in\mathbb{R}^m$ 且 $\mathbf{v}\in\mathbb{R}^n$，它们的 **outer product** (外积) 是一个 $m\times n$ 矩阵

$$
\mathbf{u}\mathbf{v}^{T}
=
\begin{bmatrix}
u_1\\
u_2\\
\vdots\\
u_m
\end{bmatrix}
\begin{bmatrix}
v_1 & v_2 & \cdots & v_n
\end{bmatrix}
=
\begin{bmatrix}
u_1v_1 & u_1v_2 & \cdots & u_1v_n\\
u_2v_1 & u_2v_2 & \cdots & u_2v_n\\
\vdots & \vdots & & \vdots\\
u_mv_1 & u_mv_2 & \cdots & u_mv_n
\end{bmatrix}.
$$

简单来说，向量的外积就是 "一列乘一行"，把两个一维向量 "扩" 成了一个矩阵. 实际上，矩阵的乘法也可以分解为若干个向量外积之和. 具体地，我们看下面的例子.

> **Example:** According to the usual definition of matrix multiplication,
> $$
> \begin{bmatrix}
> 4 & -1\\
> -3 & 5\\
> -2 & 6
> \end{bmatrix}
> \begin{bmatrix}
> 2 & -7\\
> -3 & 5
> \end{bmatrix}
> =
> \begin{bmatrix}
> (4)(2)+(-1)(-3) & (4)(-7)+(-1)(5)\\
> (-3)(2)+(5)(-3) & (-3)(-7)+(5)(5)\\
> (-2)(2)+(6)(-3) & (-2)(-7)+(6)(5)
> \end{bmatrix}.
> $$
> If we break this up into the sum of two matrices, however, each is an outer product:
> $$
> \begin{aligned}
> &\begin{bmatrix}
> (4)(2) & (4)(-7)\\
> (-3)(2) & (-3)(-7)\\
> (-2)(2) & (-2)(-7)
> \end{bmatrix}
> +
> \begin{bmatrix}
> (-1)(-3) & (-1)(5)\\
> (5)(-3) & (5)(5)\\
> (6)(-3) & (6)(5)
> \end{bmatrix}\\
> &=
> \begin{bmatrix}4\\-3\\-2\end{bmatrix}
> \begin{bmatrix}2&-7\end{bmatrix}
> +
> \begin{bmatrix}-1\\5\\6\end{bmatrix}
> \begin{bmatrix}-3&5\end{bmatrix}.
> \end{aligned}
> $$
> Note that the vectors here are columns of the left-hand matrix and rows of the right-hand matrix.

把上面的结构推广到一般的矩阵乘法，就得到一个非常有用的公式：矩阵乘积是若干个向量外积之和.

> **Theorem:** **Matrix multiplication by outer products.**
> Write the columns of $\mathbf{A}$ as $\mathbf{a}_1,\dots,\mathbf{a}_n$ and the rows of $\mathbf{B}$ as $\mathbf{b}_1^{T},\dots,\mathbf{b}_n^{T}$. Then
> $$
> \mathbf{A}\mathbf{B}=\sum_{k=1}^{n} \mathbf{a}_k\mathbf{b}_k^{T}.
> $$

**#2 三角矩阵乘积的结构**

令 $\mathbf{L}$ 为 $n\times n$ 下三角矩阵 (主对角线上方为 0)，$\mathbf{U}$ 为 $n\times n$ 上三角矩阵 (主对角线下方为 0). 把上面的外积分解公式应用到 $\mathbf{L}\mathbf{U}$，会出现一种很特殊的结构.

> **Demo:** Outer products in a triangular product.
> ```Python
> import numpy as np
>
> # Fix the seed and use small integers for readability.
> rng = np.random.default_rng(0)
> L = np.tril(rng.integers(1, 10, size=(3, 3))).astype(int)
> U = np.triu(rng.integers(1, 10, size=(3, 3))).astype(int)
>
> print("L =\n", L)
> print("U =\n", U)
>
> # Outer products of columns of L and rows of U.
> for k in range(3):
>     outer = np.outer(L[:, k], U[k, :])
>     print(f"k={k+1}\n", outer)
>
> print("L@U =\n", L @ U)
> ```
> Due to triangular zeros, early outer products determine early rows/columns of the result.

> **Note:** 上面的 Demo 其实是在把 $\mathbf{L}\mathbf{U}$ 写成一串外积的求和，并观察每一项外积会影响乘积矩阵的哪些位置.

> **Note:** 以 $3\times 3$ 的三角矩阵为例，
> $$
> \mathbf{L}=
> \begin{bmatrix}
> L_{11} & 0 & 0\\
> L_{21} & L_{22} & 0\\
> L_{31} & L_{32} & L_{33}
> \end{bmatrix},
> \qquad
> \mathbf{U}=
> \begin{bmatrix}
> U_{11} & U_{12} & U_{13}\\
> 0 & U_{22} & U_{23}\\
> 0 & 0 & U_{33}
> \end{bmatrix}.
> $$
> 把 $\mathbf{L}$ 的列记为 $\boldsymbol{\ell}_1,\boldsymbol{\ell}_2,\boldsymbol{\ell}_3$，把 $\mathbf{U}$ 的行记为 $\mathbf{u}_1^{T},\mathbf{u}_2^{T},\mathbf{u}_3^{T}$，则
> $$
> \mathbf{L}\mathbf{U}
> =
> \boldsymbol{\ell}_1\mathbf{u}_1^{T}
> +\boldsymbol{\ell}_2\mathbf{u}_2^{T}
> +\boldsymbol{\ell}_3\mathbf{u}_3^{T}.
> $$
> 其中每一项都是 "一列乘一行" 的外积，并且它们有非常具体的零结构：
> $$
> \boldsymbol{\ell}_1\mathbf{u}_1^{T}=
> \begin{bmatrix}
> L_{11}U_{11} & L_{11}U_{12} & L_{11}U_{13}\\
> L_{21}U_{11} & L_{21}U_{12} & L_{21}U_{13}\\
> L_{31}U_{11} & L_{31}U_{12} & L_{31}U_{13}
> \end{bmatrix},
> \quad
> \boldsymbol{\ell}_2\mathbf{u}_2^{T}=
> \begin{bmatrix}
> 0 & 0 & 0\\
> 0 & L_{22}U_{22} & L_{22}U_{23}\\
> 0 & L_{32}U_{22} & L_{32}U_{23}
> \end{bmatrix},
> \quad
> \boldsymbol{\ell}_3\mathbf{u}_3^{T}=
> \begin{bmatrix}
> 0 & 0 & 0\\
> 0 & 0 & 0\\
> 0 & 0 & L_{33}U_{33}
> \end{bmatrix}.
> $$
> 因为对 $k\ge 2$，$\boldsymbol{\ell}_k$ 的前 $k-1$ 个分量必为 0，且 $\mathbf{u}_k^{T}$ 的前 $k-1$ 个分量也必为 0，所以第 $k$ 项外积只会落在右下角 (从第 $k$ 行第 $k$ 列开始) 的子块里，不会影响前 $k-1$ 行或前 $k-1$ 列. 这就是上面的 Demo 里 "前面的外积项先确定前面的行或列" 的原因.

为了把这个现象写成公式，令 $\mathbf{L}$ 的第 $k$ 列为 $\boldsymbol{\ell}_k$，令 $\mathbf{U}$ 的第 $k$ 行为 $\mathbf{u}_k^{T}$. 则

$$
\mathbf{L}\mathbf{U}=\sum_{k=1}^{n} \boldsymbol{\ell}_k\mathbf{u}_k^{T}.
$$

观察第一行：用 $\mathbf{e}_1^{T}$ 左乘，

$$
\mathbf{e}_1^{T}\mathbf{L}\mathbf{U}
=
\sum_{k=1}^{n} (\mathbf{e}_1^{T}\boldsymbol{\ell}_k)\mathbf{u}_k^{T}
=
L_{11}\mathbf{u}_1^{T}.
$$

也就是说，整个乘积矩阵的第一行只由 $\mathbf{U}$ 的第一行决定.

同理观察第一列：用 $\mathbf{e}_1$ 右乘，

$$
\mathbf{L}\mathbf{U}\mathbf{e}_1
=
\sum_{k=1}^{n} \boldsymbol{\ell}_k(\mathbf{u}_k^{T}\mathbf{e}_1)
=
U_{11}\boldsymbol{\ell}_1.
$$

也就是说，整个乘积矩阵的第一列只由 $\mathbf{L}$ 的第一列决定. 这两个计算就足以导出一个极其重要的算法.

**#3 从结构得到 LU 分解**

我们的目标是把给定的 $n\times n$ 矩阵 $\mathbf{A}$ 分解为三角乘积 $\mathbf{A}=\mathbf{L}\mathbf{U}$. 如果 $\mathbf{L}$ 是下三角、$\mathbf{U}$ 是上三角，那么这两个矩阵一共包含 $n^2+n$ 个可能非零的未知量. 因此我们约定

$$
L_{11}=\cdots=L_{nn}=1,
$$

使得 $\mathbf{L}$ 成为单位下三角矩阵，从而减少自由度并保证分解的唯一性.

下面的 Demo 用一个 $4\times 4$ 例子展示外积消去的过程：先根据 $\mathbf{A}$ 的第一行 / 第一列确定 $\mathbf{U}$ 的第一行与 $\mathbf{L}$ 的第一列，然后减去第一个外积项；再对剩余的右下子块重复相同的过程.

> **Demo:** A worked LU factorization by successive outer products.
> ```Python
> import numpy as np
>
> A = np.array(
>     [
>         [2, 0, 4, 3],
>         [-4, 5, -7, -10],
>         [1, 15, 2, -4.5],
>         [-2, 0, 2, -13],
>     ],
>     dtype=float,
> )
>
> n = A.shape[0]
> L = np.eye(n)
> U = np.zeros((n, n), dtype=float)
> Ak = A.copy()
>
> for k in range(n - 1):
>     U[k, :] = Ak[k, :]
>     L[:, k] = Ak[:, k] / U[k, k]
>     Ak = Ak - np.outer(L[:, k], U[k, :])
>
> U[n - 1, n - 1] = Ak[n - 1, n - 1]
> print("L =\n", L)
> print("U =\n", U)
> print("A - L@U =\n", A - L @ U)
> ```
> In floating point, the backward error `A - L@U` is expected to be small, not exactly zero.

> **Note:** 上面的 Demo 是把 LU 分解写成一串外积消去，我们进一步把具体计算步骤写出来. 要分解的矩阵 $\mathbf{A}$ 为
> $$
> \mathbf{A}=
> \begin{bmatrix}
> 2 & 0 & 4 & 3\\
> -4 & 5 & -7 & -10\\
> 1 & 15 & 2 & -4.5\\
> -2 & 0 & 2 & -13
> \end{bmatrix}.
> $$
> 我们把初始矩阵记为 $\mathbf{A}_1=\mathbf{A}$，并初始化 $\mathbf{L}=\mathbf{I}$，$\mathbf{U}=\mathbf{0}$. 用 $A_{ij}^{(k)}$ 表示 $\mathbf{A}_k$ 的元素. 在第 $k$ 步 (这里用 1-based 下标，代码中的 `k` 对应 $k+1$)：
>
> 1. 取当前矩阵 $\mathbf{A}_k$ 的第 $k$ 行作为 $\mathbf{U}$ 的第 $k$ 行：
> $$
> \mathbf{u}_k^{T}=\mathbf{e}_k^{T}\mathbf{A}_k.
> $$
> 这对应代码里的 `U[k, :] = Ak[k, :]`.
>
> 2. 取当前矩阵 $\mathbf{A}_k$ 的第 $k$ 列除以主元 $U_{kk}$，作为 $\mathbf{L}$ 的第 $k$ 列：
> $$
> \boldsymbol{\ell}_k=\frac{\mathbf{A}_k\mathbf{e}_k}{U_{kk}}.
> $$
> 这对应代码里的 `L[:, k] = Ak[:, k] / U[k, k]`. 由于前 $k-1$ 步已经把 $\mathbf{A}_k$ 的前 $k-1$ 行与前 $k-1$ 列清零，所以 $\boldsymbol{\ell}_k$ 的前 $k-1$ 个分量为 0，且第 $k$ 个分量 $L_{kk}=1$.
>
> 3. 用一个外积把第 $k$ 行与第 $k$ 列同时从剩余矩阵里消去，得到下一步的矩阵：
> $$
> \mathbf{A}_{k+1}=\mathbf{A}_k-\boldsymbol{\ell}_k\mathbf{u}_k^{T}.
> $$
> 这对应代码里的 `Ak = Ak - np.outer(L[:, k], U[k, :])`. 它会让 $\mathbf{A}_{k+1}$ 的第 $k$ 行与第 $k$ 列都变成 0，从而把问题缩小到右下角的更小子块上.
>
> 这个 $4\times 4$ 例子里，前三步分别是：
> $$
> \mathbf{u}_1^{T}=
> \begin{bmatrix}
> 2 & 0 & 4 & 3
> \end{bmatrix},
> \qquad
> \boldsymbol{\ell}_1=
> \begin{bmatrix}
> 1\\-2\\\frac{1}{2}\\-1
> \end{bmatrix},
> \qquad
> \mathbf{A}_2=
> \begin{bmatrix}
> 0 & 0 & 0 & 0\\
> 0 & 5 & 1 & -4\\
> 0 & 15 & 0 & -6\\
> 0 & 0 & 6 & -10
> \end{bmatrix}.
> $$
> $$
> \mathbf{u}_2^{T}=
> \begin{bmatrix}
> 0 & 5 & 1 & -4
> \end{bmatrix},
> \qquad
> \boldsymbol{\ell}_2=
> \begin{bmatrix}
> 0\\1\\3\\0
> \end{bmatrix},
> \qquad
> \mathbf{A}_3=
> \begin{bmatrix}
> 0 & 0 & 0 & 0\\
> 0 & 0 & 0 & 0\\
> 0 & 0 & -3 & 6\\
> 0 & 0 & 6 & -10
> \end{bmatrix}.
> $$
> $$
> \mathbf{u}_3^{T}=
> \begin{bmatrix}
> 0 & 0 & -3 & 6
> \end{bmatrix},
> \qquad
> \boldsymbol{\ell}_3=
> \begin{bmatrix}
> 0\\0\\1\\-2
> \end{bmatrix},
> \qquad
> \mathbf{A}_4=
> \begin{bmatrix}
> 0 & 0 & 0 & 0\\
> 0 & 0 & 0 & 0\\
> 0 & 0 & 0 & 0\\
> 0 & 0 & 0 & 2
> \end{bmatrix}.
> $$
> 因此最后一步只剩下右下角的 $1\times 1$ 元素，直接读出 $U_{44}=2$ 即可.

> **Definition:** **LU factorization.**
> Given $n\times n$ matrix $\mathbf{A}$, its LU factorization is
> $$
> \mathbf{A}=\mathbf{L}\mathbf{U},
> $$
> where $\mathbf{L}$ is a unit lower triangular matrix and $\mathbf{U}$ is an upper triangular matrix.

上面的外积消去过程可以写成一个函数.

> **Demo:** A simple LU factorization routine (not stable).
> ```Python
> import numpy as np
>
> def lufact(A):
>     """Compute an LU factorization A = L U without pivoting (not stable)."""
>     A = np.array(A, dtype=float, copy=True)
>     n = A.shape[0]
>     L = np.eye(n)
>     U = np.zeros((n, n), dtype=float)
>     Ak = A.copy()
>
>     for k in range(n - 1):
>         U[k, :] = Ak[k, :]
>         L[:, k] = Ak[:, k] / U[k, k]
>         Ak = Ak - np.outer(L[:, k], U[k, :])
>
>     U[n - 1, n - 1] = Ak[n - 1, n - 1]
>     return L, U
> ```
> This follows the outer-product reduction shown in the previous demo.

**#4 高斯消元与用 LU 解线性系统**

在初等线性代数里，我们通常用 **Gaussian elimination** (高斯消元) 解线性系统：把增广矩阵 $[\mathbf{A}\ \mathbf{b}]$ 做行变换，直到左侧变成上三角，再用回代求解. 不进行换行的高斯消元与 LU 分解是等价的：消元过程中产生的行倍乘子 (row multipliers) 正是 $\mathbf{L}$ 的对角下方的元素.

LU 分解的主要用途也是解线性系统，它把一个系统拆成两个三角系统. 由结合律，

$$
\mathbf{b}=\mathbf{A}\mathbf{x}=(\mathbf{L}\mathbf{U})\mathbf{x}=\mathbf{L}(\mathbf{U}\mathbf{x}).
$$

令 $\mathbf{z}=\mathbf{U}\mathbf{x}$，就得到一个标准流程.

> **Algorithm:** **Solution of linear systems by LU factorization (unstable).**
> 1. Factor $\mathbf{L}\mathbf{U} = \mathbf{A}$.
> 2. Solve $\mathbf{L}\mathbf{z} = \mathbf{b}$ for $\mathbf{z}$ using forward substitution.
> 3. Solve $\mathbf{U}\mathbf{x} = \mathbf{z}$ for $\mathbf{x}$ using backward substitution.

这种因子分解的视角有一个关键优势：分解只依赖于矩阵 $\mathbf{A}$. 如果我们要对同一个 $\mathbf{A}$ 解很多个不同的右端项 $\mathbf{b}$，那么先分解再重复做三角求解会更高效 (这很自然，我们将在 **2-5-矩阵计算效率** 中详细讨论).

> **Demo:** Solving $\mathbf{A}\mathbf{x}=\mathbf{b}$ via a precomputed LU factorization.
> ```Python
> import numpy as np
>
> def lufact(A):
>     """Compute an LU factorization A = L U without pivoting (not stable)."""
>     A = np.array(A, dtype=float, copy=True)
>     n = A.shape[0]
>     L = np.eye(n)
>     U = np.zeros((n, n), dtype=float)
>     Ak = A.copy()
>
>     for k in range(n - 1):
>         U[k, :] = Ak[k, :]
>         L[:, k] = Ak[:, k] / U[k, k]
>         Ak = Ak - np.outer(L[:, k], U[k, :])
>
>     U[n - 1, n - 1] = Ak[n - 1, n - 1]
>     return L, U
>
> def forwardsub(L, b):
>     n = L.shape[0]
>     x = np.zeros(n, dtype=float)
>     x[0] = b[0] / L[0, 0]
>     for i in range(1, n):
>         s = np.dot(L[i, :i], x[:i])
>         x[i] = (b[i] - s) / L[i, i]
>     return x
>
> def backsub(U, b):
>     n = U.shape[0]
>     x = np.zeros(n, dtype=float)
>     x[-1] = b[-1] / U[-1, -1]
>     for i in range(n - 2, -1, -1):
>         s = np.dot(U[i, i + 1 :], x[i + 1 :])
>         x[i] = (b[i] - s) / U[i, i]
>     return x
>
> A = np.array(
>     [
>         [2, 0, 4, 3],
>         [-4, 5, -7, -10],
>         [1, 15, 2, -4.5],
>         [-2, 0, 2, -13],
>     ],
>     dtype=float,
> )
> b = np.array([4, 9, 9, 4], dtype=float)
>
> L, U = lufact(A)
> z = forwardsub(L, b)
> x = backsub(U, z)
> print("x =", x)
> print("residual =", b - A @ x)
> ```
> The residual should be near machine precision for a well-behaved problem.

值得注意的是，我们目前看到的 LU 分解版本并不对所有矩阵都稳定，且事实上分解也不总是存在的. 解决问题的关键是行交换，我们会在 **2-6-行主元** 中处理这些问题.
