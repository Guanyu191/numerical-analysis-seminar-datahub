# 10-2-打靶法 (Shooting)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 把边值问题改写成一系列初值问题**

处理两点边值问题的一种思路是：把第 6 章的初值问题求解技术拿来用. 这些技术的前提是我们知道完整的初始状态，但在边值问题里，我们可以允许这个初始状态变化，从而让解满足给定的边界条件.

这就是打靶法 (**shooting method**) 的想法：可以把它类比成罚球. 我们调整瞄准点与出手力度；每一次偏离的方式 (太远、轨迹太平等) 都会告诉我们下一次该怎么调.

**#2 一个试错式的打靶**

先用 **10-1-两点边值问题** 的 MEMS 例子来观察打靶法的基本行为，取 $\lambda=0.6$.

为了用初值问题求解器，我们把二阶方程改写成一阶系统. 同时由于方程里出现 $\frac{1}{r}$，我们需要把区间在 $r=0$ 附近截断一点来避免除以零. 这个边值问题给出了 $w'(0)=0$，而 $w(0)$ 需要我们猜测.

> **Demo:** Trial initial values for the MEMS problem
> We solve the IVP repeatedly with different guesses of $w(0)$ and compare how close $w(1)$ gets to 1.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> from scipy.integrate import solve_ivp
>
> lam = 0.6
> r0 = np.finfo(float).eps
>
> def rhs(r, y):
>     w, wp = y
>     return np.array([wp, lam / (w**2) - wp / r], dtype=float)
>
> r = np.linspace(r0, 1.0, 400)
> plt.figure()
> for w0 in np.arange(0.4, 1.0, 0.1):
>     sol = solve_ivp(rhs, (r0, 1.0), [w0, 0.0], t_eval=r, rtol=1e-8, atol=1e-10)
>     plt.plot(sol.t, sol.y[0], label=f"w(0)={w0:.1f}")
>
> plt.axhline(1.0, color="black", ls="--", lw=1, label="target w(1)=1")
> plt.xlabel("r")
> plt.ylabel("w(r)")
> plt.title("Different initial values")
> plt.grid(True, alpha=0.3)
> plt.legend(loc="lower right", fontsize=8)
> plt.show()
> ```
>
> The curve starting at $w(0)=0.8$ comes closest to the condition $w(1)=1$, but it is a bit too large.

**#3 从边界条件得到一个求根问题**

对初始状态的未知部分，我们可以做得比试错更系统一些. 按惯例，把

$$
u''(x)=\phi(x,u,u')
$$

改写成一阶系统

$$
y_1'=y_2,\qquad y_2'=\phi(x,y_1,y_2).
$$

把它当成初值问题时，我们在 $x=a$ 处用一个向量 $\mathbf{s}=(s_1,s_2)$ 来指定状态：

$$
y_1(a)=s_1,\qquad y_2(a)=s_2.
$$

然后用边界条件把 $\mathbf{s}$ "反过来" 决定出来. 定义残差函数 $\mathbf{v}(\mathbf{s})$ 为

$$
v_1(s_1,s_2)=g_1(s_1,s_2),\qquad
v_2(s_1,s_2)=g_2\bigl(y_1(b),y_2(b)\bigr).
$$

这里 $v_2$ 对 $\mathbf{s}$ 的依赖是间接的：它需要先解一遍初值问题得到 $y(b)$. 因此我们把边值问题变成了一个标准的求根问题：求 $\mathbf{v}(\mathbf{s})=\mathbf{0}$，可以调用 **4-1-求根问题** 到 **4-7-非线性最小二乘** 的方法链路来做.

**#4 实现结构**

打靶法的实现结构很直接：外层用一个求根器；每次评估 $\mathbf{v}(\mathbf{s})$ 时，内层都要解一次初值问题. 这也是为什么在求根阶段我们会关心 "目标函数调用次数"：每次调用都很贵.

> **Demo:** A minimal shooting solver in Python
> We implement a generic `shoot` routine with `solve_ivp` (for the IVP) and `root` (for the rootfinding), and apply it to the MEMS problem.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> from scipy.integrate import solve_ivp
> from scipy.optimize import root
>
> def shoot(phi, xspan, g1, g2, init, tol=1e-5, n=400):
>     a, b = xspan
>
>     def rhs(x, y):
>         return np.array([y[1], phi(x, y[0], y[1])], dtype=float)
>
>     def objective(s):
>         sol = solve_ivp(rhs, (a, b), np.array(s, dtype=float), rtol=tol / 10, atol=tol / 10)
>         ub, upb = sol.y[0, -1], sol.y[1, -1]
>         return np.array([g1(s[0], s[1]), g2(ub, upb)], dtype=float)
>
>     sol_root = root(objective, np.array(init, dtype=float), tol=tol)
>     s_star = sol_root.x
>
>     x = np.linspace(a, b, n)
>     sol_ivp = solve_ivp(rhs, (a, b), s_star, t_eval=x, rtol=tol / 10, atol=tol / 10)
>     u, du_dx = sol_ivp.y
>     return sol_ivp.t, u, du_dx, s_star, sol_root
>
> # MEMS problem from the previous section
> lam = 0.6
> r0 = np.finfo(float).eps
>
> phi = lambda r, w, dwdr: lam / (w**2) - dwdr / r
> g1 = lambda w, dw: dw        # w'(0) = 0
> g2 = lambda w, dw: w - 1.0   # w(1) = 1
>
> r, w, dwdr, s_star, info = shoot(phi, (r0, 1.0), g1, g2, init=[0.8, 0.0], tol=1e-5)
> print("root success:", info.success, "|", info.message)
> print("w(1) approx:", w[-1])
> print("w(r0) approx:", w[0])
>
> plt.plot(r, w, label="w")
> plt.xlabel("r")
> plt.ylabel("w(r)")
> plt.title("Shooting solution")
> plt.grid(True, alpha=0.3)
> plt.legend()
> plt.show()
> ```
>
> The accuracy of $w(1)$ is consistent with the error tolerance used for the IVP solver, and the computed $w(0)$ is close to $0.7877576$.

**#5 打靶法的不稳定性**

打靶法的精度应当与它的组成部分 (求根器与初值问题求解器) 相当. 但对某些问题，打靶法会表现出明显的不稳定性.

> **Example:**
> We solve the problem
> $$
> u'' = \lambda^2 u + \lambda^2,\qquad 0\le x\le 1,\qquad u(0)=-1,\ u(1)=0.
> $$
> The exact solution is easily confirmed to be
> $$
> u(x)=\frac{\sinh(\lambda x)}{\sinh(\lambda)}-1.
> $$
> This solution satisfies $-1\le u(x)\le 0$ for all $x\in[0,1]$.

> **Demo:** Shooting instability as $\lambda$ increases
> We compute shooting solutions for several values of $\lambda$ and check whether the right boundary condition is satisfied.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> lam_list = [6, 10, 14, 18]
> x = np.linspace(0.0, 1.0, 400)
>
> plt.figure()
> for lam in lam_list:
>     phi = lambda x, u, up, lam=lam: (lam**2) * u + (lam**2)
>     g1 = lambda u, up: u + 1.0   # u(0) = -1
>     g2 = lambda u, up: u         # u(1) = 0
>
>     xx, u, up, s_star, info = shoot(phi, (0.0, 1.0), g1, g2, init=[-1.0, 0.0], tol=1e-5, n=x.size)
>     plt.plot(xx, u, label=f"lambda={lam}, u(1)~{u[-1]:.2e}")
>
> plt.xlabel("x")
> plt.ylabel("u(x)")
> plt.title("Shooting instability")
> plt.grid(True, alpha=0.3)
> plt.legend(fontsize=8)
> plt.show()
> ```
>
> For larger $\lambda$, the computed solution may fail to satisfy $u(1)=0$ to meaningful accuracy, even though the solver reports convergence.

这种现象可以被解释得很直接：对上面的方程，如果我们固定 $u(0)=-1$ 并把 $u'(0)$ 记作 $s_2$，那么初值问题的解是

$$
u(x)=\frac{s_2}{\lambda}\sinh(\lambda x)-1.
$$

当 $x\in[0,1]$ 固定时，$u(x)$ 对 $s_2$ 的绝对条件数就是偏导数的大小

$$
\left|\frac{\partial u}{\partial s_2}(x)\right|
=
\left|\frac{\sinh(\lambda x)}{\lambda}\right|.
$$

它在 $x$ 接近 1 时会随 $\lambda$ 很快增长. 这意味着：初值问题对 $s_2$ 极其敏感时，想通过数值方法把 $s_2$ 近似出来往往注定会失败.

打靶法不稳定性的本质是：误差会从 $x=a$ (我们人为指定状态的位置) 往外指数增长. 在 **6-1-IVP-基础** 里，我们讨论过初值问题中误差沿积分方向增长的机制；打靶法正是把这种增长直接暴露在 "从左端推进到右端" 的过程中. 因此，为了在 $x=b$ 附近得到可接受的精度，我们可能需要在 $x=a$ 附近达到异常苛刻的精度.

打靶法的不稳定性可以通过把区间拆成更小的段来缓解，从而限制误差增长的空间. 但这里不展开细节. 后面几节的方法会把区间两端对称地处理，并在整个区间上一并求解.
