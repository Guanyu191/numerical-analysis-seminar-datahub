# 10-4-线性问题的配点法 (Collocation for linear problems)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 线性两点边值问题与离散未知量**

这一节为线性两点边值问题设计一个基于有限差分的数值方法：

$$
u'' + p(x)u' + q(x)u = r(x),\qquad u(a)=\alpha,\qquad u(b)=\beta.
$$

第一步是选择节点 $x_0=a<x_1<\cdots<x_n=b$. 在有限差分里，这些节点通常是等距的；在谱微分里，这些节点通常会选成 Chebyshev 点 (见 **10-3-微分矩阵**：用全局插值导出稠密的微分矩阵).

我们不直接解一个连续函数 $u(x)$，而是把未知量设置成节点处的近似值向量

$$
\mathbf{u}=
\begin{bmatrix}
u_0\\
u_1\\
\vdots\\
u_{n-1}\\
u_n
\end{bmatrix}
\approx
\begin{bmatrix}
\hat{u}(x_0)\\
\hat{u}(x_1)\\
\vdots\\
\hat{u}(x_{n-1})\\
\hat{u}(x_n)
\end{bmatrix},
$$

其中 $\hat{u}$ 表示原问题的精确解. 如果我们需要，也可以在求出 $\{(x_i,u_i)\}$ 后，用插值把这些离散值再转回函数形式.

**#2 配点离散化**

既然未知量是节点处的值，我们就把微分方程也在同一组节点上强制满足 (以离散近似的形式). 这种思路称为配点法 (**collocation**).

导数用微分矩阵给出. 例如，对某个合适的一阶导数微分矩阵 $\mathbf{D}_x$，

$$
\begin{bmatrix}
\hat{u}'(x_0)\\
\hat{u}'(x_1)\\
\vdots\\
\hat{u}'(x_n)
\end{bmatrix}
\approx
\mathbf{u}'=\mathbf{D}_x\mathbf{u}.
$$

类似地，用二阶导数微分矩阵 $\mathbf{D}_{xx}$，

$$
\begin{bmatrix}
\hat{u}''(x_0)\\
\hat{u}''(x_1)\\
\vdots\\
\hat{u}''(x_n)
\end{bmatrix}
\approx
\mathbf{u}''=\mathbf{D}_{xx}\mathbf{u}.
$$

把微分方程在 $n+1$ 个节点上离散化，可以写成

$$
\mathbf{u}'' + \mathbf{P}\mathbf{u}' + \mathbf{Q}\mathbf{u} = \mathbf{r},
$$

其中

$$
\mathbf{P}=\operatorname{diag}(p(x_0),\dots,p(x_n)),\qquad
\mathbf{Q}=\operatorname{diag}(q(x_0),\dots,q(x_n)),\qquad
\mathbf{r}=
\begin{bmatrix}
r(x_0)\\
\vdots\\
r(x_n)
\end{bmatrix}.
$$

代入 $\mathbf{u}'=\mathbf{D}_x\mathbf{u}$、$\mathbf{u}''=\mathbf{D}_{xx}\mathbf{u}$ 并整理，得到一个线性方程组

$$
\mathbf{L}\mathbf{u}=\mathbf{r},
\qquad
\mathbf{L}=\mathbf{D}_{xx}+\mathbf{P}\mathbf{D}_x+\mathbf{Q}.
$$

**#3 边界条件的并入**

到目前为止，我们还没有把边界条件并进来. 边界条件给出两个额外的线性约束 $u_0=\alpha$、$u_n=\beta$. 这时如果直接把它们加到配点方程里，会变成一个超定系统，可以用最小二乘求解；但在这里，我们更希望边界条件与配点条件都被精确地满足. 为了保持系统仍是方阵，我们需要丢弃两条配点方程. 最自然的选择就是丢弃两端点处的配点方程.

我们用一个 "删除矩阵" 来表达这一操作. 令 $\mathbf{E}$ 是一个从 $(n+1)\times(n+1)$ 单位矩阵中删去第一行与最后一行得到的矩阵，则 $\mathbf{E}\mathbf{L}$ 会删去 $\mathbf{L}$ 的第一行与最后一行，$\mathbf{E}\mathbf{r}$ 会删去 $\mathbf{r}$ 的第一项与最后一项. 另外，$\hat{u}(a)=\mathbf{e}_0^{T}\mathbf{u}$、$\hat{u}(b)=\mathbf{e}_n^{T}\mathbf{u}$，其中 $\mathbf{e}_k$ 是单位矩阵的第 $k$ 列.

因此，把两端边界条件与内部的配点方程合起来，我们得到

$$
\begin{bmatrix}
\mathbf{e}_0^{T}\\
\mathbf{E}\mathbf{L}\\
\mathbf{e}_n^{T}
\end{bmatrix}\mathbf{u}
=
\begin{bmatrix}
\alpha\\
\mathbf{E}\mathbf{r}\\
\beta
\end{bmatrix},
\qquad\text{或记为}\qquad
\mathbf{A}\mathbf{u}=\mathbf{b}.
$$

**#4 实现**

> **Demo:** A finite-difference collocation solver for linear BVPs
> We implement a solver that uses second-order finite differences (from **10-3-微分矩阵**) and enforces Dirichlet boundary conditions by replacing the first and last rows of the collocation system.
>
> ```Python
> import numpy as np
>
> def diffmat2(n, xspan):
>     a, b = xspan
>     h = (b - a) / n
>     x = a + h * np.arange(n + 1)
>
>     D1 = np.zeros((n + 1, n + 1))
>     for i in range(1, n):
>         D1[i, i - 1] = -0.5 / h
>         D1[i, i + 1] = 0.5 / h
>     D1[0, 0:3] = np.array([-1.5, 2.0, -0.5]) / h
>     D1[n, n - 2 : n + 1] = np.array([0.5, -2.0, 1.5]) / h
>
>     D2 = np.zeros((n + 1, n + 1))
>     for i in range(1, n):
>         D2[i, i - 1] = 1.0 / h**2
>         D2[i, i] = -2.0 / h**2
>         D2[i, i + 1] = 1.0 / h**2
>     D2[0, 0:4] = np.array([2.0, -5.0, 4.0, -1.0]) / h**2
>     D2[n, n - 3 : n + 1] = np.array([-1.0, 4.0, -5.0, 2.0]) / h**2
>
>     return x, D1, D2
>
> def bvplin(p, q, r, xspan, lval, rval, n):
>     x, Dx, Dxx = diffmat2(n, xspan)
>     P = np.diag(p(x))
>     Q = np.diag(q(x))
>     L = Dxx + P @ Dx + Q
>
>     A = L.copy()
>     b = r(x).copy()
>     A[0, :] = 0.0
>     A[0, 0] = 1.0
>     b[0] = lval
>     A[-1, :] = 0.0
>     A[-1, -1] = 1.0
>     b[-1] = rval
>
>     u = np.linalg.solve(A, b)
>     return x, u
> ```
>
> This implementation does not try to exploit sparsity. Switching to spectral differentiation is straightforward: replace `diffmat2` by the Chebyshev differentiation matrices from **10-3-微分矩阵**.

**#5 一个有精确解的线性边值问题**

> **Demo:** Solving a linear BVP with a known exact solution
> We solve
> $$
> u'' - (\\cos x)u' + (\\sin x)u = 0,\\qquad u(0)=1,\\qquad u\\left(\\frac{3\\pi}{2}\\right)=e^{-1}.
> $$
> The exact solution is $u(x)=\\exp(\\sin x)$.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> exact = lambda x: np.exp(np.sin(x))
> p = lambda x: -np.cos(x)
> q = lambda x: np.sin(x)
> r = lambda x: np.zeros_like(x)
>
> x, u = bvplin(p, q, r, (0.0, 1.5 * np.pi), lval=1.0, rval=np.exp(-1.0), n=30)
> ue = exact(x)
>
> fig, ax = plt.subplots(2, 1, sharex=True, figsize=(6, 6))
> ax[0].plot(x, ue, label="exact")
> ax[0].plot(x, u, "o", ms=3, label="numerical")
> ax[0].set_ylabel("solution")
> ax[0].legend()
> ax[0].grid(True, alpha=0.3)
>
> ax[1].plot(x, u - ue)
> ax[1].set_xlabel("x")
> ax[1].set_ylabel("error")
> ax[1].grid(True, alpha=0.3)
>
> fig.suptitle("Solution of a linear BVP")
> plt.show()
> ```

**#6 精度与稳定性**

我们回到 **10-2-打靶法** 里用来展示不稳定性的那个线性 BVP，来验证这里的配点法能给出二阶收敛.

> **Demo:** Second-order convergence for a linear BVP
> Consider
> $$
> u'' - \\lambda^2 u = \\lambda^2,\\qquad 0\\le x\\le 1,\\qquad u(0)=-1,\\ u(1)=0.
> $$
> The exact solution is $u(x)=\\frac{\\sinh(\\lambda x)}{\\sinh(\\lambda)}-1$.
>
> ```Python
> import numpy as np
>
> lam = 10.0
> exact = lambda x: np.sinh(lam * x) / np.sinh(lam) - 1.0
>
> p = lambda x: np.zeros_like(x)
> q = lambda x: -(lam**2) * np.ones_like(x)
> r = lambda x: (lam**2) * np.ones_like(x)
>
> for n in [20, 40, 80, 160, 320]:
>     x, u = bvplin(p, q, r, (0.0, 1.0), lval=-1.0, rval=0.0, n=n)
>     err = np.max(np.abs(exact(x) - u))
>     print("n", n, "inf-norm error", err)
> ```
>
> Doubling $n$ should reduce the error by about a factor of 4, consistent with second-order convergence.

为了理解 "稳定性" 这一说法，把离散线性系统的解 $\mathbf{u}$ 写成 "精确解减去误差"：

$$
\mathbf{u}=\hat{\mathbf{u}}-\mathbf{e}.
$$

代入离散系统 $\mathbf{A}\mathbf{u}=\mathbf{b}$ 得到

$$
\mathbf{A}\hat{\mathbf{u}}-\mathbf{A}\mathbf{e}=\mathbf{b},
\qquad
\mathbf{e}=\mathbf{A}^{-1}(\mathbf{A}\hat{\mathbf{u}}-\mathbf{b})
=\mathbf{A}^{-1}\boldsymbol{\tau}(h),
$$

其中 $\boldsymbol{\tau}(h)$ 是有限差分的截断误差 (边界行被替换成边界条件，因此对应项为 0). 如果当 $h\to 0$ 时 $\|\mathbf{A}^{-1}\|$ 有一致的上界，那么 $\|\mathbf{e}\|$ 会以与截断误差相同的速率趋于 0. 在这里，这种性质被称为稳定性 (**stability**).

稳定性的严格证明比较技术性，但在一些合理的边值问题条件下，配点法的稳定性是可以保证的.

