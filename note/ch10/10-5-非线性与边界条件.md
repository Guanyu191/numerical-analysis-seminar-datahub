# 10-5-非线性与边界条件 (Nonlinearity and boundary conditions)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 非线性问题的配点离散**

非线性微分方程的配点法与线性情形 (见 **10-4-线性问题的配点法**) 遵循相同的原则：用向量替代函数，用微分矩阵替代导数.

但由于微分方程是非线性的，离散后得到的代数方程组也会是非线性的. 因此，在求解过程中我们需要用到 **quasi-Newton** 或类似的方法.

我们考虑 **10-1-两点边值问题** 中的 TPBVP 形式：

> **Definition:** Two-point boundary-value problem (TPBVP)
> $$
> \begin{aligned}
> u''(x) &= \phi(x,u,u'), && a\le x \le b,\\
> g_1\bigl(u(a),u'(a)\bigr) &= 0,\\
> g_2\bigl(u(b),u'(b)\bigr) &= 0.
> \end{aligned}
> $$

和 **10-4-线性问题的配点法** 一样，我们用节点 $x_0,\dots,x_n$ 上的近似值向量 $\mathbf{u}$ 来表示未知函数，并用微分矩阵 $\mathbf{D}_x$ 与 $\mathbf{D}_{xx}$ 近似一阶与二阶导数.

如果暂时先忽略边界条件，那么配点方程可以写成

$$
\mathbf{D}_{xx}\mathbf{u}-\mathbf{r}(\mathbf{u})=\mathbf{0},
$$

其中 $\mathbf{r}(\mathbf{u})$ 是由 $\phi$ 逐点构造出来的向量. 具体来说，对 $i=0,\dots,n$，

$$
r_i(\mathbf{u})=\phi(x_i,u_i,u'_i),
\qquad
\mathbf{u}'=\mathbf{D}_x\mathbf{u}.
$$

**#2 以同样的方式并入边界条件**

边界条件的处理方式与 **10-4-线性问题的配点法** 类似：用一个矩形矩阵 $\mathbf{E}$ 删去两端点处的配点方程，再用边界条件替代被删掉的两行.

于是我们得到一个关于 $\mathbf{u}$ 的非线性方程组

$$
\mathbf{f}(\mathbf{u})
=
\begin{bmatrix}
\mathbf{E}\bigl(\mathbf{D}_{xx}\mathbf{u}-\mathbf{r}(\mathbf{u})\bigr)\\
g_1(u_0,u_0')\\
g_2(u_n,u_n')
\end{bmatrix}
=\mathbf{0}.
$$

这里 $\mathbf{f}(\mathbf{u})$ 的每个分量都可能是非线性的，因此这是一个规模为 $n+1$ 的非线性方程组，可以用第 4 章的技术来求解.

**#3 一个手算规模的例子**

> **Example:**
> Given the BVP
> $$
> u'' - \\sin(xu) + \\exp(xu') = 0,\\qquad u(0)=-2,\\qquad u'(3/2)=1,
> $$
> we compare to the TPBVP form and recognize
> $$
> \\phi(x,u,u') = \\sin(xu) - \\exp(xu').
> $$
>
> Suppose $n=3$ for an equispaced grid, so that $h=\\frac{1}{2}$ and $x_0=0$, $x_1=\\frac{1}{2}$, $x_2=1$, $x_3=\\frac{3}{2}$. There are four unknowns. We compute
> $$
> \\mathbf{D}_{xx}
> =
> \\frac{1}{1/4}
> \\begin{bmatrix}
> 2 & -5 & 4 & -1\\
> 1 & -2 & 1 & 0\\
> 0 & 1 & -2 & 1\\
> -1 & 4 & -5 & 2
> \\end{bmatrix},
> \\qquad
> \\mathbf{D}_x
> =
> \\begin{bmatrix}
> -3 & 4 & -1 & 0\\
> -1 & 0 & 1 & 0\\
> 0 & -1 & 0 & 1\\
> 0 & 1 & -4 & 3
> \\end{bmatrix}.
> $$
>
> The interior collocation residual is
> $$
> \\mathbf{E}\\mathbf{r}(\\mathbf{u})
> =
> \\begin{bmatrix}
> \\sin\\left(\\frac{u_1}{2}\\right) - \\exp\\left(\\frac{u_2-u_0}{2}\\right)\\vspace{2mm}\\\\
> \\sin(u_2) - \\exp(u_3-u_1)
> \\end{bmatrix},
> $$
> and the full nonlinear system is
> $$
> \\mathbf{f}(\\mathbf{u})
> =
> \\begin{bmatrix}
> (4u_0-8u_1+4u_2) - \\sin\\left(\\frac{u_1}{2}\\right) + \\exp\\left(\\frac{u_2-u_0}{2}\\right)\\vspace{2mm}\\\\
> (4u_1-8u_2+4u_3) - \\sin(u_2) + \\exp(u_3-u_1)\\vspace{2mm}\\\\
> u_0+2\\vspace{2mm}\\\\
> (u_1-4u_2+3u_3)-1
> \\end{bmatrix}
> = \\mathbf{0}.
> $$

**#4 实现**

下面用二阶有限差分微分矩阵 (见 **10-3-微分矩阵**) 来实现一个非线性 BVP 求解器. 核心就是把 $\mathbf{f}(\mathbf{u})$ 写成一个残差函数，并交给一个非线性最小二乘/求根算法.

> **Demo:** Finite-difference collocation for a nonlinear TPBVP
> We implement second-order differentiation matrices and a nonlinear BVP solver based on least squares.
>
> ```Python
> import numpy as np
> from scipy.optimize import least_squares
>
> def diffmat2(n, xspan):
>     a, b = xspan
>     h = (b - a) / n
>     x = a + h * np.arange(n + 1)
>
>     D1 = np.zeros((n + 1, n + 1))
>     for i in range(1, n):
>         D1[i, i - 1] = -0.5 / h
>         D1[i, i + 1] = 0.5 / h
>     D1[0, 0:3] = np.array([-1.5, 2.0, -0.5]) / h
>     D1[n, n - 2 : n + 1] = np.array([0.5, -2.0, 1.5]) / h
>
>     D2 = np.zeros((n + 1, n + 1))
>     for i in range(1, n):
>         D2[i, i - 1] = 1.0 / h**2
>         D2[i, i] = -2.0 / h**2
>         D2[i, i + 1] = 1.0 / h**2
>     D2[0, 0:4] = np.array([2.0, -5.0, 4.0, -1.0]) / h**2
>     D2[n, n - 3 : n + 1] = np.array([-1.0, 4.0, -5.0, 2.0]) / h**2
>
>     return x, D1, D2
>
> def bvp(phi, xspan, g1, g2, init, tol=1e-12, max_nfev=20000):
>     init = np.asarray(init, dtype=float)
>     n = init.size - 1
>     x, Dx, Dxx = diffmat2(n, xspan)
>     h = x[1] - x[0]
>
>     def residual(u):
>         du_dx = Dx @ u
>         d2u_dx2 = Dxx @ u
>         f = d2u_dx2 - phi(x, u, du_dx)
>         # Replace first and last rows by boundary conditions.
>         f[0] = g1(u[0], du_dx[0]) / h
>         f[-1] = g2(u[-1], du_dx[-1]) / h
>         return f
>
>     res = least_squares(
>         residual,
>         init,
>         method="trf",
>         xtol=tol,
>         ftol=tol,
>         gtol=tol,
>         max_nfev=max_nfev,
>     )
>     return x, res.x, res
> ```
>
> The length of `init` is $n+1$, which sets the discretization size.

**#5 初值估计、多个解与边界条件**

为了求解某个具体问题，我们需要提供三个要素：$\phi$、边界条件函数 $g_1,g_2$、以及初值估计 `init`. 初值估计会显著影响求解速度，甚至影响迭代是否收敛；当问题存在多个解时，初值估计还可能决定最终找到哪一个解.

> **Demo:** A damped pendulum BVP
> We solve the nonlinear equation $\\theta'' + 0.05\\,\\theta' + \\sin\\theta = 0$ with Dirichlet conditions $\\theta(0)=2.5$ and $\\theta(T)=-2$.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> phi = lambda t, th, om: -0.05 * om - np.sin(th)
> g1 = lambda u, du: u - 2.5
> g2 = lambda u, du: u + 2.0
>
> init = np.linspace(2.5, -2.0, 101)  # n=100
>
> for T in [5.0, 8.0]:
>     t, theta, info = bvp(phi, (0.0, T), g1, g2, init)
>     _, Dt, _ = diffmat2(theta.size - 1, (0.0, T))
>     dtheta_dt = Dt @ theta
>
>     plt.figure()
>     plt.plot(t, theta)
>     plt.xlabel("t")
>     plt.ylabel("theta(t)")
>     plt.title(f"Pendulum over [0, {T}] (theta'(0) ~ {dtheta_dt[0]:.4f})")
>     plt.grid(True, alpha=0.3)
>     plt.show()
> ```
>
> If we extend the time interval while keeping the same endpoint values, the initial slope must adjust, and the qualitative behavior of the solution can change.

> **Demo:** Two solutions of the membrane problem
> For the membrane deflection problem in **10-1-两点边值问题**, different constant initializations can lead to different valid solutions.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> lam = 0.5
> r0 = np.finfo(float).eps
> domain = (r0, 1.0)
>
> phi = lambda r, w, dwdr: lam / (w**2) - dwdr / r
> g1 = lambda w, dwdr: dwdr      # w'(0) = 0
> g2 = lambda w, dwdr: w - 1.0   # w(1) = 1
>
> init1 = np.ones(301)
> r, w1, _ = bvp(phi, domain, g1, g2, init1)
>
> init2 = 0.5 * np.ones(301)
> r, w2, _ = bvp(phi, domain, g1, g2, init2)
>
> plt.plot(r, w1, label="init = 1")
> plt.plot(r, w2, label="init = 0.5")
> plt.xlabel("r")
> plt.ylabel("w(r)")
> plt.title("Two solutions of the membrane problem")
> plt.grid(True, alpha=0.3)
> plt.legend()
> plt.show()
> ```
>
> It is not necessary that an initialization satisfy the boundary conditions. Changing the initialization can determine which solution is found.

**#6 参数延续 (Parameter continuation)**

有时最好的初始化方式，是先解一个 "更容易" 的相关问题，再把它的解当作初始化，逐步把参数推到我们真正关心的取值. 这种做法称为参数延续 (**parameter continuation**). 在这个过程中，我们会在一串参数值上反复求解，每一步都用最近一次的数值解来初始化下一步的迭代.

> **Demo:** Parameter continuation for the Allen-Cahn equation
> We solve $\\varepsilon u'' = u^3-u$ on $[0,1]$ with $u'(0)=0$ and $u(1)=1$. The same naive initialization may fail for smaller $\\varepsilon$, but continuation can succeed.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> def solve_allen_cahn(eps, init):
>     phi = lambda x, u, du: (u**3 - u) / eps
>     g1 = lambda u, du: du
>     g2 = lambda u, du: u - 1.0
>     x, u, info = bvp(phi, (0.0, 1.0), g1, g2, init)
>     # Use the returned solver object to judge whether the residual is small.
>     _, Dx, Dxx = diffmat2(u.size - 1, (0.0, 1.0))
>     h = x[1] - x[0]
>     du = Dx @ u
>     res = (Dxx @ u) - phi(x, u, du)
>     res[0] = g1(u[0], du[0]) / h
>     res[-1] = g2(u[-1], du[-1]) / h
>     return x, u, np.max(np.abs(res)), info
>
> init0 = np.linspace(-1.0, 1.0, 141)
>
> x, u1, rmax1, _ = solve_allen_cahn(0.02, init0)
> x, u_bad, rmax_bad, _ = solve_allen_cahn(0.002, init0)
>
> x, u2, rmax2, _ = solve_allen_cahn(0.002, u1)
> x, u3, rmax3, _ = solve_allen_cahn(0.0005, u2)
>
> print("eps=0.02  max|res|", rmax1)
> print("eps=0.002 max|res| (naive init)", rmax_bad)
> print("eps=0.002 max|res| (continuation)", rmax2)
> print("eps=0.0005 max|res| (continuation)", rmax3)
>
> plt.plot(x, u1, label=r"eps=0.02")
> plt.plot(x, u2, label=r"eps=0.002")
> plt.plot(x, u3, label=r"eps=0.0005")
> plt.xlabel("x")
> plt.ylabel("u(x)")
> plt.title("Allen-Cahn solutions by continuation")
> plt.grid(True, alpha=0.3)
> plt.legend()
> plt.show()
> ```
>
> When the residual stays large, the iteration has not converged to a valid discrete solution, even if the solver reports termination.
