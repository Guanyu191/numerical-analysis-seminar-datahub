# 8-7-无矩阵迭代 (Matrix-free iterations)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 矩阵与线性变换**

矩阵之所以重要，一个主要原因是它与线性变换 (linear transformation) 的关系. 如果我们定义

$$
f(\mathbf{x})=\mathbf{A}\mathbf{x},
$$

那么对任意向量 $\mathbf{x},\mathbf{y}$ 与任意标量 $\alpha$，都有

$$
f(\mathbf{x}+\mathbf{y})=f(\mathbf{x})+f(\mathbf{y}),
\qquad
f(\alpha\mathbf{x})=\alpha f(\mathbf{x}).
$$

这两条性质刻画了线性变换. 反过来，任意有限维向量空间之间的线性变换，都可以用一次矩阵-向量乘法来表示.

**#2 无矩阵迭代**

在 **4-1-求根问题** 中，我们解过非线性求根问题 $f(\mathbf{x})=\mathbf{0}$：很多方法只需要我们能在给定 $\mathbf{x}$ 时计算 $f(\mathbf{x})$. 通过在一系列 "选得很巧" 的点上反复评估 $f$，算法最终返回 $f^{-1}(\mathbf{0})$ 的一个近似.

类似地，幂迭代与 Krylov 子空间方法也有同样的结构：矩阵 $\mathbf{A}$ 在算法里出现的唯一方式，是用它去乘一个已知向量，也就是计算 $f(\mathbf{x})=\mathbf{A}\mathbf{x}$. 而这一能力又被用来近似计算 $\mathbf{A}^{-1}\mathbf{b}$.

把这两种视角合在一起，会得到现代科学计算中的一个基石：**无矩阵迭代 (matrix-free iterations)**. 我们只要提供 "线性变换如何作用在向量上" 的代码，即使完全不知道它对应的矩阵元素，也可以用 Krylov 子空间方法来近似求解该线性变换的逆.

**#3 图像模糊**

在 **7-1-从矩阵到洞见** 里，我们把灰度图像表示为一个 $m\times n$ 的矩阵 $\mathbf{X}$，矩阵元素是像素强度. 现在考虑一个简单的模糊模型. 定义 $\mathbf{B}$ 为 $m\times m$ 的三对角矩阵，使得

$$
B_{ij}
=
\begin{cases}
\frac{1}{2}, & i=j,\\
\frac{1}{4}, & |i-j|=1,\\
0, & \text{otherwise}.
\end{cases}
$$

矩阵乘积 $\mathbf{B}\mathbf{X}$ 会把 $\mathbf{B}$ 作用到 $\mathbf{X}$ 的每一列上：在每一列内部，它把某个像素与其上下相邻像素做加权平均，从而产生竖直方向的模糊. 如果我们反复应用 $\mathbf{B}$，模糊程度会增强.

要在水平方向上模糊，我们可以先把图像转置，再用同样的方式模糊，然后再转置回去. 这要求一个 $n\times n$ 的矩阵 $\mathbf{C}$，它的定义与 $\mathbf{B}$ 相同 (只把维度从 $m$ 换成 $n$). 水平模糊对应的操作是

$$
(\mathbf{C}\mathbf{X}^{T})^{T}=\mathbf{X}\mathbf{C}^{T}=\mathbf{X}\mathbf{C},
$$

其中用到了 $\mathbf{C}$ 的对称性. 因此，我们可以把二维模糊写成

$$
\operatorname{blur}(\mathbf{X})=\mathbf{B}^{k}\mathbf{X}\mathbf{C}^{k},
$$

其中 $k$ 是正整数.

> **Demo:** Blurring an image
> We build the tridiagonal blurring matrices and apply them repeatedly to a grayscale test image.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> import scipy.sparse as sp
> from skimage import data, transform
>
> # A readily available test image (grayscale). Downsample for speed.
> img = data.camera()
> X = transform.resize(img, (192, 192), anti_aliasing=True).astype(float)
> X = X / X.max()
> m, n = X.shape
>
> def blurmatrix(d):
>     e = np.ones(d - 1)
>     return sp.diags([0.25 * e, 0.5 * np.ones(d), 0.25 * e], offsets=[-1, 0, 1], format="csr")
>
> B = blurmatrix(m)
> C = blurmatrix(n)
>
> def blur(X, k):
>     Y = X.copy()
>     for _ in range(k):
>         Y = B @ Y                 # vertical blur
>     for _ in range(k):
>         Y = (C @ Y.T).T           # horizontal blur, via transpose
>     return Y
>
> k = 12
> Z = blur(X, k)
>
> fig, ax = plt.subplots(1, 2, figsize=(8, 4))
> ax[0].imshow(X, cmap="gray", vmin=0, vmax=1)
> ax[0].set_title("Original image")
> ax[0].axis("off")
> ax[1].imshow(Z, cmap="gray", vmin=0, vmax=1)
> ax[1].set_title("Blurred image")
> ax[1].axis("off")
> plt.tight_layout()
> plt.show()
> ```
>
> The repeated local averaging makes edges less sharp, which is perceived as blur.

**#4 去模糊**

更有意思的操作是去模糊：如果我们拿到一张因为失焦而被模糊的图像，能否恢复出真实图像？从概念上说，我们想要 "反过来求" $\operatorname{blur}(\mathbf{X})$.

从 $\operatorname{blur}(\mathbf{X})=\mathbf{B}^{k}\mathbf{X}\mathbf{C}^{k}$ 可以直接看出，模糊操作对图像矩阵是一个线性变换. 同时，一个 $m\times n$ 的图像矩阵也等价于一个长度为 $mn$ 的向量：本质上只是同一份数据的形状解释不同而已. 我们用

$$
\operatorname{vec}(\mathbf{X})=\mathbf{x},
\qquad
\operatorname{unvec}(\mathbf{x})=\mathbf{X}
$$

来表示这种 "拉直" 与 "还原形状" 的操作.

设 $\mathbf{X}$ 是原图，$\mathbf{Z}=\operatorname{blur}(\mathbf{X})$ 是模糊后的图像. 由于线性性，存在某个矩阵 $\mathbf{A}$ 使得

$$
\mathbf{A}\operatorname{vec}(\mathbf{X})=\operatorname{vec}(\mathbf{Z}),
\qquad \text{也就是} \qquad
\mathbf{A}\mathbf{x}=\mathbf{z}.
$$

这里的 $\mathbf{A}$ 是一个 $mn\times mn$ 的矩阵. 如果是 1200 万像素的图片，那么 $mn\approx 1.2\times 10^{7}$，矩阵元素个数约为 $(mn)^2\approx 1.4\times 10^{14}$. 它确实极其稀疏，但关键是：我们完全不需要显式构造它.

相反，给定任意向量 $\mathbf{u}$，我们可以通过

$$
\mathbf{U}=\operatorname{unvec}(\mathbf{u}),
\qquad
\mathbf{V}=\operatorname{blur}(\mathbf{U}),
\qquad
\mathbf{v}=\operatorname{vec}(\mathbf{V})
$$

来计算 $\mathbf{v}=\mathbf{A}\mathbf{u}$. 下面展示如何用 MINRES 把这一思路真正用起来.

> **Demo:** Deblurring via a matrix-free MINRES solve (SciPy)
> We define the blur operator as a `scipy.sparse.linalg.LinearOperator` (no explicit matrix), then solve for the original image by MINRES.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> import scipy.sparse as sp
> import scipy.sparse.linalg as spla
> from skimage import data, transform
>
> img = data.camera()
> X = transform.resize(img, (160, 160), anti_aliasing=True).astype(float)
> X = X / X.max()
> m, n = X.shape
>
> def blurmatrix(d):
>     e = np.ones(d - 1)
>     return sp.diags([0.25 * e, 0.5 * np.ones(d), 0.25 * e], offsets=[-1, 0, 1], format="csr")
>
> B = blurmatrix(m)
> C = blurmatrix(n)
>
> def blur(X, k):
>     Y = X.copy()
>     for _ in range(k):
>         Y = B @ Y
>     for _ in range(k):
>         Y = (C @ Y.T).T
>     return Y
>
> k = 12
> Z = blur(X, k)
>
> def unvec(x):
>     return x.reshape(m, n)
>
> def vec(X):
>     return X.reshape(-1)
>
> def matvec(x):
>     return vec(blur(unvec(x), k))
>
> T = spla.LinearOperator((m * n, m * n), matvec=matvec, rmatvec=matvec, dtype=float)
>
> y, info = spla.minres(T, vec(Z), maxiter=50, rtol=1e-5)
> Y = np.clip(y, 0.0, 1.0).reshape(m, n)
>
> fig, ax = plt.subplots(1, 2, figsize=(8, 4))
> ax[0].imshow(X, cmap="gray", vmin=0, vmax=1)
> ax[0].set_title("Original")
> ax[0].axis("off")
> ax[1].imshow(Y, cmap="gray", vmin=0, vmax=1)
> ax[1].set_title("Deblurred (MINRES, 50 iters)")
> ax[1].axis("off")
> plt.tight_layout()
> plt.show()
> ```
>
> The system can be ill-conditioned for large `k`, so the deblurred image may still lose fine detail unless we use better conditioning (see the next section on preconditioning).
