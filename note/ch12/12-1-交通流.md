# 12-1-交通流 (Traffic flow)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 交通堵塞的一个 PDE 模型**

我们可能都有过这种经历：在高速路上开着开着突然遇到堵车. 我们可能不得不急刹车，进入一段走走停停的密集车流，然后又以更缓慢的方式从拥堵中脱离出来 (进入堵车的过程很突然，离开堵车却更渐进). 这类现象背后的数学机制已经被很好地理解.

考虑一条沿 $x$ 方向延伸的一维道路. 我们用连续的密度函数 $\rho(x)$ 来表示车辆. 车辆的流率或通量 (**flux**) $q$ 表示单位时间内通过道路某个固定点的车辆数. 我们假设通量只依赖于局部车密度.

一个合理的设想是：当 $\rho=0$ (无车) 时通量为 0；通量在某个 $\rho=\rho_m$ 处达到最大值 $q_m$；当密度趋近某个临界密度 $\rho_c$ 时 (非常拥挤)，通量再次趋近 0. 这些条件可以由下列模型满足：

$$
Q_0(\rho)=\frac{4q_m\rho_m\rho(\rho-\rho_c)(\rho_m-\rho_c)}{\bigl[\rho(\rho_c-2\rho_m)+\rho_c\rho_m\bigr]^2}.
$$

观测数据表明 (以三车道高速为例)，可以取

$$
\rho_c=1080\ \text{vehicles/km},\qquad
\rho_m=380\ \text{vehicles/km},\qquad
q_m=4500\ \text{vehicles/hour}.
$$

> **Note:** 后面的 Demo 会使用 $q_m=10000$ 来做数值实验，这与上面给出的观测值不同.

此外，我们还希望纳入一个事实：司机会根据对密度变化的感知提前减速或加速. 因此我们令

$$
q=Q_0(\rho)-\epsilon\rho_x,
$$

其中 $\epsilon>0$ 很小.

**#2 守恒律与对流-扩散**

守恒律 (**conservation law**) 在科学与工程中非常常见. 它们通常表达某个物理量 (例如物质、能量、动量等) 不能被凭空产生或消失. 在一维情形，它们具有形式

$$
u_t+q_x=0,
$$

其中 $u$ 是被守恒的量，$q$ 是 $u$ 的通量.

把它用于交通流，并代入 $q=Q_0(\rho)-\epsilon\rho_x$，得到随时间演化的 PDE：

$$
\rho_t+Q_0'(\rho)\rho_x=\epsilon\rho_{xx}.
$$

注意 $Q_0'(\rho)$ 的量纲是 (cars/time)/(cars/length)，也就是 length/time. 其中第一项与最后一项带有扩散 (**diffusion**) 的典型结构，而中间的项则带来一种不同的效应. 类似的项也出现在 **11-1-Black-Scholes 方程** 中.

**#3 对流方程 (Advection equation)**

先暂时考虑一个更基础的 PDE.

> **Definition:** Advection equation
> The advection equation in one dimension is
> $$
> u_t + c u_x = 0,
> $$
> where $c$ is constant.

对流方程是双曲型 PDE (**hyperbolic PDE**) 的代表模型，它与抛物型 PDE 是不同的类别. 对比守恒律形式 $u_t+q_x=0$，我们可以把 $u_t+cu_x=0$ 理解为一种 "通量与梯度成比例" 的情形.

构造它的解很容易. 设 $u(t,x)=\psi(x-ct)$，其中 $\psi$ 是任意一元可微函数. 链式法则给出

$$
u_t+cu_x=\psi'(x-ct)\cdot(-c)+c\bigl[\psi'(x-ct)\bigr]=0,
$$

因此 PDE 成立. 这个形式告诉我们：沿着满足 $x-ct=a$ 的路径 (即 $x=a+ct$) ，$u$ 保持不变. 所以当 $c>0$ 时，$u$ 的一个固定取值会以速度 $|c|$ 向右传播；当 $c<0$ 时则向左传播.

> **Observation:**
> Solutions to the advection equation propagate with constant speed and fixed shape.

**#4 用线法解对流方程**

我们可以像 **11-2-线法** 那样用线法来解对流方程. 对周期端条件，需要二阶的一阶导数矩阵 $\mathbf{D}_x$：

$$
\mathbf{D}_x=\frac{1}{2h}
\begin{bmatrix}
0 & 1 & 0 & \cdots & 0 & -1\\
-1 & 0 & 1 & \cdots & 0 & 0\\
0 & -1 & 0 & \ddots & 0 & 0\\
\vdots & \ddots & \ddots & \ddots & \ddots & \vdots\\
0 & 0 & 0 & \ddots & 0 & 1\\
1 & 0 & 0 & \cdots & -1 & 0
\end{bmatrix}.
$$

这个矩阵可以由 **11-2-线法** 中的 `diffper` 产生.

> **Demo:** Advection by the method of lines (periodic)
> We solve $u_t + c u_x = 0$ on $[-4,4]$ with periodic end conditions by the method of lines.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> import scipy.sparse as sp
>
> def diffper(n, xspan):
>     a, b = float(xspan[0]), float(xspan[1])
>     h = (b - a) / n
>     x = a + h * np.arange(n)
>
>     dp = np.full(n - 1, 0.5 / h)
>     dm = np.full(n - 1, -0.5 / h)
>     Dx = sp.diags([dm, dp], offsets=[-1, 1], shape=(n, n), format="lil")
>     Dx[0, n - 1] = -1.0 / (2.0 * h)
>     Dx[n - 1, 0] = 1.0 / (2.0 * h)
>
>     d0 = np.full(n, -2.0 / h**2)
>     dp2 = np.full(n - 1, 1.0 / h**2)
>     Dxx = sp.diags([dp2, d0, dp2], offsets=[-1, 0, 1], shape=(n, n), format="lil")
>     Dxx[0, n - 1] = 1.0 / h**2
>     Dxx[n - 1, 0] = 1.0 / h**2
>
>     return x, Dx.tocsr(), Dxx.tocsr()
>
> def rk4(f, tspan, u0, n, c):
>     a, b = float(tspan[0]), float(tspan[1])
>     h = (b - a) / n
>     t = a + h * np.arange(n + 1)
>     u = np.empty((n + 1, u0.size))
>     u[0] = u0
>     for k in range(n):
>         tk = t[k]
>         uk = u[k]
>         k1 = f(tk, uk, c)
>         k2 = f(tk + h / 2.0, uk + h * k1 / 2.0, c)
>         k3 = f(tk + h / 2.0, uk + h * k2 / 2.0, c)
>         k4 = f(tk + h, uk + h * k3, c)
>         u[k + 1] = uk + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)
>     return t, u
>
> x, Dx, _ = diffper(300, (-4.0, 4.0))
> Dx_dense = Dx.toarray()
>
> def f(t, u, c):
>     return -c * (Dx_dense @ u)
>
> # The initial condition is not exactly periodic, but the mismatch is tiny.
> u_init = 1.0 + np.exp(-3.0 * x**2)
>
> c = 2.0
> t, U = rk4(f, (0.0, 4.0), u_init, n=800, c=c)
>
> for tj in [0.0, 1.0, 2.0, 3.0, 4.0]:
>     j = int(round(tj / (t[1] - t[0])))
>     plt.plot(x, U[j], label=f"t = {tj:.1f}")
> plt.title("Advection")
> plt.xlabel("x")
> plt.ylabel("u(x,t)")
> plt.grid(True, alpha=0.3)
> plt.legend(loc="upper left")
> plt.show()
> ```
>
> The bump moves to the right with speed $c$ and reenters on the left due to periodicity.

如果仔细看前面的 Demo，会发现我们用的时间积分器是 RK4，这是一种非刚性 (nonstiff) 方法. 纯对流方程本身并不天然刚性；我们会在本章后续看到原因.

**#5 交通流方程的解与激波**

回到交通流 PDE $\rho_t+Q_0'(\rho)\rho_x=\epsilon\rho_{xx}$. 我们可以把它理解为：以速度 $Q_0'(\rho)$ 做对流. 与线性对流方程不同的是，这里的速度依赖于解本身，这正是交通堵塞反常行为的关键.

尤其是：高密度对应低速度，低密度对应高速度. 右端的 $\epsilon\rho_{xx}$ 提供了一点扩散，而参数 $\epsilon$ 决定了扩散与对流谁占主导. 当 $\epsilon$ 很小时，对流效应主导.

尽管这个方程的显式解比标准对流方程难得多，但线法仍然有效.

> **Demo:** Traffic flow by the method of lines (periodic)
> We use periodic boundary conditions on $[0,4]$ and solve the semidiscrete ODE with a stiff solver.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> from scipy.integrate import solve_ivp
>
> rho_c = 1080.0
> rho_m = 380.0
> q_m = 10000.0
>
> def dQ0(rho):
>     num = 4.0 * q_m * rho_c**2 * (rho_c - rho_m) * rho_m * (rho_m - rho)
>     den = (rho * (rho_c - 2.0 * rho_m) + rho_c * rho_m) ** 3
>     return num / den
>
> x, Dx, Dxx = diffper(800, (0.0, 4.0))
> Dx = Dx.toarray()
> Dxx = Dxx.toarray()
>
> def rhs(t, rho, eps):
>     return -dQ0(rho) * (Dx @ rho) + eps * (Dxx @ rho)
>
> eps = 0.02
>
> # Moderate bump.
> rho0 = 400.0 + 10.0 * np.exp(-20.0 * (x - 3.0) ** 2)
> sol = solve_ivp(lambda t, y: rhs(t, y, eps), (0.0, 1.0), rho0, method="Radau",
>                 rtol=1e-6, atol=1e-8, dense_output=True)
>
> for tj in [0.0, 0.25, 0.5, 0.75, 1.0]:
>     plt.plot(x, sol.sol(tj), label=f"t = {tj:.2f}")
> plt.title("Traffic flow (moderate bump)")
> plt.xlabel("x")
> plt.ylabel("density")
> plt.grid(True, alpha=0.3)
> plt.legend(loc="upper left")
> plt.show()
>
> # Larger bump.
> rho0 = 400.0 + 80.0 * np.exp(-16.0 * (x - 3.0) ** 2)
> sol = solve_ivp(lambda t, y: rhs(t, y, eps), (0.0, 0.5), rho0, method="Radau",
>                 rtol=1e-6, atol=1e-8, dense_output=True)
>
> for tj in [0.0, 0.1, 0.2, 0.3, 0.4, 0.5]:
>     plt.plot(x, sol.sol(tj), label=f"t = {tj:.2f}")
> plt.title("Traffic jam (larger bump)")
> plt.xlabel("x")
> plt.ylabel("density")
> plt.grid(True, alpha=0.3)
> plt.legend(loc="upper left")
> plt.show()
> ```
>
> In the larger-bump case, the density bump travels backward and steepens on the side facing incoming traffic.

> **Note:** 这个更大波峰的数值解中可能会出现短暂的高频振荡. 这来自数值不稳定性，本章后面会在更简单的情形下讨论.

第二个情形中出现的现象被称为激波 (**shock wave**). 这种数学现象与超音速飞机机翼产生的激波 (音爆) 或某些条件下海浪出现的陡峭波峰并没有本质差别.

如果没有扩散 (即 $\epsilon=0$)，激波会变成解的跃变不连续，这会同时破坏有限差分近似与原 PDE 本身的意义，需要不同的处理方式. 在很多应用里，加入少量扩散是合理且简单的建模手段. 不过在继续讨论激波之前，我们会先尝试把线性问题中的纯对流 "搞清楚".
