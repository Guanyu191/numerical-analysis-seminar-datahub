# 12-4-波动方程 (The wave equation)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 波动方程与双向传播**

与对流方程紧密相关的另一个经典模型是波动方程：

$$
u_{tt}-c^2u_{xx}=0.
$$

这是我们第一次遇到时间上含二阶导数的 PDE. 和对流方程一样，$u(x,t)=\phi(x-ct)$ 是波动方程的解；但现在对任意二次可微的 $\phi$，$u(x,t)=\phi(x+ct)$ 也是解. 因此，波动方程可以同时支持两个方向的传播.

我们取 $x\in[0,1]$、$t>0$ 作为定义域. 由于 $u$ 在 $t$ 与 $x$ 上都是二阶导数，因此需要两个边界条件. 我们使用 Dirichlet 条件

$$
u(0,t)=u(1,t)=0,\qquad t\ge 0,
$$

并给出两个初始条件

$$
u(x,0)=f(x),\qquad u_t(x,0)=g(x),\qquad 0\le x\le 1.
$$

一种做法是对 $u_{tt}$ 与 $u_{xx}$ 都用有限差分离散，例如

$$
\frac{1}{\tau^2}\bigl(U_{i,j+1}-2U_{i,j}+U_{i,j-1}\bigr)
=
\frac{c^2}{h^2}\bigl(U_{i+1,j}-2U_{i,j}+U_{i-1,j}\bigr),
$$

并把它整理成对 $U_{i,j+1}$ 的显式递推. 这里我们不沿着这条路走，而是转向线法.

**#2 写成时间上一阶系统**

为了与我们熟悉的 IVP 求解器兼容，需要把波动方程改写成时间上一阶的系统.

按最常见的做法，我们可以令 $y=u_t$，得到

$$
u_t=y,\qquad y_t=c^2u_{xx}.
$$

但还有另一种不那么直观的选择：

$$
u_t=z_x,\qquad z_t=c^2u_x.
$$

这个形式之所以吸引人，部分原因是它与电磁学中的 Maxwell 方程等价. 在这种 Maxwell 形式下，我们通常把初始条件换成

$$
u(x,0)=f(x),\qquad z(x,0)=g(x),
$$

这在一些应用里可能更贴近物理意义.

由于波沿两个方向传播，没有偏好的迎风方向，因此使用中心差分 (或其他对称的空间离散) 是合适的. 在加入边界条件之前，对 Maxwell 形式做空间半离散可写成块矩阵系统：

$$
\begin{bmatrix}
\mathbf{u}'(t)\\
\mathbf{z}'(t)
\end{bmatrix}
=
\begin{bmatrix}
\mathbf{0} & \mathbf{D}_x\\
c^2\mathbf{D}_x & \mathbf{0}
\end{bmatrix}
\begin{bmatrix}
\mathbf{u}(t)\\
\mathbf{z}(t)
\end{bmatrix}.
$$

边界条件 $u(0,t)=u(1,t)=0$ 暗示我们应该把 $\mathbf{u}$ 的两个端点值从未知量中移除，但保留所有 $\mathbf{z}$ 的分量. 我们用 $\mathbf{w}(t)$ 表示半离散系统的全部未知量；在计算 $\mathbf{w}'(t)$ 时，需要把 $\mathbf{u}$ 与 $\mathbf{z}$ 分量拆出来，并用专门的函数来 "补零" 或 "裁剪" (把边界的 0 加回来，或把它们删掉).

**#3 Demo：常速度的波动方程**

> **Demo:** Wave equation in Maxwell form (Dirichlet u at both ends)
> We solve $u_t=z_x$, $z_t=c^2u_x$ with $c=2$ and $u$ satisfying homogeneous Dirichlet boundary conditions.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> from scipy.integrate import solve_ivp
>
> def diffcheb(n, xspan):
>     k = np.arange(n + 1)
>     x = -np.cos(np.pi * k / n)
>
>     c = np.ones(n + 1)
>     c[0] = 2.0
>     c[-1] = 2.0
>     c = c * ((-1) ** k)
>
>     dX = x[:, None] - x[None, :]
>     D = (c[:, None] / c[None, :]) / (dX + np.eye(n + 1))
>     D = D - np.diag(D.sum(axis=1))
>
>     a, b = float(xspan[0]), float(xspan[1])
>     x = a + (b - a) * (x + 1.0) / 2.0
>     Dx = 2.0 * D / (b - a)
>     return x, Dx
>
> m = 200
> x, Dx = diffcheb(m, (-1.0, 1.0))
> c = 2.0
>
> def extend_u(v):
>     return np.concatenate(([0.0], v, [0.0]))
>
> def chop_u(u):
>     return u[1:-1]
>
> def rhs(t, w):
>     u_int = w[: m - 1]
>     z = w[m - 1 :]
>     u = extend_u(u_int)
>     dudt = Dx @ z
>     dzdt = (c**2) * (Dx @ u)
>     return np.concatenate((chop_u(dudt), dzdt))
>
> # Initial condition: one hump in u; choosing z=-u makes the two traveling pieces have different amplitudes.
> u0 = np.exp(-100.0 * (x + 0.5) ** 2)
> u0[0] = 0.0
> u0[-1] = 0.0
> z0 = -u0
> w0 = np.concatenate((chop_u(u0), z0))
>
> sol = solve_ivp(rhs, (0.0, 2.0), w0, method="RK45", rtol=1e-6, atol=1e-9, dense_output=True)
>
> tt = np.linspace(0.0, 2.0, 80)
> U = np.column_stack([extend_u(sol.sol(t)[: m - 1]) for t in tt])
>
> plt.contourf(x, tt, U.T, levels=24, cmap="RdBu_r", vmin=-1, vmax=1)
> plt.colorbar()
> plt.title("Wave equation (constant c)")
> plt.xlabel("x")
> plt.ylabel("t")
> plt.show()
> ```
>
> The initial hump breaks into two pieces traveling in opposite directions, reflects at the boundaries with inverted shape, and the pieces pass through each other without interference.

**#4 变速波动与界面反射/透射**

当波速 $c$ 在空间上不连续变化时 (例如光从一种介质进入另一种介质)，会出现更有趣的现象. 在半离散系统里，这意味着把常数 $c^2$ 替换为对角矩阵 $\operatorname{diag}(c^2(x_0),\dots,c^2(x_m))$，从而在实现上变成逐点的系数乘法.

> **Demo:** Wave equation with discontinuous wave speed
> We take $c(x)=1$ for $x<0$ and $c(x)=2$ for $x>0$.
>
> ```Python
> cvec = 1.0 + (np.sign(x) + 1.0) / 2.0  # 1 (left) / 2 (right)
>
> def rhs_varc(t, w):
>     u_int = w[: m - 1]
>     z = w[m - 1 :]
>     u = extend_u(u_int)
>     dudt = Dx @ z
>     dzdt = (cvec**2) * (Dx @ u)
>     return np.concatenate((chop_u(dudt), dzdt))
>
> sol = solve_ivp(rhs_varc, (0.0, 5.0), w0, method="RK45", rtol=1e-6, atol=1e-9, dense_output=True)
>
> tt = np.linspace(0.0, 5.0, 80)
> U = np.column_stack([extend_u(sol.sol(t)[: m - 1]) for t in tt])
> plt.contourf(x, tt, U.T, levels=24, cmap="RdBu_r", vmin=-1, vmax=1)
> plt.colorbar()
> plt.title("Wave equation (variable c)")
> plt.xlabel("x")
> plt.ylabel("t")
> plt.show()
> ```
>
> Each pass through the interface at $x=0$ generates a reflected and transmitted wave. By conservation of energy, both are smaller in amplitude than the incoming wave.
