# 12-2-迎风格式与稳定性 (Upwinding and stability)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 依赖域与迎风方向**

这一节聚焦常速度的线性对流方程：

$$
u_t+cu_x=0,\qquad u(0,x)=u_0(x).
$$

暂时先不考虑边界. 这里 $c$ 是速度 (velocity) 而不是速率 (speed)：当 $c>0$ 时解向右传播，当 $c<0$ 时解向左传播.

在 **12-1-交通流** 里我们已经看到 $u(t,x)=\psi(x-ct)$ 是解，因此

$$
u(t,x)=u_0(x-ct).
$$

> **Definition:** Domain of dependence
> Let $u(x,t)$ be the solution of an evolutionary PDE with initial condition $u_0(x)$.
>
> The domain of dependence of the solution at $(x,t)$ is the set of all $x$ such that $u_0(x)$ can possibly affect $u(x,t)$.
>
> If this domain of dependence lies entirely in one direction relative to $x$, then that direction is called the upwind direction of the PDE, and its opposite is the downwind direction.

对流方程在 $(x,t)$ 的依赖域就是单点集合 $\{x-ct\}$. 因此，若 $c>0$，迎风方向在 $x$ 的左侧；若 $c<0$，迎风方向在 $x$ 的右侧.

任何数值方法也有与之对应的概念.

> **Definition:** Numerical domain of dependence
> Let $U_{i,j}$ be the approximate solution of an evolutionary PDE at $x=x_i$, $t=t_j$ from a numerical method, when the initial condition is given by $U_{i,0}$ for all $i$.
>
> The numerical domain of dependence of the method at $(x_i,t_j)$ is the set of all $x_i$ such that $U_{i,0}$ can possibly affect $U_{i,j}$.

> **Example:**
> Discretize $u_x$ by a centered difference,
> $$
> u_x(x_i,t_j)\approx \frac{U_{i+1,j}-U_{i-1,j}}{2h}.
> $$
> If we use forward Euler in time, then
> $$
> \mathbf{u}_{j+1}=(\mathbf{I}-c\tau\mathbf{D}_x)\mathbf{u}_j,
> $$
> where $\tau$ is the time step. Because the update matrix is tridiagonal, $U_{i,j}$ can depend directly only on $U_{i-1,j}$, $U_{i,j}$, and $U_{i+1,j}$. Tracing this dependence back to $t=0$, $U_{i,j}$ can depend on initial data from $x_{i-j}$ to $x_{i+j}$, i.e., between $x_i-jh$ and $x_i+jh$ (ignoring boundaries).

**#2 CFL 条件**

现在给出一个关于依赖域的基本原则.

> **Theorem:** Courant-Friedrichs-Lewy (CFL) condition
> In order for a numerical method for an advection equation to converge to the correct solution, the limiting numerical domain of dependence must contain the exact domain of dependence.

> **Note:** CFL 条件是收敛的必要条件，但不是充分条件. 例如，我们可以构造一个方法，让 $U_{i,j}$ 是所有初始值 $U_{k,0}$ 的某种加权和，这会让数值依赖域变成整条实线，但它并不意味着我们在正确求解某个 PDE.

这个结论的直觉并不难：如果 CFL 不成立，那么精确解在 $(x,t)$ 处可能受某处初始数据影响，但数值解却不受影响. 于是无论我们怎么选初始数据，总会出现 "精确解变了、数值解不变" 的情况，因此不可能对所有问题都收敛到正确解.

> **Example:**
> In the centered-difference + forward-Euler scheme, $U_{i,j}$ depends on initial data within $[x_i-jh,\ x_i+jh]$.
>
> The exact domain of dependence at $(x_i,t_j)$ is $\{x_i-ct_j\}$. Requiring $\{x_i-ct_j\}$ to lie inside $[x_i-jh,\ x_i+jh]$ gives
> $$
> |c j\tau|\le jh,
> $$
> and hence, as $\tau,h\\to 0$,
> $$
> \\frac{h}{\\tau}\\ge |c|.
> $$

上述不等式可以改写为时间步长约束

$$
\tau\le \frac{h}{|c|}.
$$

这里 $h/\tau$ 可以理解为数值方法中 "信息传播速度" 的上限，因此 CFL 也常被表述为下面的速度比较.

> **Observation:**
> The CFL condition requires that the maximum propagation speed in the numerical method be at least as large as the maximum speed in the original PDE problem.

相比 **11-4-刚性** 里扩散方程对显式方法的 $\tau=O(h^2)$ 约束，这里的 $\tau\le h/|c|$ 明显温和得多，这也是对流比扩散更不刚性的一个早期信号.

> **Demo:** CFL scaling in step counts (periodic advection)
> We solve advection with velocity $c=2$ on $[0,1]$ with periodic end conditions and compare the required number of time steps as we double $m$.
>
> ```Python
> import numpy as np
> import scipy.sparse as sp
>
> def diffper(n, xspan):
>     a, b = float(xspan[0]), float(xspan[1])
>     h = (b - a) / n
>     x = a + h * np.arange(n)
>
>     dp = np.full(n - 1, 0.5 / h)
>     dm = np.full(n - 1, -0.5 / h)
>     Dx = sp.diags([dm, dp], offsets=[-1, 1], shape=(n, n), format="lil")
>     Dx[0, n - 1] = -1.0 / (2.0 * h)
>     Dx[n - 1, 0] = 1.0 / (2.0 * h)
>     return x, Dx.tocsr(), h
>
> def rk4_step(f, t, u, dt, c):
>     k1 = f(t, u, c)
>     k2 = f(t + dt / 2.0, u + dt * k1 / 2.0, c)
>     k3 = f(t + dt / 2.0, u + dt * k2 / 2.0, c)
>     k4 = f(t + dt, u + dt * k3, c)
>     return u + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)
>
> def demo(m, c=2.0, tfinal=2.0, cfl=0.8):
>     x, Dx, h = diffper(m, (0.0, 1.0))
>     Dx = Dx.toarray()
>     u0 = np.exp(-80.0 * (x - 0.5) ** 2)  # nearly periodic
>
>     def f(t, u, c):
>         return -c * (Dx @ u)
>
>     dt = cfl * h / abs(c)  # CFL-motivated scaling
>     n = int(np.ceil(tfinal / dt))
>     t = 0.0
>     u = u0.copy()
>     for _ in range(n):
>         u = rk4_step(f, t, u, tfinal / n, c)
>         t += tfinal / n
>     return n
>
> n400 = demo(400)
> n800 = demo(800)
> print("Number of time steps for m = 400:", n400)
> print("Number of time steps for m = 800:", n800)
> ```
>
> When $h$ is halved (doubling $m$), the CFL scaling suggests the time step should be halved as well, so the number of steps roughly doubles.

如果我们改用隐式时间离散，会发生什么.

> **Example:**
> If we use backward Euler in time, then
> $$
> (\mathbf{I}+c\tau\mathbf{D}_x)\mathbf{u}_{j+1}=\mathbf{u}_j,\qquad
> \mathbf{u}_{j+1}=(\mathbf{I}+c\tau\mathbf{D}_x)^{-1}\mathbf{u}_j.
> $$
> The inverse of a tridiagonal matrix is not necessarily tridiagonal, so $U_{i,j+1}$ can depend on all data at time level $j$. Hence the numerical domain of dependence includes the entire real line, and the CFL condition is always satisfied.

> **Observation:**
> An explicit time discretization must obey $\tau=O(h)$ as $h\\to 0$ in order to solve linear advection, while an implicit method is typically unrestricted by the CFL condition.

**#3 迎风格式 (Upwinding)**

对流方程中的 $u_x$ 还有其他离散方式，CFL 的含义也会随之变化.

> **Example:**
> Using the backward difference
> $$
> u_x(x_i,t_j)\approx \\frac{U_{i,j}-U_{i-1,j}}{h}
> $$
> with an explicit time step makes $U_{i,j}$ depend only on points to the left of $x_i$ (upwind direction is to the left).
>
> If $c<0$, the PDE upwind direction is to the right, so the CFL condition cannot be satisfied.
>
> Similarly, pairing the forward difference
> $$
> u_x(x_i,t_j)\approx \\frac{U_{i+1,j}-U_{i,j}}{h}
> $$
> with an explicit method makes the numerical upwind direction to the right and fails when $c>0$.

当 PDE 的依赖域与数值方法都表现出方向偏好时，这两者必须一致.

> **Observation:** Upwinding
> If a numerical method has an upwinding direction, it must be the same as the upwind direction of the PDE.

这看起来让人觉得 "那我永远用中心差分就好了". 但在激波前沿，中心差分会跨越跃变不连续来做差分，这会带来另一类困难.

**#4 入流边界条件 (Inflow boundary condition)**

现在假设对流方程定义在有限区间 $x\\in[a,b]$. 由于 PDE 在 $x$ 上只有一阶导数，我们只应当给出一个边界条件. 那么这个边界条件应当写在左端还是右端.

如果我们在下风端 (downwind) 施加边界条件，随着时间推进，这个边界信息无法传播进区间内部. 另一方面，对于靠近迎风端的点，它的依赖域会试图越过迎风边界，但这是不可能的；因此依赖域会被 "卡" 在迎风边界上.

总结来说，我们必须给 PDE 指定一个入流条件 (**inflow condition**)：当 $c>0$ 时写在左端，当 $c<0$ 时写在右端. 这不仅对精确 PDE 成立，对其任何合理的离散也成立.

> **Demo:** Advection on [0,1] with an inflow boundary condition
> We take $c=-1$, so the right boundary is upwind/inflow. A well-posed boundary condition is $u(1,t)=0$.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> from scipy.integrate import solve_ivp
>
> def diffcheb(n, xspan):
>     k = np.arange(n + 1)
>     x = -np.cos(np.pi * k / n)
>
>     c = np.ones(n + 1)
>     c[0] = 2.0
>     c[-1] = 2.0
>     c = c * ((-1) ** k)
>
>     dX = x[:, None] - x[None, :]
>     D = (c[:, None] / c[None, :]) / (dX + np.eye(n + 1))
>     D = D - np.diag(D.sum(axis=1))
>
>     a, b = float(xspan[0]), float(xspan[1])
>     x = a + (b - a) * (x + 1.0) / 2.0
>     Dx = 2.0 * D / (b - a)
>     return x, Dx
>
> m = 80
> x, Dx = diffcheb(m, (0.0, 1.0))
>
> # Inflow BC: u(1,t)=0 means the last node is fixed and not part of v.
> interior = np.arange(0, m)   # exclude the last node (index m)
> def extend(v):
>     return np.concatenate((v, [0.0]))
>
> c = -1.0
> def rhs(t, v):
>     u = extend(v)
>     ux = Dx @ u
>     return (-c) * ux[interior]
>
> v0 = np.exp(-80.0 * (x[interior] - 0.5) ** 2)
> sol = solve_ivp(rhs, (0.0, 1.0), v0, method="RK45", dense_output=True)
>
> # Sample a space-time contour.
> tt = np.linspace(0.0, 0.75, 80)
> U = np.column_stack([extend(sol.sol(t)) for t in tt])
> plt.contourf(x, tt, U.T, levels=30)
> plt.title("Advection with inflow BC")
> plt.xlabel("x")
> plt.ylabel("t")
> plt.colorbar()
> plt.show()
> ```
>
> The hump exits gracefully out the downwind end.

如果我们反过来试图施加下风端的出流条件 (**outflow BC**) $u(0,t)=0$，就会出现冲突并导致爆炸.

> **Demo:** Advection on [0,1] with an outflow boundary condition (ill-posed)
> We impose $u(0,t)=0$ while still taking $c=-1$ (inflow is on the right). The solution blows up when the hump reaches the boundary.
>
> ```Python
> # Outflow BC at x=0 forces the first node to be 0 and removes it from the unknowns.
> interior = np.arange(1, m + 1)  # include the right endpoint, exclude the left
> def extend(v):
>     return np.concatenate(([0.0], v))
>
> def rhs(t, v):
>     u = extend(v)
>     ux = Dx @ u
>     return (-c) * ux[interior]
>
> v0 = np.exp(-80.0 * (x[interior] - 0.5) ** 2)
> sol = solve_ivp(rhs, (0.0, 0.25), v0, method="RK45", dense_output=True)
> ```

这一次，当波包到达边界时数值解会立刻爆炸. 直觉上，PDE 的迎风信息来自右端，但我们在左端施加了边界条件，于是在边界附近产生了相互冲突的约束.
