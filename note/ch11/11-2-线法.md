# 11-2-线法 (The method of lines)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 从全离散到半离散**

在 **11-1-Black-Scholes 方程** 里，我们的策略是：同时对时间与空间导数做有限差分离散，然后把格式整理成可以随时间逐步推进的形式. 这种做法部分有效，但并不稳妥；我们在上一节的后半部分已经见到，当时间区间变长时，数值解会出现爆炸式增长.

这一节我们换一个更一般的离散化视角. 为了引出关键想法，我们先用更简单的热方程 $u_t=u_{xx}$ 作为模型.

边界条件往往会显著增加复杂度，因此我们先考虑一种几乎没有边界麻烦的情形：周期端条件 (**periodic end conditions**). 具体地说，我们在 $0\le x<1$ 上求解，并要求对任意时刻都满足

$$
u(x+1,t)=u(x,t)\quad \text{for all }x.
$$

这与仅仅要求 $u(1,t)=u(0,t)$ 不同：真正的周期条件意味着函数值以及各阶导数在一个周期的端点处都要匹配；否则，把区间端点 "首尾相接" 后会产生不可忽略的不光滑.

**#2 半离散化 (Semidiscretization)**

和之前一样，我们用 $\hat u$ 表示 PDE 的精确解. 为了避免在周期条件下携带冗余信息，我们只使用节点

$$
x_i=ih,\quad i=0,\dots,m-1,\qquad h=\frac{1}{m},
$$

并约定：当表达式里出现 $x_m$ 时，我们把它理解为 $x_0$. 更一般地，对精确解在任意整数 $i$ 上都有

$$
\hat u(x_i,t)=\hat u\bigl(x_{i\bmod m},t\bigr).
$$

接着把空间离散后的未知量写成一个向量：

$$
\mathbf{u}(t)=
\begin{bmatrix}
u_0(t)\\
u_1(t)\\
\vdots\\
u_{m-1}(t)
\end{bmatrix}.
$$

这一步叫半离散化 (**semidiscretization**)：空间变量离散了，但时间变量还没有离散.

像 **10-3-微分矩阵** 那样，我们用一个二阶微分矩阵 $\mathbf{D}_{xx}$ 来近似 $u_{xx}$. 对二阶中心差分，在周期条件下得到的矩阵具有 "回绕" 结构：

$$
\mathbf{D}_{xx}=\frac{1}{h^2}
\begin{bmatrix}
-2 & 1 & 0 & \cdots & 0 & 1\\
1 & -2 & 1 & \cdots & 0 & 0\\
0 & 1 & -2 & \ddots & 0 & 0\\
\vdots & \ddots & \ddots & \ddots & \ddots & \vdots\\
0 & 0 & 0 & \ddots & -2 & 1\\
1 & 0 & 0 & \cdots & 1 & -2
\end{bmatrix}.
$$

注意第一行与最后一行的角元素：它们正是周期条件导致的 "从一端回到另一端".

> **Function:** diffper
> **Differentiation matrices for periodic end conditions**
> ```Python
> import numpy as np
> import scipy.sparse as sp
>
> def diffper(n, xspan=(0.0, 1.0)):
>     """
>     Construct 2nd-order differentiation matrices for periodic end conditions,
>     using n unique nodes in the interval xspan=(a,b).
>
>     Returns:
>       x:   (n,) nodes on [a,b), omitting the repeated endpoint
>       Dx:  (n,n) first-derivative matrix (2nd-order)
>       Dxx: (n,n) second-derivative matrix (2nd-order)
>     """
>     a, b = float(xspan[0]), float(xspan[1])
>     h = (b - a) / n
>     x = a + h * np.arange(n)
>
>     # First derivative: central difference with wrap-around.
>     dp = np.full(n - 1, 0.5 / h)
>     dm = np.full(n - 1, -0.5 / h)
>     Dx = sp.diags([dm, dp], offsets=[-1, 1], shape=(n, n), format="lil")
>     Dx[0, n - 1] = -1.0 / (2.0 * h)
>     Dx[n - 1, 0] = 1.0 / (2.0 * h)
>
>     # Second derivative: 3-point stencil with wrap-around.
>     d0 = np.full(n, -2.0 / h**2)
>     dp = np.full(n - 1, 1.0 / h**2)
>     Dxx = sp.diags([dp, d0, dp], offsets=[-1, 0, 1], shape=(n, n), format="lil")
>     Dxx[0, n - 1] = 1.0 / h**2
>     Dxx[n - 1, 0] = 1.0 / h**2
>
>     return x, Dx.tocsr(), Dxx.tocsr()
> ```

把 $u_t=u_{xx}$ 的空间二阶导数用 $\mathbf{D}_{xx}\mathbf{u}$ 代替后，PDE 被近似为半离散问题

$$
\frac{d\mathbf{u}(t)}{dt}=\mathbf{D}_{xx}\mathbf{u}(t).
$$

这已经是一个线性、常系数的常微分方程组. 只要我们用初始函数 $u(x,0)$ 给出 $\mathbf{u}(0)$，就得到了一个我们熟悉的初值问题.

半离散化经常被称为线法 (**the method of lines**). 需要注意的是，它并不是一个单一算法：要得到具体可运行的方法，我们还必须指定 "时间怎么离散". 线法的关键思想在于把空间离散与时间离散分开处理，这一点也与解析方法里对热方程的分离变量思路有些相似.

**#3 显式时间离散与失败现象**

> **Example:**
> Suppose we solve $\mathbf{u}'=\mathbf{D}_{xx}\mathbf{u}$ using the forward Euler IVP integrator. Choose a time step $\tau$ and times $t_j=j\tau$. Then a fully discrete method for the heat equation is
> $$
> \mathbf{u}_{j+1}=\mathbf{u}_j+\tau(\mathbf{D}_{xx}\mathbf{u}_j)=(\mathbf{I}+\tau\mathbf{D}_{xx})\mathbf{u}_j.
> $$

> **Demo:** Forward Euler time stepping for the heat equation (periodic)
> We implement the scheme in the previous Example using 2nd-order semidiscretization in space.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> import scipy.sparse as sp
>
> m = 100
> x, Dx, Dxx = diffper(m, (0.0, 1.0))
>
> tfinal = 0.16
> n = 2400
> tau = tfinal / n
> t = tau * np.arange(n + 1)
>
> U = np.zeros((m, n + 1))
> U[:, 0] = np.exp(-60.0 * (x - 0.5) ** 2)  # nearly periodic
>
> A = (sp.identity(m, format="csr") + tau * Dxx).tocsr()
> for j in range(n):
>     U[:, j + 1] = A @ U[:, j]
>
> idx = [0, 20, 40, 60]
> for j in idx:
>     plt.plot(x, U[:, j], label=f"t = {t[j]:.4f}")
> plt.title("Heat equation by forward Euler (periodic)")
> plt.xlabel("x")
> plt.ylabel("u(x,t)")
> plt.ylim(0, 1)
> plt.grid(True, alpha=0.3)
> plt.legend(loc="upper left")
> plt.show()
>
> M = np.max(np.abs(U), axis=0)
> plt.plot(t[:1000], np.log10(M[:1000]))
> plt.title("Nonphysical growth")  # exponential in time
> plt.xlabel("t")
> plt.ylabel(r"log10 max_x |u(x,t)|")
> plt.grid(True, alpha=0.3)
> plt.show()
> ```
>
> The initial peak starts to spread and flatten, but soon the solution grows in a nonphysical way.

这个现象与 **11-1-Black-Scholes 方程** 里的爆炸非常相似：我们用的是同一类 "显式时间推进 + 空间二阶差分" 的全离散思路. 改变时间离散方式可以显著改善结果.

**#4 隐式时间离散与线性系统**

> **Example:**
> Using backward Euler for $\mathbf{u}'=\mathbf{D}_{xx}\mathbf{u}$ gives
> $$
> \mathbf{u}_{j+1}=\mathbf{u}_j+\tau(\mathbf{D}_{xx}\mathbf{u}_{j+1}),
> $$
> i.e.,
> $$
> (\mathbf{I}-\tau\mathbf{D}_{xx})\mathbf{u}_{j+1}=\mathbf{u}_j.
> $$
> Because backward Euler is implicit, a linear system must be solved for $\mathbf{u}_{j+1}$ at each time step.

> **Demo:** Backward Euler time stepping for the heat equation (periodic)
> The matrix $\mathbf{I}-\tau\mathbf{D}_{xx}$ does not change over time, so we factor it once and reuse the factorization.
>
> ```Python
> import scipy.sparse.linalg as spla
>
> U = np.zeros((m, n + 1))
> U[:, 0] = np.exp(-60.0 * (x - 0.5) ** 2)
>
> B = (sp.identity(m, format="csc") - tau * Dxx.tocsc())
> lu = spla.splu(B)  # one factorization
> for j in range(n):
>     U[:, j + 1] = lu.solve(U[:, j])
>
> idx = [0, 20, 40, 60]
> for j in idx:
>     plt.plot(x, U[:, j], label=f"t = {t[j]:.4f}")
> plt.title("Heat equation by backward Euler (periodic)")
> plt.xlabel("x")
> plt.ylabel("u(x,t)")
> plt.ylim(0, 1)
> plt.grid(True, alpha=0.3)
> plt.legend(loc="upper left")
> plt.show()
> ```
>
> The solution looks physically plausible: diffusion smooths the initial concentration while preserving periodicity.

这暗示：在扩散类问题中，隐式时间推进方法具有重要作用. 其中原因会在后续几节通过稳定性分析解释清楚.

**#5 把初值问题求解器当黑盒**

线法把 PDE 变成了常微分方程组的初值问题，因此我们不一定要手写 Runge-Kutta 或多步法. 我们也可以直接调用任意 IVP 求解器来解

$$
\mathbf{u}'=\mathbf{D}_{xx}\mathbf{u},\qquad \mathbf{u}(0)=\mathbf{u}_0.
$$

> **Demo:** Solving the semidiscrete heat equation with `solve_ivp`
> We compare an explicit adaptive method (RK23) against a stiff solver (Radau).
>
> ```Python
> from scipy.integrate import solve_ivp
>
> u0 = np.exp(-60.0 * (x - 0.5) ** 2)
> Dxx_dense = Dxx.toarray()
>
> def rhs(t, u):
>     return Dxx_dense @ u
>
> tfinal = 0.25
> sol_rk23 = solve_ivp(rhs, (0.0, tfinal), u0, method="RK23", rtol=1e-5, atol=1e-8)
> print("Number of time steps for RK23:", len(sol_rk23.t) - 1)
>
> sol_radau = solve_ivp(rhs, (0.0, tfinal), u0, method="Radau", rtol=1e-5, atol=1e-8)
> print("Number of time steps for Radau:", len(sol_radau.t) - 1)
>
> u_final = sol_radau.y[:, -1]
> plt.plot(x, u0, label="t = 0")
> plt.plot(x, u_final, label=f"t = {tfinal}")
> plt.title("Semidiscrete heat equation (adaptive IVP solver)")
> plt.xlabel("x")
> plt.ylabel("u")
> plt.grid(True, alpha=0.3)
> plt.legend()
> plt.show()
> ```
>
> Both solvers can produce reasonable solutions, but the explicit method may take far more steps than a stiff solver.
>
> > **Note:** 为了让示例尽量短，这里把稀疏矩阵 `Dxx` 转成了稠密矩阵. 当 $m$ 很大时，这么做会占用大量内存；更稳妥的方式是把 `Dxx` 包装成 `scipy.sparse.linalg.LinearOperator`，并把矩阵-向量乘法写进 `rhs`.

自适应时间积分器都可以产出数值解，但它们并不在所有重要方面都等价. 不管我们选择固定步长的直接实现，还是带自适应的黑盒求解器，都需要理解半离散问题本身的一个关键性质；接下来的两节会围绕这个性质展开.
