# 11-5-边界 (Boundaries)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 线法如何处理边界条件**

到目前为止，我们在 **11-2-线法** 中讨论的都是周期端条件，这几乎等价于 "没有边界". 那么当我们面对真正的边界条件时，线法要怎么做.

设我们要解如下形式的非线性 PDE：

$$
u_t=\phi(t,x,u,u_x,u_{xx}),\qquad a\le x\le b.
$$

并不是所有此类 PDE 都是抛物型 (本质上包含扩散项)，但我们这里假设它确实属于抛物型. 再设解满足边界条件

$$
g_1\bigl(u(a,t),u_x(a,t)\bigr)=0,\qquad
g_2\bigl(u(b,t),u_x(b,t)\bigr)=0.
$$

Dirichlet、Neumann、Robin 条件都是上式的线性特例.

**#2 消去边界未知量 (Boundary removal)**

像往常一样，我们把 $u(x,t)$ 变成半离散的 $\mathbf{u}(t)$，其中 $u_i(t)\approx \hat u(x_i,t)$. 与周期条件不同，这里我们必须把区间端点纳入离散节点：$x_0=a$、$x_m=b$.

于是半离散未知量可以自然分成 "端点" 与 "内部" 两部分：

$$
\mathbf{u}(t)=
\begin{bmatrix}
u_0(t)\\
\mathbf{v}(t)\\
u_m(t)
\end{bmatrix},
$$

其中 $\mathbf{v}(t)$ 收集了内部节点 $x_1,\dots,x_{m-1}$ 上的函数值.

指导原则是：
- 让内部未知量 $\mathbf{v}$ 由 PDE 的离散形式决定；
- 让端点未知量 $u_0,u_m$ 被选取为满足边界条件.

最终我们希望只为内部未知量建立初值问题：

$$
\frac{d\mathbf{v}}{dt}=\mathbf{f}(t,\mathbf{v}).
$$

边界条件只出现在 $\mathbf{f}$ 的定义中，而不会成为额外的微分方程.

像 **10-5-非线性与边界条件** 那样，我们引入一阶微分矩阵 $\mathbf{D}_x$，并把半离散的一阶导数写成

$$
\mathbf{u}_x\approx \mathbf{D}_x\mathbf{u}.
$$

这样边界条件就可以写成

$$
g_1(u_0,u_{x,0})=0,\qquad g_2(u_m,u_{x,m})=0.
$$

给定内部值 $\mathbf{v}$ 之后，上式可以被视为关于未知端点值 $u_0,u_m$ 的两个方程. 对 Dirichlet、Neumann、Robin 条件，这个方程组是线性的.

> **Example:**
> Consider the Black-Scholes PDE
> $$
> u_t=\frac{1}{2}\sigma^2x^2u_{xx}+rxu_x-ru,
> $$
> with boundary conditions $u(0,t)=0$ and $u_x(S_{\max},t)=1$. Then $u_0=0$. Using a 2nd-order one-sided difference at $x_m=S_{\max}$,
> $$
> u_x(x_m,t)\approx \frac{u_{m-2}-4u_{m-1}+3u_m}{2h}=1.
> $$
> These two conditions form a $2\\times 2$ linear system for $(u_0,u_m)$ once the interior vector $\mathbf{v}$ is given.

> **Example:**
> Using a global Chebyshev differentiation matrix $\mathbf{D}_x$ instead, the boundary conditions become
> $$
> u_0=0,\qquad D_{m0}u_0+D_{m1}u_1+\\cdots +D_{mm}u_m=1.
> $$
> Given interior values $\mathbf{v}=[u_1,\\dots,u_{m-1}]^T$, this is again a $2\\times 2$ linear system for $(u_0,u_m)$.

**#3 计算 $\mathbf{f}(t,\mathbf{v})$ 的步骤**

> **Algorithm:** Time derivative for a parabolic PDE (method of lines with boundaries)
> Given a value of $t$ and $\mathbf{v}$:
>
> 1. Use the boundary conditions to solve for $u_0$ and $u_m$.
> 2. Assemble the full vector $\mathbf{u}=[u_0;\\mathbf{v};u_m]$.
> 3. Use the spatial semidiscretization to evaluate $\phi$ at all nodes.
> 4. Ignore the boundary nodes to obtain $\mathbf{f}(t,\\mathbf{v})$ for the interior nodes.

**#4 一个通用实现: parabolic**

这一节给出一个完整实现：用 Chebyshev 配点在空间做谱离散，并把边界条件通过 "解 $u_0,u_m$" 的方式嵌入到右端函数 $\mathbf{f}(t,\mathbf{v})$ 中.

> **Function:** parabolic
> **Solution of parabolic PDEs by the method of lines**
> ```Python
> import numpy as np
> from scipy.integrate import solve_ivp
> from scipy.optimize import root
>
> def diffcheb(n, xspan):
>     k = np.arange(n + 1)
>     x = -np.cos(np.pi * k / n)  # nodes in [-1,1]
>
>     c = np.ones(n + 1)
>     c[0] = 2.0
>     c[-1] = 2.0
>     c = c * ((-1) ** k)
>
>     dX = x[:, None] - x[None, :]
>     D = (c[:, None] / c[None, :]) / (dX + np.eye(n + 1))
>     D = D - np.diag(D.sum(axis=1))  # diagonal entries
>
>     a, b = float(xspan[0]), float(xspan[1])
>     x = a + (b - a) * (x + 1.0) / 2.0
>     Dx = 2.0 * D / (b - a)
>     Dxx = Dx @ Dx
>     return x, Dx, Dxx
>
> def parabolic(phi, xspan, m, g1, g2, tspan, init, *, method="Radau", rtol=1e-6, atol=1e-10):
>     """Solve a parabolic PDE u_t = phi(t,x,u,ux,uxx) on xspan by the method of lines.
>
>     Boundary conditions are encoded as g1(u(a,t),u_x(a,t))=0 and g2(u(b,t),u_x(b,t))=0.
>
>     Returns:
>       x: (m+1,) Chebyshev nodes on [a,b]
>       u: function t -> full semidiscrete solution u(x,t)
>     """
>     x, Dx, Dxx = diffcheb(m, xspan)
>     interior = np.arange(1, m)  # 1..m-1
>     x_int = x[interior]
>
>     def extend(v, ubc_guess=None):
>         # Solve 2 equations for boundary values (u0, um).
>         def objective(ubc):
>             u0, um = ubc
>             u = np.concatenate(([u0], v, [um]))
>             ux = Dx @ u
>             return np.array([g1(u0, ux[0]), g2(um, ux[-1])], dtype=float)
>
>         x0 = np.array([0.0, 0.0]) if ubc_guess is None else np.asarray(ubc_guess, dtype=float)
>         sol = root(objective, x0=x0, method="hybr")
>         if not sol.success:
>             raise RuntimeError(f"boundary solve failed: {sol.message}")
>         u0, um = sol.x
>         return np.concatenate(([u0], v, [um])), sol.x
>
>     def rhs(t, v):
>         # Using a persistent guess helps convergence and reduces work.
>         u, ubc = extend(v, rhs.ubc)
>         rhs.ubc = ubc
>         ux = Dx @ u
>         uxx = Dxx @ u
>         return np.asarray(phi(t, x_int, u[interior], ux[interior], uxx[interior]), dtype=float)
>
>     rhs.ubc = np.array([0.0, 0.0])
>     v0 = np.asarray(init(x_int), dtype=float)
>
>     sol = solve_ivp(rhs, (float(tspan[0]), float(tspan[1])), v0, method=method,
>                     rtol=rtol, atol=atol, dense_output=True)
>     if not sol.success:
>         raise RuntimeError(sol.message)
>
>     def u_of_t(t):
>         v = sol.sol(t)
>         if v.ndim == 1:
>             u, _ = extend(v)
>             return u
>         # Vectorized: evaluate column-by-column.
>         U = np.empty((m + 1, v.shape[1]))
>         ubc = np.array([0.0, 0.0])
>         for k in range(v.shape[1]):
>             U[:, k], ubc = extend(v[:, k], ubc)
>         return U
>
>     return x, u_of_t
> ```
>
> > **Note:** 在 Dirichlet 边界条件下，$u_0,u_m$ 可以直接写出，不需要每次都调用 `root` 去解非线性方程组；为了保持函数通用性，这里没有做该特化.

**#5 Demo：热方程与 Black-Scholes 方程**

> **Demo:** Heat equation on [-1,1] with Dirichlet boundary conditions
> We solve $u_t=u_{xx}$ on $[-1,1]$ with $u(-1,t)=0$ and $u(1,t)=2$.
>
> ```Python
> import matplotlib.pyplot as plt
>
> phi = lambda t, x, u, ux, uxx: uxx
> g1 = lambda u, ux: u        # u(-1,t)=0
> g2 = lambda u, ux: u - 2.0  # u(1,t)=2
>
> init = lambda x: 1.0 + np.sin(np.pi * x / 2.0) + 3.0 * (1.0 - x**2) * np.exp(-4.0 * x**2)
>
> x, u = parabolic(phi, (-1.0, 1.0), 60, g1, g2, (0.0, 0.75), init, method="Radau")
>
> for t in np.arange(0.0, 0.41, 0.1):
>     plt.plot(x, u(t), label=f"t = {t:.2f}")
> plt.title("Solution of the heat equation")
> plt.xlabel("x")
> plt.ylabel("u(x,t)")
> plt.grid(True, alpha=0.3)
> plt.legend(loc="upper left")
> plt.show()
> ```

> **Demo:** Heat equation with a nonlinear source term
> We solve $u_t=u^2+u_{xx}$ on $[0,1]$ with homogeneous boundary conditions of different kinds.
>
> ```Python
> phi = lambda t, x, u, ux, uxx: u**2 + uxx
> g1 = lambda u, ux: u     # Dirichlet at x=0
> g2 = lambda u, ux: ux    # Neumann at x=1
> init = lambda x: 400.0 * x**4 * (1.0 - x)**2
>
> x, u = parabolic(phi, (0.0, 1.0), 60, g1, g2, (0.0, 0.1), init, method="Radau")
> ```
>
> > **Note:** 这个例子的重点是演示 "边界条件被当作求 $u_0,u_m$ 的方程嵌入到 rhs 中" 的套路；如果要复现原文的动画，可以在多个时刻采样 `u(t)` 并用 `matplotlib.animation` 绘制.

> **Demo:** Black-Scholes equation by the method of lines with boundary removal
> We solve
> $$
> u_t = \\frac{\\sigma^2}{2}x^2u_{xx} + r x u_x - r u
> $$
> on $[0,S_{\\max}]$ with $u(0,t)=0$ and $u_x(S_{\\max},t)=1$.
>
> ```Python
> K = 3.0
> sigma = 0.06
> r = 0.08
> Smax = 8.0
>
> phi = lambda t, x, u, ux, uxx: (sigma**2 / 2.0) * (x**2 * uxx) + r * x * ux - r * u
> g1 = lambda u, ux: u
> g2 = lambda u, ux: ux - 1.0
>
> payoff = lambda x: np.maximum(0.0, x - K)
> x, u = parabolic(phi, (0.0, Smax), 80, g1, g2, (0.0, 15.0), payoff, method="Radau")
> ```

回忆：在 Black-Scholes 里，$u$ 表示看涨期权的价值，而这里的时间变量代表 "距离到期还有多久". 时间跨度越长，期权通常越值钱，因为我们预期股价有更大概率在到期前上涨.
