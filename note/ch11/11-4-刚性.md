# 11-4-刚性 (Stiffness)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 稳定性约束与 "刚性" 的直觉**

在 **11-3-绝对稳定性** 里，我们用稳定区域与特征值来分析了周期热方程半离散系统

$$
\mathbf{u}'=\mathbf{D}_{xx}\mathbf{u}
$$

的时间步长约束. 由于特征值都落在负实轴上，离原点最远的那个特征值 (大约是 $-4/h^2$) 会决定显式方法的稳定性步长限制；对显式方法 (或者更一般地，对任何稳定区域在负实轴方向上是有界的方法)，结论是 $\tau=O(h^2)$.

对 Euler 与 backward Euler 来说，稳定性并不是时间步长受限的唯一原因：它们都是一阶方法，局部截断误差是 $O(\tau)$. 而我们选用的空间离散是二阶的，因此为了让时间误差不拖后腿，我们也应该选取 $\tau=O(h^2)$.

但当我们使用二阶 IVP 求解器时，情况会改变：若时间与空间都做到二阶，那么总体截断误差为 $O(h^2+\tau^2)$，这意味着仅从精度角度出发，选择 $\tau=O(h)$ 就是合理的. 于是，稳定性给出的 $\tau=O(h^2)$ 约束就显得 "过于严格".

这类 "时间步长由稳定性而非精度决定" 的问题被称为刚性 (**stiff**) 问题. 刚性不是非黑即白的性质，而是一条连续光谱. 它可以出现在非线性问题中，也可以出现在与扩散无关的问题里. 除了最温和的刚性情形之外，隐式时间推进方法通常是更好的选择.

> **Note:** 在第 6 章里我们常用 $h$ 表示时间步长，但在这一章开始我们把 $h$ 留给空间网格尺度，把时间步长写成 $\tau$.

**#2 线性化 (Linearization)**

为什么在 **11-3-绝对稳定性** 里用 $y'=\lambda y$ 这个模型方程就能讨论那么多实际问题. 通过对角化，它确实能自然推广到常系数线性系统 $\mathbf{u}'=\mathbf{A}\mathbf{u}$. 但这仍然是一类非常受限的问题.

现在考虑一般的非线性向量系统：

$$
\mathbf{u}'=\mathbf{f}(t,\mathbf{u}).
$$

要把它与绝对稳定性联系起来，一个关键思路是：我们不去直接研究精确解本身，而是研究精确解附近的扰动如何演化. 在真实的数值计算里，这类扰动总会存在 (例如舍入误差). 如果我们假设扰动足够小，就可以用线性近似描述它的增长或衰减；若线性近似暗示扰动会无界增长，那么我们就必须严肃质疑数值解的价值.

更具体地说，设 $\hat{\mathbf{u}}(t)$ 是我们希望跟踪的一条精确解轨道，而扰动把我们推到了附近的一条轨道 $\hat{\mathbf{u}}(t)+\mathbf{v}(t)$. 将其代入 ODE，并对 $\mathbf{f}$ 做多元 Taylor 展开，可得

$$
\bigl[\hat{\mathbf{u}}(t)+\mathbf{v}(t)\bigr]'=\mathbf{f}\bigl(t,\hat{\mathbf{u}}(t)+\mathbf{v}(t)\bigr),
$$

从而

$$
\hat{\mathbf{u}}'(t)+\mathbf{v}'(t)
=
\mathbf{f}\bigl(t,\hat{\mathbf{u}}(t)\bigr)
+
\mathbf{J}(t)\mathbf{v}(t)
+
O\bigl(\|\mathbf{v}(t)\|^2\bigr).
$$

这里 $\mathbf{J}(t)$ 是 Jacobian 矩阵，其元素为

$$
J_{ij}=\frac{\partial f_i}{\partial u_j}\bigl(t,\hat{\mathbf{u}}(t)\bigr).
$$

如果忽略二阶小量，就得到扰动的线性演化方程.

> **Definition:** Linearization of an ODE
> A linearization of $\mathbf{u}'=\mathbf{f}(t,\mathbf{u})$ at an exact solution $\hat{\mathbf{u}}(t)$ is
> $$
> \mathbf{v}'(t)=\mathbf{J}(t)\mathbf{v}(t),
> $$
> where $\mathbf{v}(t)$ is a perturbation to the exact solution and $\mathbf{J}(t)$ is the Jacobian matrix evaluated along $\hat{\mathbf{u}}(t)$.

> **Example:**
> The Oregonator is a well-known ODE system modeling a chemical oscillator:
> $$
> \begin{aligned}
> u_1'&=s\Bigl[u_2(1-u_1)+u_1(1-qu_1)\Bigr],\\
> u_2'&=s^{-1}(u_3-u_2-u_1u_2),\\
> u_3'&=w(u_1-u_3),
> \end{aligned}
> $$
> where $s,q,w$ are constants. Linearization about an exact (unknown) solution $\hat{\mathbf{u}}(t)$ leads to the Jacobian
> $$
> \mathbf{J}(t)=
> \begin{bmatrix}
> s(1-\hat u_2-2q\hat u_1) & s(1-\hat u_1) & 0\\
> -\hat u_2/s & -(1+\hat u_1)/s & 1/s\\
> w & 0 & -w
> \end{bmatrix}.
> $$

**#3 冻结时间 (Freezing time) 与绝对稳定的经验法则**

虽然 $\mathbf{v}'=\mathbf{J}(t)\mathbf{v}$ 是线性的，但 $\mathbf{J}(t)$ 随时间变化，使分析变得困难. 如果扰动在某个时刻 $t=t_{\star}$ 被引入，我们可以把 Jacobian 在该时刻冻结，考虑常系数系统

$$
\mathbf{v}'=\mathbf{A}\mathbf{v},\qquad \mathbf{A}=\mathbf{J}(t_{\star}).
$$

这就回到了 **11-3-绝对稳定性** 讨论过的情形，于是得到下面的经验法则.

> **Observation:** Rule of thumb for absolute stability
> The eigenvalues of the Jacobian appearing in the linearization about an exact solution, after scaling by the time step $\tau$, should lie in the stability region of the IVP solver.

这里没有把它表述为定理，因为推理链中做了多处近似与假设，并不容易量化. 但如果这个经验法则被违反，我们就应当预期：围绕精确解的扰动会随时间显著增长，最终使数值解失去意义. 另外，舍入误差会不断引入新的扰动，因此这一判断应沿着整个数值解轨道持续适用.

> **Demo:** Jacobian eigenvalues along the Oregonator trajectory
> We solve the Oregonator and plot the eigenvalues of the Jacobian $\mathbf{J}(t)$ evaluated along the computed solution.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> from scipy.integrate import solve_ivp
>
> # Parameters in the Oregonator model.
> s = 77.27
> w = 0.161
> q = 8.375e-6
>
> def f(t, u):
>     u1, u2, u3 = u
>     return np.array([
>         s * (u2 * (1.0 - u1) + u1 * (1.0 - q * u1)),
>         (u3 - u2 - u1 * u2) / s,
>         w * (u1 - u3),
>     ])
>
> def jac(u):
>     u1, u2, u3 = u
>     return np.array([
>         [s * (1.0 - u2 - 2.0 * q * u1), s * (1.0 - u1), 0.0],
>         [-u2 / s, -(1.0 + u1) / s, 1.0 / s],
>         [w, 0.0, -w],
>     ])
>
> # Initial condition and time span.
> u0 = np.array([1.0, 2.0, 3.0])
> tspan = (0.0, 500.0)
>
> sol = solve_ivp(f, tspan, u0, method="Radau", rtol=1e-6, atol=1e-10)
> print("steps (Radau):", len(sol.t) - 1)
>
> eigvals = []
> for k in range(sol.y.shape[1]):
>     lam = np.linalg.eigvals(jac(sol.y[:, k]))
>     eigvals.append(lam)
> eigvals = np.array(eigvals)
>
> plt.figure()
> for j in range(3):
>     plt.plot(sol.t, sol.y[j, :], label=f"u{j+1}(t)")
> plt.yscale("log")
> plt.title("Solution of the Oregonator")
> plt.xlabel("t")
> plt.ylabel("state")
> plt.grid(True, alpha=0.3)
> plt.legend()
> plt.show()
>
> plt.figure()
> plt.scatter(eigvals.real.flatten(), eigvals.imag.flatten(), s=8, alpha=0.6)
> plt.title("Oregonator eigenvalues")
> plt.xlabel("Re(λ)")
> plt.ylabel("Im(λ)")
> plt.grid(True, alpha=0.3)
> plt.show()
> ```
>
> The eigenvalues typically include one that sweeps far along the negative real axis, which dominates stability considerations.
>
> > **Note:** 不同软件、不同容差设置会导致步数与点的分布不同，但 "刚性求解器用较少步数即可稳定推进，显式求解器会被迫选很小步长" 的现象应当是稳定可复现的.

**#4 多时间尺度 (Multiple time scales)**

对测试方程 $y'=\lambda y$、$y(0)=1$，精确解是 $e^{\lambda t}$. 若 $\lambda$ 是实数，则解在 $t=1/|\lambda|$ 左右会增长或衰减一个因子 $e$. 若 $\lambda=i\omega$ 是纯虚数，则解包含频率为 $\omega$ 的正弦与余弦. 复数 $\lambda$ 会同时叠加衰减 (或增长) 与振荡.

> **Observation:**
> We may regard $|\lambda|^{-1}$ (with units of time) as a characteristic time scale of dynamics due to eigenvalue $\lambda$.

因此，如果 Jacobian 的特征值跨越了不同数量级，就意味着系统包含多个时间尺度. 设 $|\lambda_1|\gg|\lambda_2|$. 任意显式积分器的稳定区域都是有界的，因此会施加与 $|\lambda_1|^{-1}$ 成正比的步长限制；而一个好的自适应积分器也会自然遵守这类限制来控制误差. 但如果我们想观察解中的 "慢" 部分，仿真就必须持续到 $|\lambda_2|^{-1}$ 的量级，这可能远大于 $|\lambda_1|^{-1}$.

在 Oregonator 的例子里，我们就能看到快速变化与缓慢演化交织在一起的行为.

> **Demo:** Step counts: stiff solver vs explicit solver
> We solve the Oregonator with a stiff solver and an explicit solver and compare their step counts.
>
> ```Python
> tspan_short = (0.0, 25.0)
> sol_stiff = solve_ivp(f, tspan_short, u0, method="Radau", rtol=1e-6, atol=1e-10)
> sol_exp = solve_ivp(f, tspan_short, u0, method="RK23", rtol=1e-6, atol=1e-10)
>
> print("steps (Radau):", len(sol_stiff.t) - 1)
> print("steps (RK23):", len(sol_exp.t) - 1)
> ```
>
> The explicit solver typically needs far more steps to cope with the large negative eigenvalue.

从 Jacobian 的特征值出发，我们还可以构造一个 "有效的" $\zeta(t)$：对每个时间步，把局部步长与当时的特征值相乘，得到 $\zeta=\tau\lambda$. 这些点应当大致落在所用显式方法的稳定区域之内 (或附近)；偶尔短暂越界是可能的，但如果长期反复越界，误差会被指数放大并触发不稳定.

**#5 A-稳定性**

一般来说，稳定区域越大，稳定性允许的时间步长就越大. 对扩散类半离散系统而言，Jacobian 的特征值会在负实轴上延伸到 $O(h^{-2})$ 的距离，因此任何在负实轴方向上有界的稳定区域都会导致 $\tau=O(h^2)$ 的稳定性限制 (只不过前面的常数不同).

因此，在刚性问题 (尤其是扩散问题) 中，我们希望稳定区域至少在负实轴方向上是无界的.

> **Definition:** A(alpha)- and A-stability
> A stability region that includes a sector of angle $\alpha$ in both directions from the negative real axis is called A($\alpha$)-stable.
>
> A time stepping method whose stability region contains the entire left half-plane is called A-stable.

对热方程而言，只要 $\alpha>0$，A($\alpha$)-稳定就足以保证无条件稳定.

A-稳定方法的稳定区域覆盖了所有实部非正的特征值. 换句话说，所有 "理论上应当随时间有界" 的扰动，在数值上也确实会被保持为有界. 当我们使用 A-稳定方法时，时间步长就可以只由精度来决定.

回顾 **11-3-绝对稳定性** 里的稳定区域图，我们已经遇到的 A-稳定方法只有 backward Euler (AM1) 与 trapezoid (AM2). 更高阶的 A-稳定方法并不容易得到.

> **Theorem:** Second Dahlquist stability barrier
> An A-stable linear multistep method must be implicit and have order of accuracy no greater than 2.

因此，在 A-稳定的线性多步法家族里，我们对精度的最高期待也就是二阶的 trapezoid 公式. Runge-Kutta 方法的情况略有不同，但也并没有好太多，这里暂不展开.
