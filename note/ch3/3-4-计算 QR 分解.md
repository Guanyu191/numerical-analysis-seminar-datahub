# 3-4-计算 QR 分解 (Computing QR factorizations)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 用正交变换做 "逐列消去"**

我们当然可以像做 LU 分解那样，用外积公式逐列逐行构造薄 QR 分解. 但如果我们的目标是稳定地计算分解，更好的策略是：用正交矩阵把下三角的元素逐列变成 0. 由于正交矩阵的乘积仍是正交矩阵，连续做很多次正交变换不会破坏 "正交性" 这个关键结构.

**#2 Householder 反射**

我们会使用一种特殊的正交矩阵.

> **Definition:** Householder reflector
> A **Householder reflector** is a matrix of the form
> $$
> \mathbf{P} = \mathbf{I} - 2\mathbf{v}\mathbf{v}^T,
> $$
> where $\mathbf{v}$ is any unit vector (in the 2-norm).

练习会让我们证明：只要 $\mathbf{v}$ 是单位向量，上面的 $\mathbf{P}$ 一定是正交矩阵. 另外，对任意维数匹配的向量 $\mathbf{x}$，

$$
\mathbf{P}\mathbf{x}=\mathbf{x}-2\mathbf{v}(\mathbf{v}^T\mathbf{x}).
$$

之所以叫 reflector，是因为它可以看成 "关于某个超平面的镜像反射". 当 $\mathbf{v}$ 是单位向量时，$\mathbf{v}^T\mathbf{x}$ 就是 $\mathbf{x}$ 在 $\mathbf{v}$ 方向上的分量. 因此减去 $(\mathbf{v}^T\mathbf{x})\mathbf{v}$ 会把 $\mathbf{x}$ 投影到与 $\mathbf{v}$ 正交的超平面上；而如果减去两倍，就得到穿过该超平面的反射.

给定一个向量 $\mathbf{z}$，我们可以选择 $\mathbf{v}$，使得 $\mathbf{P}$ 把 $\mathbf{z}$ 反射到 $x_1$ 轴上，也就是让 $\mathbf{P}\mathbf{z}$ 只有第一个分量非零. 因为正交矩阵保持 2-范数，所以必然有

$$
\mathbf{P}\mathbf{z}
=
\begin{bmatrix}
\pm\|\mathbf{z}\|\\
0\\
\vdots\\
0
\end{bmatrix}
=
\pm\|\mathbf{z}\|\mathbf{e}_1,
$$

其中 $\mathbf{e}_k$ 是单位矩阵的第 $k$ 列. 我们在讨论中选取正号，但在实现时需要注意符号选择对数值稳定性的影响.

令

$$
\mathbf{w}=\|\mathbf{z}\|\mathbf{e}_1-\mathbf{z},
\qquad
\mathbf{v}=\frac{\mathbf{w}}{\|\mathbf{w}\|}.
$$

如果 $\mathbf{w}=\boldsymbol{0}$，说明 $\mathbf{z}$ 已经处于目标形式，这时可以直接取 $\mathbf{P}=\mathbf{I}$. 否则，我们有下面的结论.

> **Theorem:** Householder reflector
> Let $\mathbf{v}$ be defined by
> $$
> \mathbf{w}=\|\mathbf{z}\|\mathbf{e}_1-\mathbf{z},
> \qquad
> \mathbf{v}=\frac{\mathbf{w}}{\|\mathbf{w}\|},
> $$
> and let $\mathbf{P}$ be given by $\mathbf{P}=\mathbf{I}-2\mathbf{v}\mathbf{v}^T$. Then $\mathbf{P}$ is symmetric and orthogonal, and $\mathbf{P}\mathbf{z}=\| \mathbf{z} \|\mathbf{e}_1$.
>
> **Proof:** The proofs of symmetry and orthogonality are left to the exercises. For the last fact, we use $\mathbf{P}\mathbf{x}=\mathbf{x}-2\mathbf{v}(\mathbf{v}^T\mathbf{x})$ to compute
> $$
> \mathbf{P}\mathbf{z} = \mathbf{z} - 2 \frac{\mathbf{w}^T \mathbf{z}}{\mathbf{w}^T\mathbf{w}} \mathbf{w}.
> $$
> Since $\mathbf{e}_1^T\mathbf{z}=z_1$,
> $$
> \begin{aligned}
> \mathbf{w}^T\mathbf{w}
> &=
> \| \mathbf{z} \|^2 - 2 \| \mathbf{z} \| z_1 + \mathbf{z}^T\mathbf{z}
> =
> 2\| \mathbf{z} \|(\| \mathbf{z} \|-z_1),\\
> \mathbf{w}^T\mathbf{z}
> &=
> \| \mathbf{z} \|z_1 - \mathbf{z}^T\mathbf{z}
> =
> -\| \mathbf{z} \|\bigl(\| \mathbf{z} \|-z_1\bigr),
> \end{aligned}
> $$
> leading finally to
> $$
> \begin{aligned}
> \mathbf{P}\mathbf{z}
> &=
> \mathbf{z} - 2\cdot
> \frac{-\| \mathbf{z} \| \bigl(\| \mathbf{z} \|-z_1\bigr)}{2\| \mathbf{z} \| \bigl(\| \mathbf{z} \|-z_1\bigr)} \mathbf{w}\\
> &=
> \mathbf{z} + \mathbf{w}
> =
> \| \mathbf{z} \|\mathbf{e}_1.
> \end{aligned}
> $$

> **Note:** 在数值实现里，计算 $\mathbf{w}=\|\mathbf{z}\|\mathbf{e}_1-\mathbf{z}$ 可能触发相减消去，因此通常会根据 $z_1$ 的符号改写成等价但更稳定的形式.

**#3 用 Householder 反射计算 QR 分解**

我们通过一系列 Householder 反射，把矩阵逐列变成上三角. 设 $\mathbf{A}\in\mathbb{R}^{m\times n}$ 且 $m\ge n$. 在第 $k$ 步，我们用一个反射把第 $k$ 列的对角线以下元素消成 0 (更准确地说，只作用在第 $k$ 行及其以下的子向量上).

> **Demo:** Householder QR: eliminate the lower triangle column by column.
> ```Python
> import numpy as np
>
> def householder_v(z):
>     """Return v (unit) for a Householder reflector that maps z to +-||z|| e1.
>     Returns None if the update would be trivial.
>     """
>     z = z.astype(float, copy=True)
>     normz = np.linalg.norm(z)
>     if normz == 0.0:
>         return None
>     s = 1.0 if z[0] >= 0.0 else -1.0
>     alpha = -s * normz
>     w = z.copy()
>     w[0] -= alpha
>     nrmw = np.linalg.norm(w)
>     if nrmw <= np.finfo(float).eps:
>         return None
>     return w / nrmw
>
> rng = np.random.default_rng(0)
> A = rng.integers(1, 10, size=(6, 4)).astype(float)
> m, n = A.shape
>
> Qt = np.eye(m)
> Rwork = A.copy()
> for k in range(n):
>     v = householder_v(Rwork[k:, k])
>     if v is None:
>         continue
>     # Apply the reflector to the active submatrix (left-multiplication).
>     Rwork[k:, :] -= 2.0 * np.outer(v, v @ Rwork[k:, :])
>     Qt[k:, :]    -= 2.0 * np.outer(v, v @ Qt[k:, :])
>
> R = np.triu(Rwork)
> Q = Qt.T
>
> print("||A - Q R|| =", np.linalg.norm(A - Q @ R))
> print("||Q^T Q - I|| =", np.linalg.norm(Q.T @ Q - np.eye(m)))
> print("R is upper triangular (up to rounding):")
> print(R)
> ```
> The key outcome is that `R` becomes upper triangular while `Q` stays orthogonal.

**#4 构造 $\mathbf{Q}$，以及 Q-less QR**

在上面的消去过程中，我们一直在左乘某个 Householder 反射. 但每一步的反射 $\mathbf{P}_k$ 并不是满尺寸的 $m\times m$ 矩阵：它只作用在从第 $k$ 行开始的子块上. 为了把这个事实写成矩阵乘法，我们把它 "补全" 成分块对角形式

$$
\mathbf{Q}_k =
\begin{bmatrix}
\mathbf{I}_{k-1} & \boldsymbol{0}\\
\boldsymbol{0} & \mathbf{P}_k
\end{bmatrix}.
$$

可以验证 $\mathbf{Q}_k$ 仍然是正交矩阵. 于是算法实际上在做

$$
\mathbf{Q}_n\mathbf{Q}_{n-1}\cdots\mathbf{Q}_1\mathbf{A}=\mathbf{R}.
$$

左端那串乘积也是正交矩阵，因此再左乘它的转置就得到 $\mathbf{A}=\mathbf{Q}\mathbf{R}$，其中

$$
\mathbf{Q}=\bigl(\mathbf{Q}_n\mathbf{Q}_{n-1}\cdots\mathbf{Q}_1\bigr)^T.
$$

我们甚至不需要显式形成每个 $\mathbf{Q}_k$. 写成

$$
\mathbf{Q}^T
=
\mathbf{Q}_n\mathbf{Q}_{n-1}\cdots\mathbf{Q}_1
=
\mathbf{Q}_n\Bigl(\mathbf{Q}_{n-1}\bigl(\cdots(\mathbf{Q}_1\mathbf{I})\cdots\bigr)\Bigr),
$$

就能看出：从单位矩阵开始，对它施加与 $\mathbf{A}$ 同样的行变换，就可以逐步构造出 $\mathbf{Q}^T$，而不必存下所有 $\mathbf{Q}_k$.

上面的算法可以概括成一个函数. 另外，利用

$$
\mathbf{P}\mathbf{x}=\mathbf{x}-2\mathbf{v}(\mathbf{v}^T\mathbf{x}),
$$

我们可以在不显式构造 $\mathbf{P}$ 的前提下，把反射作用到向量或矩阵列上.

> **Function:** qrfact
> **QR factorization by Householder reflections**
> ```Python
> import numpy as np
>
> def qrfact(A):
>     """
>     QR factorization by Householder reflections. Returns Q and R.
>     """
>     A = np.asarray(A, dtype=float)
>     m, n = A.shape
>     Qt = np.eye(m)
>     R = A.copy()
>
>     for k in range(n):
>         z = R[k:, k]
>         normz = np.linalg.norm(z)
>         if normz == 0.0:
>             continue
>         s = 1.0 if z[0] >= 0.0 else -1.0
>         alpha = -s * normz
>         w = z.copy()
>         w[0] -= alpha
>         nrmw = np.linalg.norm(w)
>         if nrmw <= np.finfo(float).eps:
>             continue
>         v = w / nrmw
>
>         # Apply the reflection to each relevant column of A and Q.
>         R[k:, :] -= 2.0 * np.outer(v, v @ R[k:, :])
>         Qt[k:, :] -= 2.0 * np.outer(v, v @ Qt[k:, :])
>
>     Q = Qt.T
>     return Q, np.triu(R)
> ```

在最小二乘问题中，我们真正需要的并不是 $\mathbf{Q}$ 本身，而是 $\hat{\mathbf{Q}}^T\mathbf{b}$. Householder 反射的结构让这个量可以在不显式形成 $\mathbf{Q}$ 的情况下计算出来：我们只要把每次构造出来的 Householder 向量 $\mathbf{v}$ 依次应用到 $\mathbf{b}$ 上即可. 这就引出了 **Q-less QR factorization**：从头到尾都不显式生成 full 或 thin 的 $\mathbf{Q}$.

> **Theorem:** Q-less QR factorization by Householder reflections takes $\sim(2mn^2-\frac{2}{3}n^3)$ flops.

用 QR 解最小二乘的运行时间主要由这个 flop 数主导. 与 **3-2-正规方程** 里正规方程路线的计算量相比，当 $m=n$ 时两者基本一致；当 $m\gg n$ 时，QR 的代价大约是正规方程的两倍. 但 QR 路线的优势在于更好的稳定性 (这里先不展开).
