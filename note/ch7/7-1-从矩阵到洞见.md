# 7-1-从矩阵到洞见 (From matrix to insight)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 从二维数组到矩阵视角**

任意一个二维数表，我们都可以把它当作一个矩阵来解释. 即便某个应用并不把 "矩阵" 当作唯一重要的观点，但这种视角往往会带来特定类型的分析. 与之配套的数学工具与计算工具具有普适性，因此能在很多场景里复用.

**#2 表格作为矩阵**

表格常用来表示某个量随两个变量变化的规律. 我们可以把这两个变量分别编码为矩阵的行与列，从而把表格直接视为一个矩阵.

> **Example:** Term-document matrix
> A corpus is a collection of text documents. A **term-document matrix** has one column for each document and one row for each unique term appearing in the corpus. The $(i,j)$ entry of the matrix is the number of times term $i$ appears in document $j$. That is, column $j$ of the matrix is a term-frequency vector quantifying all occurrences of the indexed terms. A new document could be represented by its term-frequency vector, which is then comparable to the columns of the matrix. Or, a new term could be represented by counting its appearances in all of the documents and be compared to the rows of the matrix.
>
> It turns out that by finding the **singular value decomposition** of the term-document matrix, the strongest patterns within the corpus can be isolated, frequently corresponding to what we interpret as textual meaning. This is known as **latent semantic analysis**.

> **Example:** Votes as a matrix
> Each vote cast in the U. S. Congress is available for download. We can put members of Congress along the columns of a matrix and bills along the rows, recording a number that codes for "yea", "nay", "none", etc. The **singular value decomposition** can reveal an objective, reproducible analysis of the partisanship and cooperation of individual members.

> **Example:** Netflix and matrix completion
> In 2006 the online video service Netflix started an open competition for a $1 million prize. They provided a data set of 100,480,507 ratings (one to five stars) made by 480,189 users for 17,770 movies. Each rating is implicitly an entry in a 17,770-by-480,189 matrix. The object of the prize was to predict a user's ratings for movies they had not rated. This is known as a **matrix completion** problem. (It took 6 days for a contestant to improve on Netflix's private algorithm, and in 2009 the million-dollar prize was awarded to a team that had improved the performance by over 10%.)

**#3 图作为矩阵**

图 (graph) 或网络 (network) 能用来表示社交网络的链接结构、航线网络、电网、体育比赛关系、网页链接等. 直观上，一条边 $(v_i,v_j)$ 表示从节点 $i$ 指向节点 $j$ 的链接. 我们通常把小图画成点 (节点) 与箭头/线段 (边).

> **Definition:** Graphs and adjacency matrices
> A graph or network consists of a set $V$ of nodes and a set $E$ of edges, each of which is an ordered pair of nodes. The graph is **undirected** if for every edge $(v_i,v_j)$, the pair $(v_j,v_i)$ is also an edge; otherwise the graph is **directed**.
>
> The **adjacency matrix** of a graph with $n$ nodes $V$ and edge set $E$ is the $n\times n$ matrix $\mathbf{A}$ whose elements are
> $$
> A_{ij}=
> \begin{cases}
> 1, & \text{if } (v_i,v_j)\in E \text{ (i.e., there is an edge from node } i \text{ to node } j),\\
> 0, & \text{otherwise.}
> \end{cases}
> $$

把图表示成邻接矩阵后，我们就能用线性代数来分析图. 例如，我们可以问：节点是否天然地可以分成若干簇. 或者，我们可以按某种可复现的客观准则给节点排序 (哪个更 "重要" ). 这些问题常常会落到特征值问题上 (例如 PageRank).

> **Theorem:** Basic facts about adjacency matrices
> For any graph with adjacency matrix $\mathbf{A}$,
> 1. The graph is undirected if and only if $\mathbf{A}$ is symmetric, and
> 2. For any positive integer $k$, the $(i,j)$ element of $\mathbf{A}^k$ is the number of ways to walk from node $i$ to node $j$ by following along exactly $k$ edges.

> **Demo:** Adjacency matrix and walk counts
> We create an adjacency matrix for a graph on four nodes and compute $\mathbf{A}^3$ to count all walks of length 3.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> A = np.array([
>     [0, 1, 0, 0],
>     [1, 0, 0, 0],
>     [1, 1, 0, 1],
>     [0, 1, 1, 0],
> ], dtype=int)
>
> A3 = np.linalg.matrix_power(A, 3)
> print("A =\\n", A)
> print("A^3 =\\n", A3)
>
> # Optional: visualize the directed graph.
> try:
>     import networkx as nx
>     G = nx.DiGraph(A)
>     pos = nx.spring_layout(G, seed=0)
>     nx.draw(G, pos, with_labels=True, arrows=True, node_size=600)
>     plt.title("Directed graph from adjacency matrix")
>     plt.show()
> except Exception as e:
>     print("Skipping plot (needs networkx).", type(e).__name__, str(e))
> ```
>
> If the adjacency matrix is symmetric, the graph is undirected.

**#4 图像作为矩阵**

计算机通常把图像表示为像素 (pixel) 的矩形阵列. 每个像素由红 (R)、绿 (G)、蓝 (B) 三个分量的数值决定. 在常见的表示里，这些分量是 $0$ 到 $255$ 之间的整数：$0$ 表示没有该颜色分量，$255$ 表示该分量最强.

因此，一张 $m\times n$ 像素的彩色图像可以存成一个形状为 $m\times n\times 3$ 的数组. 这意味着我们既可以把整张图像当作一个大数组，也可以把每个像素当作一个长度为 3 的向量，从而把图像自然地嵌入线性代数的语境中.

> **Demo:** Loading an image as an array
> We load a sample image, inspect its shape and pixel type, extract RGB channels, convert to grayscale, and flip it vertically.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> # Prefer a built-in sample image. If scikit-image is unavailable, fall back to a simple synthetic one.
> try:
>     from skimage import data
>     img = data.astronaut()  # shape (m, n, 3), dtype uint8
> except Exception:
>     rng = np.random.default_rng(0)
>     img = rng.integers(0, 256, size=(128, 128, 3), dtype=np.uint8)
>
> print("img.shape =", img.shape)
> print("img.dtype =", img.dtype)
> print("img[100, 10] =", img[min(100, img.shape[0]-1), min(10, img.shape[1]-1)])
>
> # Scale to [0,1] floats for numerical work.
> X = img.astype(float) / 255.0
> R, G, B = X[..., 0], X[..., 1], X[..., 2]
> print("min(B), max(B) =", float(B.min()), float(B.max()))
>
> # Convert to grayscale (luminance model).
> A = 0.2126 * R + 0.7152 * G + 0.0722 * B
>
> plt.figure(figsize=(9, 3))
> plt.subplot(1, 3, 1)
> plt.imshow(img)
> plt.axis("off")
> plt.title("RGB")
>
> plt.subplot(1, 3, 2)
> plt.imshow(A, cmap="gray", vmin=0, vmax=1)
> plt.axis("off")
> plt.title("Grayscale")
>
> plt.subplot(1, 3, 3)
> plt.imshow(A[::-1, :], cmap="gray", vmin=0, vmax=1)  # flip vertically
> plt.axis("off")
> plt.title("Flipped")
>
> plt.tight_layout()
> plt.show()
> ```
>
> The key point is that the image is an array. Its entries encode colors, and we can reinterpret them as floating-point values to apply our usual matrix operations.

把图像表示为矩阵后，我们就能用线性代数来描述一些常见的图像操作. 例如，在 **7-3-奇异值分解** 中我们会用奇异值分解来压缩信息，而在 **8-7-无矩阵迭代** 中会讨论如何在不显式形成矩阵的情况下应用某些线性算子 (例如模糊与去模糊).

> **Note:** 本节 Demo 主要依赖 `numpy` 与 `matplotlib`. 若安装了 `scikit-image`，可以直接使用其自带的示例图像.
