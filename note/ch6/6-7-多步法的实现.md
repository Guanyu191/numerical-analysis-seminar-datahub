# 6-7-多步法的实现 (Implementation of multistep methods)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 多步法实现的关键难点**

本节讨论多步法在 IVP 中实现时遇到的实际问题. 重点放在向量 IVP

$$
\mathbf{u}'=\mathbf{f}(t,\mathbf{u})
$$

上，并把 **6-6-多步法** 的差分公式写成向量形式.

多步法实现时通常会碰到以下问题：

- 需要启动值：显式/隐式多步法都需要 $k-1$ 个历史解值；实践中常用 RK 生成.
- 显式法需要维护历史 $f$ 值：每步只做一次新的 $f$ 评估，其余来自缓存.
- 隐式法每步都要解一个求根问题：成本不可预知，但在某些问题里反而更高效.

**#2 显式多步法: AB4 的基本实现**

以四阶 Adams-Bashforth (AB4) 为例，它的迭代公式是

$$
u_{i+1}
=
u_i
+
h\left(\frac{55}{24}f_i-\frac{59}{24}f_{i-1}+\frac{37}{24}f_{i-2}-\frac{9}{24}f_{i-3}\right),
\qquad i=3,\dots,n-1.
$$

实现时有两个要点：

1. 用 RK4 先得到 $u_1,u_2,u_3$ 作为启动值 (步长与 AB4 相同).
2. 维护最近的 $f$ 历史：每步插入一个新的 $f_i$，并丢弃最旧的一个.

> **Function:** ab4
> **4th-order Adams-Bashforth for an IVP**
> ```Python
> import numpy as np
>
> def rk4(f, tspan, u0, n):
>     a, b = float(tspan[0]), float(tspan[1])
>     h = (b - a) / n
>     t = a + h * np.arange(n + 1)
>     u0 = np.asarray(u0, dtype=float)
>     u = np.empty((n + 1,) + u0.shape, dtype=float)
>     u[0] = u0
>     for i in range(n):
>         k1 = h * np.asarray(f(t[i], u[i]), dtype=float)
>         k2 = h * np.asarray(f(t[i] + 0.5*h, u[i] + 0.5*k1), dtype=float)
>         k3 = h * np.asarray(f(t[i] + 0.5*h, u[i] + 0.5*k2), dtype=float)
>         k4 = h * np.asarray(f(t[i] + h, u[i] + k3), dtype=float)
>         u[i + 1] = u[i] + (k1 + 2*(k2 + k3) + k4) / 6.0
>     return t, u
>
> def ab4(f, tspan, u0, n):
>     a, b = float(tspan[0]), float(tspan[1])
>     h = (b - a) / n
>     t = a + h * np.arange(n + 1)
>
>     u0 = np.asarray(u0, dtype=float)
>     u = np.empty((n + 1,) + u0.shape, dtype=float)
>
>     # Startup values from RK4 on [a, a+3h].
>     _, ustart = rk4(f, (a, a + 3*h), u0, 3)
>     u[0:4] = ustart
>
>     sigma = np.array([55.0, -59.0, 37.0, -9.0]) / 24.0
>
>     # f-history: [f_i, f_{i-1}, f_{i-2}, f_{i-3}] at current i.
>     f_hist = [
>         np.asarray(f(t[3], u[3]), dtype=float),
>         np.asarray(f(t[2], u[2]), dtype=float),
>         np.asarray(f(t[1], u[1]), dtype=float),
>         np.asarray(f(t[0], u[0]), dtype=float),
>     ]
>
>     for i in range(3, n):
>         u[i + 1] = u[i] + h * sum(sigma[j] * f_hist[j] for j in range(4))
>         # Update history for next step.
>         f_hist = [np.asarray(f(t[i + 1], u[i + 1]), dtype=float)] + f_hist[:3]
>
>     return t, u
> ```

> **Demo:** Convergence of AB4
> We study AB4 on $u' = \\sin((u+t)^2)$ over $0\\le t\\le 4$ with $u(0)=-1$, using a high-accuracy reference from `solve_ivp`.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> from scipy.integrate import solve_ivp
>
> def rhs(t, y):
>     u = y[0]
>     return [np.sin((t + u)**2)]
>
> ref = solve_ivp(rhs, (0.0, 4.0), [-1.0], method="DOP853", rtol=1e-14, atol=1e-14, dense_output=True)
>
> def f(t, u):
>     return np.sin((t + u)**2)
>
> ns = np.round(4 * 10 ** np.arange(0, 3.1, 0.5)).astype(int)
> err = []
> for n in ns:
>     t, u = ab4(f, (0.0, 4.0), -1.0, int(n))
>     uref = ref.sol(t)[0]
>     err.append(np.max(np.abs(uref - u)))
>
> err = np.array(err)
> plt.loglog(ns, err, "o-", label="AB4")
> plt.loglog(ns, err[0] * (ns / ns[0])**(-4), ls="--", label=r"$O(n^{-4})$")
> plt.xlabel("n")
> plt.ylabel("inf-norm error")
> plt.title("Convergence of AB4")
> plt.grid(True, which="both", alpha=0.3)
> plt.legend()
> plt.show()
> ```

**#3 隐式多步法: AM2 (梯形法) 的求根步骤**

隐式多步法每步都要解一个隐式方程. 以二阶 Adams-Moulton (AM2) 为例，它也常被称为 **trapezoid method**：

$$
u_{i+1}=u_i+\frac{h}{2}\bigl[f(t_i,u_i)+f(t_{i+1},u_{i+1})\bigr].
$$

把未知量记为 $z$，则每步需要解

$$
g(z)=z-\frac{h}{2}f(t_{i+1},z)-\left(u_i+\frac{h}{2}f(t_i,u_i)\right)=0,
$$

因此可以直接调用 Chapter 4 的求根算法.

> **Function:** am2
> **2nd-order Adams-Moulton (trapezoid) for an IVP**
> ```Python
> import numpy as np
> from scipy.optimize import root, root_scalar
>
> def am2(f, tspan, u0, n):
>     a, b = float(tspan[0]), float(tspan[1])
>     h = (b - a) / n
>     t = a + h * np.arange(n + 1)
>
>     u0 = np.asarray(u0, dtype=float)
>     is_scalar = (u0.shape == ())
>     if is_scalar:
>         u = np.empty(n + 1, dtype=float)
>         u[0] = float(u0)
>     else:
>         u = np.empty((n + 1,) + u0.shape, dtype=float)
>         u[0] = u0
>
>     for i in range(n):
>         ui = u[i]
>         known = ui + 0.5 * h * f(t[i], ui)
>
>         if is_scalar:
>             g = lambda z: z - 0.5 * h * f(t[i + 1], z) - known
>             sol = root_scalar(g, x0=float(ui), x1=float(ui) + 1e-3, method="secant")
>             u[i + 1] = sol.root
>         else:
>             known = np.asarray(known, dtype=float)
>             def g(z):
>                 z = np.asarray(z, dtype=float)
>                 return z - 0.5 * h * np.asarray(f(t[i + 1], z), dtype=float) - known
>             sol = root(g, x0=np.asarray(ui, dtype=float), method="hybr")
>             u[i + 1] = sol.x.reshape(u0.shape)
>
>     return t, u
> ```

**#4 刚性 (stiffness)：隐式法可能反而更省**

隐式法每一步都需要求根，单步代价通常远大于显式法. 但在某些问题里，隐式法依然会显著更高效. 这类问题称为 **stiff problems**，并且通常说它们具有 **stiffness**.

> **Demo:** A stiff problem where implicit wins
> We solve $u'=u^2-u^3$ on $[0,400]$ with $u(0)=0.005$. With the same number of steps, AB4 can go catastrophically wrong while AM2 remains reasonable.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> f = lambda t, u: u**2 - u**3
>
> n = 200
> tI, uI = am2(f, (0.0, 400.0), u0=0.005, n=n)
> tE, uE = ab4(f, (0.0, 400.0), u0=0.005, n=n)
>
> plt.plot(tI, uI, label="AM2")
> plt.scatter(tE, uE, s=10, label="AB4")
> plt.ylim(-4, 2)
> plt.xlabel("t")
> plt.ylabel("u(t)")
> plt.title("Stiffness demo")
> plt.legend()
> plt.grid(True, alpha=0.3)
> plt.show()
> ```

一个典型的 stiff 迹象是：解的行为同时包含非常慢的时间尺度与非常快的时间尺度. 显式法会被最 "快" 的尺度绑架，不得不处处用很小的步长；隐式法则可能在慢区间用大步跨过，从而整体更省.

**#5 多步法的自适应**

类似于 **6-5-自适应-Runge-Kutta**，多步法也能用 "一对不同阶的方法" 来估计误差并调节步长. 例如 AB3 与 AB4 的 stages 完全相同，只是组合系数不同，因此在几乎零额外成本下就能产生误差估计.

但多步法依赖历史值：一旦改变步长 $h$，历史的 $u_{i-1},u_{i-2},\dots$ 与 $f_{i-1},f_{i-2},\dots$ 不再位于迭代公式所需的正确时间点上. 常见补救方式是用插值把历史值重采样到新步长网格上. 细节较繁琐，本节不展开.
