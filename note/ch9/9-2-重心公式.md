# 9-2-重心公式 (The barycentric formula)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 为什么需要重心公式**

Lagrange 公式在理论上很有用，但并不适合做数值计算. 对每一个新的评估点 $x$，我们都需要把所有 cardinal 基函数 $\ell_k(x)$ 都算出来；每个 $\ell_k$ 都需要做 $n$ 项乘积，因此每个 $x$ 的总工作量是 $O(n^2)$. 更糟的是，Lagrange 公式在数值上是不稳定的.

这里介绍一个代数上等价的替代表达：它既更快，也更稳定.

**#2 推导与重心权重**

我们继续使用 **9-1-多项式插值** 中的

$$
\Phi(x)=\prod_{j=0}^{n}(x-t_j),
$$

并定义 **重心权重 (barycentric weights)**：

$$
w_k
=
\frac{1}{\prod_{\substack{j=0\\ j\ne k}}^{n}(t_k-t_j)}
=
\frac{1}{\Phi'(t_k)},
\qquad k=0,\dots,n.
$$

下面的公式是高效、稳定评估插值多项式的关键.

> **Theorem:** Barycentric interpolation formula
> Given points $(t_k,y_k)$ for $k=0,\dots,n$ with all the $t_k$ distinct, the unique polynomial of degree $n$ or less that interpolates the points is
> $$
> p(x)=
> \frac{\sum_{k=0}^{n}\dfrac{w_k y_k}{x-t_k}}{\sum_{k=0}^{n}\dfrac{w_k}{x-t_k}}.
> $$

这个写法看起来很奇怪：当 $x$ 等于某个节点时分母为 0. 但实际上 $\lim_{x\to t_k}p(x)=y_k$，因此它可以用连续延拓自然地定义在节点上.

**#3 一个二次插值的例子**

> **Example:** Barycentric form for the quadratic interpolant
> Consider the quadratic case $(n=2)$ from the example in **9-1-多项式插值**. The weights are
> $$
> w_0=\frac{1}{(t_0-t_1)(t_0-t_2)}=\frac{18}{\pi^2},\qquad
> w_1=-\frac{36}{\pi^2},\qquad
> w_2=\frac{18}{\pi^2}.
> $$
> Note that any common factor cancels out in the barycentric formula, so we can use $w_0=w_2=1$ and $w_1=-2$ instead. Then
> $$
> p(x)=
> \frac{\dfrac{1}{x-t_0}y_0-\dfrac{2}{x-t_1}y_1+\dfrac{1}{x-t_2}y_2}{\dfrac{1}{x-t_0}-\dfrac{2}{x-t_1}+\dfrac{1}{x-t_2}}.
> $$
> Further algebraic manipulation can return this expression to the classical Lagrange form.

**#4 计算权重：递推构造**

对一些重要节点分布，$w_k$ 有简单的显式公式. 否则，我们需要先数值计算 $w_k$ (更方便的是先算它的倒数).

我们从单点集合 $\{t_0\}$ 开始，此时唯一的权重为 $w_0=1$. 接下来逐个加入新节点，使用递推更新.

设 $\omega_{k,m-1}$ (对 $k<m$) 表示：在节点集合 $\{t_0,\dots,t_{m-1}\}$ 上，对节点 $t_k$ 的权重倒数. 也就是

$$
\omega_{k,m}=\prod_{\substack{j=0\\ j\ne k}}^{m}(t_k-t_j)
=
\omega_{k,m-1}(t_k-t_m),
\qquad k=0,1,\dots,m-1.
$$

迭代 $m=1,\dots,n$ 后得到 $\omega_{k,n}$，然后

$$
w_k=\omega_{k,n}^{-1}.
$$

**#5 Python 版实现**

计算全部 $n+1$ 个权重需要 $O(n^2)$ 次运算. 但权重只依赖于节点，不依赖于数据. 一旦 $w_k$ 已经算好，对任意给定的 $x$，评估 $p(x)$ 只需要 $O(n)$ 次运算.

> **Algorithm:** polyinterp (barycentric)
> Given nodes $t_0,\dots,t_n$ and data $y_0,\dots,y_n$, precompute weights $w_0,\dots,w_n$ and evaluate
> $$
> p(x)=
> \frac{\sum_{k=0}^{n}\dfrac{w_k y_k}{x-t_k}}{\sum_{k=0}^{n}\dfrac{w_k}{x-t_k}},
> $$
> using the continuous extension $p(t_k)=y_k$ at the nodes.

> **Demo:** Polynomial interpolation by the barycentric formula
> We implement a callable interpolant and apply it to values of $f(x)=\\sin(e^{2x})$ on $[0,1]$ using equispaced nodes.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> def barycentric_weights(t):
>     t = np.asarray(t, dtype=float)
>     n = t.size - 1
>     # A mild scaling reduces overflow/underflow risk in products.
>     C = (t[-1] - t[0]) / 4.0 if t[-1] != t[0] else 1.0
>     tc = t / C
>     omega = np.ones(n + 1, dtype=float)
>     for m in range(n):
>         d = tc[: m + 1] - tc[m + 1]
>         omega[: m + 1] *= d
>         omega[m + 1] = np.prod(-d)
>     return 1.0 / omega
>
> def polyinterp(t, y):
>     t = np.asarray(t, dtype=float)
>     y = np.asarray(y, dtype=float)
>     w = barycentric_weights(t)
>     def p(x):
>         x = float(x)
>         diff = x - t
>         # Node hit: return the data value directly.
>         j = np.where(diff == 0.0)[0]
>         if j.size:
>             return float(y[j[0]])
>         terms = w / diff
>         return float(np.sum(y * terms) / np.sum(terms))
>     return p
>
> f = lambda x: np.sin(np.exp(2 * x))
>
> def plot_interp(n):
>     t = np.linspace(0.0, 1.0, n + 1)
>     y = f(t)
>     p = polyinterp(t, y)
>     xs = np.linspace(0.0, 1.0, 800)
>     plt.plot(xs, f(xs), label="function")
>     plt.plot(xs, [p(x) for x in xs], label="interpolant")
>     plt.scatter(t, y, color="black", label="nodes")
>     plt.title(f"Interpolation on {n+1} nodes")
>     plt.grid(True, alpha=0.3)
>     plt.legend()
>
> plt.figure(figsize=(8, 3))
> plt.subplot(1, 2, 1)
> plot_interp(3)
> plt.subplot(1, 2, 2)
> plot_interp(6)
> plt.tight_layout()
> plt.show()
> ```
>
> The interpolant must pass through the nodes; using more nodes typically improves the approximation on this interval.

**#6 稳定性直觉**

当 $x$ 接近某个节点 $t_k$ 时，重心公式里会出现 $1/(x-t_k)$，看起来会因为减法消去而引入严重误差. 这种误差确实会出现，但它在分子与分母中以相同方式发生，因此不会造成麻烦. 更严格地说，重心公式已经被证明是稳定的，这里不展开证明细节.

