# 9-1-多项式插值 (Polynomial interpolation)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 问题设定与唯一性**

在 **2-1-多项式插值** 与 **5-1-插值问题** 中，我们遇到过多项式插值：给定 $n+1$ 个数据点

$$
(t_0,y_0),\dots,(t_n,y_n),
$$

其中 $t_i$ 是插值节点 (data nodes)，$x$ 是自变量. 需要记住的是：数学记号里我们习惯从 0 开始编号，但写代码时索引通常要整体加 1.

从理论上说，我们总能构造一个插值多项式，并且在次数限制下它是唯一的.

> **Theorem:** Uniqueness of polynomial interpolation
> If the nodes $t_0,\dots,t_n$ are all distinct, there exists a unique polynomial $p$ of degree at most $n$ that satisfies $p(t_k)=y_k$ for all $k=0,\dots,n$.

**#2 Lagrange 基与基函数**

前面我们曾用 Vandermonde 矩阵来求插值多项式：先在单项式基 $1,x,x^2,\dots$ 下表示未知多项式，再解一个线性系统. 但如同 **5-2-分段线性插值** 所强调的：在插值问题里，没有比 cardinal basis (基函数在一个节点取 1、在其他节点取 0) 更顺手的基了.

对全局多项式插值而言，我们也可以直接构造这种基函数. 按定义，第 $k$ 个基函数 $\ell_k$ 是一个 $n$ 次多项式，并满足

$$
\ell_k(t_j)=
\begin{cases}
1, & j=k,\\
0, & j\ne k.
\end{cases}
$$

回忆：任意 $n$ 次多项式都可以写成

$$
c(x-r_1)(x-r_2)\cdots(x-r_n)=c\prod_{k=1}^{n}(x-r_k),
$$

其中 $r_1,\dots,r_n$ 是多项式的根，$c$ 是常数. 上面的 cardinal 条件告诉我们：$\ell_k$ 的 $n$ 个根正是除 $t_k$ 之外的所有节点，归一化条件 $\ell_k(t_k)=1$ 则决定了 $c$ 的取值.

> **Definition:** Lagrange cardinal polynomial
> Given distinct nodes $t_0,\dots,t_n$, the polynomial
> $$
> \ell_k(x)
> =
> \frac{(x-t_0)\cdots(x-t_{k-1})(x-t_{k+1})\cdots(x-t_n)}{(t_k-t_0)\cdots(t_k-t_{k-1})(t_k-t_{k+1})\cdots(t_k-t_n)}
> =
> \prod_{\substack{i=0\\ i\ne k}}^{n}\frac{x-t_i}{t_k-t_i}
> $$
> is of degree at most $n$ and satisfies the cardinality conditions $\ell_k(t_j)=\delta_{jk}$.

> **Demo:** Lagrange cardinal function
> We construct $\ell_k$ from the product definition and confirm the cardinal property by plotting it and marking the node values.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> t = np.array([1.0, 1.5, 2.0, 2.25, 2.75, 3.0])
> n = t.size - 1
> k = 2  # 0-based index
>
> def ell(x):
>     num = 1.0
>     den = 1.0
>     for i in range(n + 1):
>         if i == k:
>             continue
>         num *= (x - t[i])
>         den *= (t[k] - t[i])
>     return num / den
>
> xs = np.linspace(1.0, 3.0, 800)
> ys = np.array([ell(x) for x in xs])
>
> plt.plot(xs, ys, label=r"$\\ell_2(x)$")
> y_nodes = np.zeros(n + 1)
> y_nodes[k] = 1.0
> plt.scatter(t, y_nodes, color="black", zorder=3)
> plt.xlabel("x")
> plt.ylabel(r"$\\ell_2(x)$")
> plt.title("Lagrange cardinal function")
> plt.grid(True, alpha=0.3)
> plt.show()
> ```
>
> Unlike a hat function, $\ell_k$ is not confined between 0 and 1 everywhere.

**#3 Lagrange 插值公式**

因为 $\{\ell_0,\dots,\ell_n\}$ 是一组 cardinal basis，所以插值多项式可以直接写成线性组合：

> **Theorem:** Lagrange interpolation formula
> Given points $(t_k,y_k)$ for $k=0,\dots,n$ with all the $t_k$ distinct, the unique polynomial of degree $n$ or less that interpolates the points is
> $$
> p(x)=\sum_{k=0}^{n}y_k\ell_k(x).
> $$

> **Note:** 这个公式把 "存在性、唯一性、构造方法" 合到了一起：一旦我们有了 $\ell_k$，就直接得到 $p(x)$.

> **Example:** Interpolating samples of $\tan(x)$
> We construct the Lagrange interpolating polynomials of degrees $n=1$ and $n=2$ for $f(x)=\tan(x)$.
>
> For $n=1$, use $t_0=0$ and $t_1=\pi/3$. Then
> $$
> \begin{aligned}
> P_1(x)
> &= y_0\ell_0(x)+y_1\ell_1(x)\\
> &= y_0\frac{x-t_1}{t_0-t_1}+y_1\frac{x-t_0}{t_1-t_0}\\
> &= 0\cdot\frac{x-\pi/3}{0-\pi/3}+\sqrt{3}\cdot\frac{x-0}{\pi/3-0}
> = \frac{3\sqrt{3}}{\pi}x.
> \end{aligned}
> $$
>
> For $n=2$, use $t_0=0$, $t_1=\pi/6$, and $t_2=\pi/3$. Then
> $$
> P_2(x)
> =
> y_0\frac{(x-t_1)(x-t_2)}{(t_0-t_1)(t_0-t_2)}
> +
> y_1\frac{(x-t_0)(x-t_2)}{(t_1-t_0)(t_1-t_2)}
> +
> y_2\frac{(x-t_0)(x-t_1)}{(t_2-t_0)(t_2-t_1)}
> =
> \frac{6\sqrt{3}}{\pi^2}x^2+\frac{\sqrt{3}}{\pi}x.
> $$

**#4 误差公式**

除了存在性、唯一性与 Lagrange 公式之外，我们还需要一个把误差表达出来的公式：当数据来自某个光滑函数 $f$ 的采样时，插值误差可以写成一个 "导数项 × 节点项" 的乘积.

我们先定义一个只由节点决定的函数.

> **Definition:** Error indicator function
> For a set of distinct nodes $t_0,\dots,t_n$, define
> $$
> \Phi(x)=\prod_{i=0}^{n}(x-t_i).
> $$

> **Theorem:** Polynomial interpolation error
> Let $t_0,\dots,t_n$ be distinct points in $[a,b]$, and suppose $f$ has at least $n+1$ continuous derivatives in that interval. Let $p(x)$ be the unique polynomial of degree at most $n$ interpolating $f$ at $t_0,\dots,t_n$. Then for each $x\in[a,b]$, there exists a number $\xi(x)\in(a,b)$ such that
> $$
> f(x)-p(x)=\frac{f^{(n+1)}(\xi(x))}{(n+1)!}\,\Phi(x).
> $$

通常 $\xi(x)$ 与 $f^{(n+1)}$ 都是未知的. 这个公式的意义在于：它让我们能把误差看成 $x$ 的函数，并显式展示误差对节点 $t_0,\dots,t_n$ 的依赖方式. 后面我们会利用这一点来理解 "选点" 为什么会决定插值的好坏.

> **Demo:** Interpolation error and an upper bound
> We interpolate $f(x)=\\log(x)$ on $[1,3]$ and compare the observed error to an upper bound based on $\\Phi$.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> t = np.array([1.0, 1.6, 1.9, 2.7, 3.0])
> n = t.size - 1
>
> def Phi(x):
>     p = 1.0
>     for ti in t:
>         p *= (x - ti)
>     return p
>
> # Lagrange interpolation via explicit cardinal polynomials (ok for small n).
> y = np.log(t)
>
> def ell(k, x):
>     num = 1.0
>     den = 1.0
>     for i in range(n + 1):
>         if i == k:
>             continue
>         num *= (x - t[i])
>         den *= (t[k] - t[i])
>     return num / den
>
> def p(x):
>     return sum(y[k] * ell(k, x) for k in range(n + 1))
>
> xs = np.linspace(1.0, 3.0, 800)
> err = np.abs(np.log(xs) - np.array([p(x) for x in xs]))
>
> # For f(x)=log(x), f^{(5)}(x) = 4! / x^5, so on [1,3] we have |f^{(5)}| <= 4!.
> bound = 0.2 * np.abs(np.array([Phi(x) for x in xs]))  # (4! / 5!) = 1/5 = 0.2
>
> plt.plot(xs, bound, ls="--", label=r"$\\frac{1}{5}|\\Phi(x)|$")
> plt.plot(xs, err, label=r"$|f(x)-p(x)|$")
> plt.scatter(t, np.zeros_like(t), color="black", zorder=3)
> plt.title("Interpolation error and upper bound")
> plt.xlabel("x")
> plt.grid(True, alpha=0.3)
> plt.legend()
> plt.show()
> ```
>
> The error is zero at the nodes, and both the error and the bound typically have a local maximum between consecutive nodes.

**#5 等距节点的一个推论**

对等距节点，这个误差公式会给出一个更直接的量级结论.

> **Corollary:** Error size for equispaced nodes
> Suppose $t_i=ih$ for constant step size $h$ and all $i=0,1,\dots,n$, and that $f$ has $n+1$ continuous derivatives in $(t_0,t_n)$. If $x\in[t_0,t_n]$, then there exists $\xi(x)\in(t_0,t_n)$ and $C$ independent of $x$ such that
> $$
> |f(x)-p(x)| \le C f^{(n+1)}(\xi) h^{n+1}.
> $$
> In particular, $|f(x)-p(x)| = O(h^{n+1})$ as $h\to 0$.

这个结论与 **5-5-有限差分的收敛性** 里的现象一致：节点间距为 $h$ 的分段线性插值精度是 $O(h^2)$；而用 $n+1$ 个间距为 $h$ 的点去做一阶导数的有限差分，误差量级是 $O(h^n)$ (记住有限差分公式里还要除以 $h$ ).

最后要提醒的是：按 (Lagrange 公式) 的写法直接做数值计算并不好，因为它是不稳定的. 下一节我们会推导一个代数上等价、但数值上更稳定且更快的公式.

