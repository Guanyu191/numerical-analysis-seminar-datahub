# 9-3-多项式插值的稳定性 (Stability of polynomial interpolation)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 用稳定算法观察 "剩下的敏感性"**

有了 **9-2-重心公式** 中的重心插值 (barycentric interpolation)，我们就能用一个数值稳定的算法去探索多项式插值本身的性质. 此时，如果我们仍然观察到对误差的敏感性，那么原因就不是算法不稳定，而是插值过程本身的条件性 (conditioning).

> **Demo:** Interpolation error for equispaced nodes
> We interpolate a smooth function on $[0,1]$ using equispaced nodes and track the max-norm error as the degree increases.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> def barycentric_weights(t):
>     t = np.asarray(t, dtype=float)
>     n = t.size - 1
>     C = (t[-1] - t[0]) / 4.0 if t[-1] != t[0] else 1.0
>     tc = t / C
>     omega = np.ones(n + 1, dtype=float)
>     for m in range(n):
>         d = tc[: m + 1] - tc[m + 1]
>         omega[: m + 1] *= d
>         omega[m + 1] = np.prod(-d)
>     return 1.0 / omega
>
> def polyinterp(t, y):
>     t = np.asarray(t, dtype=float)
>     y = np.asarray(y, dtype=float)
>     w = barycentric_weights(t)
>     def p(x):
>         x = np.asarray(x, dtype=float)
>         out = np.empty_like(x)
>         for i, xi in enumerate(x):
>             diff = xi - t
>             j = np.where(diff == 0.0)[0]
>             if j.size:
>                 out[i] = y[j[0]]
>             else:
>                 terms = w / diff
>                 out[i] = np.sum(y * terms) / np.sum(terms)
>         return out
>     return p
>
> f = lambda x: np.sin(np.exp(2 * x))
> xs = np.linspace(0.0, 1.0, 4000)
> fx = f(xs)
>
> ns = list(range(2, 61, 2))
> errs = []
> for n in ns:
>     t = np.linspace(0.0, 1.0, n + 1)
>     y = f(t)
>     p = polyinterp(t, y)
>     err = np.max(np.abs(p(xs) - fx))
>     errs.append(err)
>
> plt.semilogy(ns, errs, marker="o")
> plt.title("Interpolation error for equispaced nodes")
> plt.xlabel("n")
> plt.ylabel("max error")
> plt.grid(True, which="both", alpha=0.3)
> plt.show()
> ```
>
> The error may decrease at first, but then it can start growing as $n$ increases.

**#2 Runge 现象的线索：误差指示函数**

上面的 "先降后升" 是一个令人失望的现象，它暗示等距节点导致了插值问题的病态性. 我们用 **9-1-多项式插值** 的误差公式作为线索：

$$
f(x)-p(x)=\frac{f^{(n+1)}(\xi(x))}{(n+1)!}\,\Phi(x),
\qquad
\Phi(x)=\prod_{i=0}^{n}(x-t_i).
$$

虽然 $f^{(n+1)}(\xi(x))$ 与 $\xi(x)$ 的依赖关系很复杂，但 $\Phi(x)$ 只由节点决定，因此我们可以先研究 $\Phi$ 的行为.

> **Demo:** Error indicator for equispaced nodes
> We plot $|\Phi(x)|$ on $[-1,1]$ for equispaced nodes as $n$ varies.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> def Phi(x, t):
>     p = np.ones_like(x, dtype=float)
>     for ti in t:
>         p *= (x - ti)
>     return p
>
> xs = np.linspace(-1.0, 1.0, 4000)
> for n in [10, 20, 30, 40, 50]:
>     t = np.linspace(-1.0, 1.0, n + 1)
>     plt.semilogy(xs, np.abs(Phi(xs, t)), label=f"n={n}")
> plt.title("Error indicator for equispaced nodes")
> plt.xlabel("x")
> plt.ylabel(r"$|\Phi(x)|$")
> plt.grid(True, which="both", alpha=0.3)
> plt.legend()
> plt.show()
> ```
>
> Each time $\Phi$ crosses zero at a node, $|\Phi|$ goes to zero, which appears as cusps on the log scale.

从等距节点的结果里有两点很重要：

1. 在区间内固定某个位置 $x$，$|\Phi(x)|$ 会随 $n$ 指数下降.
2. 但在区间端点附近，$|\Phi(x)|$ 会比区间中部大很多，而且这个 "端点 vs 中部" 的差距会随 $n$ 指数增大.

这个差距就是可能毁掉全区间收敛性的根源.

**#3 Runge 现象**

下面用一个经典测试函数来直接观察这个不稳定性.

> **Demo:** Runge phenomenon for equispaced nodes
> We interpolate $f(x)=1/(x^2+16)$ on $[-1,1]$ with equispaced nodes and plot the pointwise error for increasing degrees.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> def barycentric_weights(t):
>     t = np.asarray(t, dtype=float)
>     n = t.size - 1
>     omega = np.ones(n + 1, dtype=float)
>     for m in range(n):
>         d = t[: m + 1] - t[m + 1]
>         omega[: m + 1] *= d
>         omega[m + 1] = np.prod(-d)
>     return 1.0 / omega
>
> def polyinterp(t, y):
>     t = np.asarray(t, dtype=float)
>     y = np.asarray(y, dtype=float)
>     w = barycentric_weights(t)
>     def p(x):
>         x = np.asarray(x, dtype=float)
>         out = np.empty_like(x)
>         for i, xi in enumerate(x):
>             diff = xi - t
>             j = np.where(diff == 0.0)[0]
>             if j.size:
>                 out[i] = y[j[0]]
>             else:
>                 terms = w / diff
>                 out[i] = np.sum(y * terms) / np.sum(terms)
>         return out
>     return p
>
> f = lambda x: 1.0 / (x**2 + 16.0)
> xs = np.linspace(-1.0, 1.0, 4000)
> fx = f(xs)
>
> for n in [4, 10, 16, 27, 42, 57]:
>     t = np.linspace(-1.0, 1.0, n + 1)
>     y = f(t)
>     p = polyinterp(t, y)
>     err = np.abs(fx - p(xs))
>     plt.semilogy(xs, err, label=f"degree {n}")
>
> plt.title("Runge phenomenon (equispaced nodes)")
> plt.xlabel("x")
> plt.ylabel(r"$|f(x)-p(x)|$")
> plt.grid(True, which="both", alpha=0.3)
> plt.legend()
> plt.show()
> ```
>
> The error can stay small in the middle while blowing up near the ends as the degree increases.

这种 "等距节点 + 高次数" 导致的插值不稳定，称为 **Runge 现象 (Runge phenomenon)**. 需要强调的是：它根植于插值收敛理论本身，并不是因为我们选了某个不稳定的实现算法.

从图里还能看到一个关键信息：即使发生 Runge 现象，区间中部仍可能保持稳定收敛. 接下来我们通过重新分配节点，把端点附近的误差救回来，代价是中部的收敛会略微变差.

**#4 Chebyshev 节点**

前面的观察暗示：如果我们在区间端点附近布更多节点，而在中部布更少节点，可能会成功. 在渐近意义下，确实存在一种 "必须这样做" 的精确结论. 一个特别重要的节点族是第二类 Chebyshev 点 (也称 Chebyshev extreme points)：

$$
t_k=-\cos\left(\frac{k\pi}{n}\right),
\qquad k=0,\dots,n.
$$

它们可以看作：单位圆上等角度分布的点投影到 $x$ 轴后的结果. 因此它们在 $[-1,1]$ 的两端会密集聚集，这个特征刚好能克服 Runge 现象.

> **Demo:** Error indicator for Chebyshev nodes
> We repeat the $|\Phi(x)|$ experiment but using Chebyshev nodes.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> def cheb_nodes(n):
>     k = np.arange(n + 1)
>     return -np.cos(np.pi * k / n)
>
> def Phi(x, t):
>     p = np.ones_like(x, dtype=float)
>     for ti in t:
>         p *= (x - ti)
>     return p
>
> xs = np.linspace(-1.0, 1.0, 4000)
> for n in [10, 20, 30, 40, 50]:
>     t = cheb_nodes(n)
>     plt.semilogy(xs, np.abs(Phi(xs, t)), label=f"n={n}")
>
> plt.title("Error indicator for Chebyshev nodes")
> plt.xlabel("x")
> plt.ylabel(r"$|\Phi(x)|$")
> plt.grid(True, which="both", alpha=0.3)
> plt.legend()
> plt.show()
> ```
>
> In contrast to the equispaced case, $|\Phi(x)|$ decays with $n$ almost uniformly across the interval.

> **Demo:** Chebyshev interpolation avoids the Runge phenomenon
> We revisit the test function $f(x)=1/(x^2+16)$ and interpolate on Chebyshev nodes instead of equispaced nodes.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> def cheb_nodes(n):
>     k = np.arange(n + 1)
>     return -np.cos(np.pi * k / n)
>
> def cheb_weights(n):
>     # Second-kind Chebyshev barycentric weights.
>     w = np.ones(n + 1, dtype=float)
>     w[0] = 0.5
>     w[-1] = 0.5
>     w *= (-1.0) ** np.arange(n + 1)
>     return w
>
> def polyinterp_cheb(f, n):
>     t = cheb_nodes(n)
>     y = f(t)
>     w = cheb_weights(n)
>     def p(x):
>         x = np.asarray(x, dtype=float)
>         out = np.empty_like(x)
>         for i, xi in enumerate(x):
>             diff = xi - t
>             j = np.where(diff == 0.0)[0]
>             if j.size:
>                 out[i] = y[j[0]]
>             else:
>                 terms = w / diff
>                 out[i] = np.sum(y * terms) / np.sum(terms)
>         return out
>     return p
>
> f = lambda x: 1.0 / (x**2 + 16.0)
> xs = np.linspace(-1.0, 1.0, 4000)
> fx = f(xs)
>
> for n in [4, 10, 16, 40]:
>     p = polyinterp_cheb(f, n)
>     err = np.abs(fx - p(xs))
>     plt.semilogy(xs, err, label=f"degree {n}")
>
> plt.title("Error for Chebyshev interpolants")
> plt.xlabel("x")
> plt.ylabel(r"$|f(x)-p(x)|$")
> plt.grid(True, which="both", alpha=0.3)
> plt.legend()
> plt.show()
> ```
>
> By moderate degrees, the error can become essentially uniform and remain near machine precision instead of blowing up at the ends.

作为一个额外好处：对 Chebyshev 节点，重心权重有非常简单的形式. 用

$$
w_k=(-1)^k d_k,
\qquad
d_k=
\begin{cases}
\frac{1}{2}, & k=0 \text{ or } k=n,\\
1, & \text{otherwise},
\end{cases}
$$

就可以直接评估重心插值.

**#5 谱收敛**

当我们在 Chebyshev 节点上做多项式插值，并让 $n\to\infty$ 时，如果被逼近的函数足够光滑，收敛率会是指数级的. 下面给出一个典型结果.

> **Theorem:** Spectral convergence on Chebyshev nodes
> Suppose $f(x)$ is analytic in an open real interval containing $[-1,1]$. Then there exist constants $C>0$ and $K>1$ such that
> $$
> \max_{x\in[-1,1]}|f(x)-p(x)| \le C K^{-n},
> $$
> where $p$ is the unique polynomial of degree $n$ or less defined by interpolation on $n+1$ Chebyshev second-kind points.

这里的 "analytic (解析)" 意味着：$f$ 的 Taylor 级数在某个包含 $[-1,1]$ 的开区间内收敛到 $f(x)$. 解析性的一个必要条件是 $f$ 有无穷多阶导数.

在其他语境里我们可能把这种形式称为线性收敛，但这里更常说 "指数收敛"，或者说它具有 **谱收敛 (spectral convergence)**. 它的含义是：每当 $n$ 增加一个常数量，误差就会再被乘上一个常数因子.

相比之下，代数收敛 (algebraic convergence) 的形式是 $O(n^{-p})$ (对某个 $p>0$)，它意味着要把误差降低一个常数因子，我们必须把 $n$ 乘上某个常数因子. 从图像上看，谱误差在 log-linear 坐标下是一条直线，而代数收敛在 log-log 坐标下是一条直线.

> **Demo:** Algebraic vs spectral convergence (schematic)
> We plot representative curves on log-log and log-linear scales.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> n = np.arange(10, 401)
> err_alg = n**(-4)                 # O(n^{-4})
> err_spec = (1.05)**(-n)           # O(K^{-n})
>
> plt.figure(figsize=(8, 3))
>
> plt.subplot(1, 2, 1)
> plt.loglog(n, err_alg, label="algebraic")
> plt.loglog(n, err_spec, label="spectral")
> plt.title("Log-log")
> plt.xlabel("n")
> plt.grid(True, which="both", alpha=0.3)
> plt.legend()
>
> plt.subplot(1, 2, 2)
> plt.semilogy(n, err_alg, label="algebraic")
> plt.semilogy(n, err_spec, label="spectral")
> plt.title("log-linear")
> plt.xlabel("n")
> plt.grid(True, which="both", alpha=0.3)
> plt.legend()
>
> plt.tight_layout()
> plt.show()
> ```
>
> Spectral convergence appears linear on a log-linear plot, while algebraic convergence appears linear on a log-log plot.

