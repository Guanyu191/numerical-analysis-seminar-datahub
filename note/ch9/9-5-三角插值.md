# 9-5-三角插值 (Trigonometric interpolation)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 周期函数与三角多项式**

到目前为止，我们用来做全局逼近的函数都是多项式. 多项式很灵活，也很容易处理，但并不总是最好的选择.

假设我们要逼近的函数 $f$ 是周期函数，并且它的一个周期可以用标准区间 $[-1,1]$ 表示. 周期性的数学含义是：对任意实数 $x$，

$$
f(x+2)=f(x).
$$

我们当然也可以用多项式去插值或投影 $f$，但更自然的做法是：用同样具有周期性的函数来替代多项式.

> **Definition:** Trigonometric polynomial
> For an integer $n$, a trigonometric polynomial of degree $n$ is
> $$
> p(x)=\frac{a_0}{2}+\sum_{k=1}^{n}\bigl(a_k\cos(k\pi x)+b_k\sin(k\pi x)\bigr),
> $$
> for real constants $a_k,b_k$.

一个重要结论是：三角插值允许我们重新使用等距节点，而且不会像多项式那样出现麻烦. 因此我们在 $[-1,1]$ 内定义

$$
N=2n+1
$$

个等距节点：

$$
t_k=\frac{2k}{N},
\qquad k=-n,\dots,n.
$$

> **Note:** 这里默认 $N$ 是奇数. 当 $N$ 为偶数时，公式需要做一些小但关键的调整. 我们在实现里会把偶数情形也处理掉. 另外，端点 $\pm 1$ 不包含在这些节点中.

像之前一样，我们有采样值 $y_{-n},\dots,y_n$，它们对应 $f$ 在节点上的取值. 并且我们还假设采样值能在双向上周期延拓：对任意整数 $m$，都有

$$
y_{k+mN}=y_k.
$$

**#2 基函数与 cardinal 性质**

三角插值在等距节点上的 cardinal 基函数可以显式写出来. 我们先定义一个 "母函数"：

$$
\tau(x)
=
\frac{2}{N}\left(\frac{1}{2}+\cos(\pi x)+\cos(2\pi x)+\cdots+\cos(n\pi x)\right)
=
\frac{\sin(N\pi x/2)}{N\sin(\pi x/2)}.
$$

> **Theorem:** Cardinal basis for trigonometric interpolation
> Given the definition of $\tau$ above:
> 1. $\tau(x)$ is a trigonometric polynomial of degree $n$.
> 2. $\tau(x)$ is $2$-periodic.
> 3. $\tau(t_k)=0$ for any nonzero integer $k$ (equivalently, for all nodes except $t_0=0$).
> 4. $\lim_{x\to 0}\tau(x)=1$.
>
> Given also the nodes $t_k=2k/N$, the functions $\tau_k(x)=\tau(x-t_k)$ form a cardinal basis for trigonometric interpolation.

因为 $\tau_{-n},\dots,\tau_n$ 构成 cardinal 基，所以插值系数就是采样值本身：

$$
p(x)=\sum_{k=-n}^{n} y_k \tau_k(x).
$$

三角插值的收敛是谱的 (spectral)，也就是在 max-范数下随 $N$ 指数收敛.

**#3 Python 版实现**

下面给出一个基于上面公式的 Python 实现. 它接收等距节点向量 `t` 与数据 `y`，返回一个可调用的插值函数 `p(x)`.

> **Demo:** Trigonometric interpolation (implementation)
> We implement `triginterp` based on the cardinal formula. The even-`N` case is handled by switching the denominator from `sin` to `tan`.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> def triginterp(t, y):
>     t = np.asarray(t, dtype=float)
>     y = np.asarray(y, dtype=complex)
>     N = t.size
>     odd = (N % 2 == 1)
>
>     def tau(x):
>         # Use the continuous extension tau(0)=1.
>         if x == 0.0:
>             return 1.0
>         if odd:
>             denom = N * np.sin(np.pi * x / 2.0)
>         else:
>             denom = N * np.tan(np.pi * x / 2.0)
>         return np.sin(N * np.pi * x / 2.0) / denom
>
>     def p(x):
>         x = np.asarray(x, dtype=float)
>         out = np.empty_like(x, dtype=complex)
>         for i, xi in enumerate(x):
>             out[i] = np.sum(y * np.array([tau(xi - tj) for tj in t]))
>         return out
>
>     return p
> ```

**#4 例子: cardinal 函数与插值**

cardinal 基函数的一个简单构造方式是：把数据设置为 "某个节点取 1，其他节点取 0"，然后直接调用 `triginterp`.

> **Demo:** Trig cardinal function and an interpolant
> We visualize a cardinal function for $N=7$, then build an interpolant for a $2$-periodic test function.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> def trig_nodes(N):
>     # Nodes in [-1,1), equally spaced, excluding endpoints.
>     n = (N - 1) // 2
>     k = np.arange(-n, n + 1)
>     return 2.0 * k / N
>
> N = 7
> t = trig_nodes(N)
> y = np.zeros(N)
> y[(N - 1) // 2] = 1.0  # node at 0
>
> p = triginterp(t, y)
>
> xs = np.linspace(-1.0, 1.0, 1000)
> plt.plot(xs, p(xs).real)
> plt.scatter(t, y, color="black", zorder=3)
> plt.title(f"Trig cardinal function, N={N}")
> plt.xlabel("x")
> plt.ylabel(r"$\\tau(x)$")
> plt.grid(True, alpha=0.3)
> plt.show()
>
> f = lambda x: np.exp(np.sin(np.pi * x) - 2.0 * np.cos(np.pi * x))
> y = f(t)
> p = triginterp(t, y)
>
> plt.plot(xs, f(xs), label="function")
> plt.plot(xs, p(xs).real, label="interpolant")
> plt.scatter(t, y, color="black", label="nodes", zorder=3)
> plt.title(f"Trig interpolation, N={N}")
> plt.xlabel("x")
> plt.ylabel("p(x)")
> plt.grid(True, alpha=0.3)
> plt.legend()
> plt.show()
> ```
>
> The interpolant and the function must intersect at every node.

**#5 收敛与稳定性**

三角插值的收敛是谱的. 我们可以把 $N$ 取到不必要的大，来展示一个对比：不同于多项式插值，三角插值在等距节点上依然保持稳定.

> **Demo:** Convergence of trig interpolation
> We track the max error as a function of $N$ on a semi-log plot.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> f = lambda x: np.exp(np.sin(np.pi * x))
> xs = np.linspace(-1.0, 1.0, 4000)
> fx = f(xs)
>
> Ns = list(range(5, 61, 2))  # odd N = 2n+1
> errs = []
> for N in Ns:
>     t = trig_nodes(N)
>     y = f(t)
>     p = triginterp(t, y)
>     err = np.max(np.abs(p(xs).real - fx))
>     errs.append(err)
>
> plt.semilogy(Ns, errs, marker="o")
> plt.title("Convergence of trig interpolation")
> plt.xlabel("N")
> plt.ylabel("max error")
> plt.grid(True, which="both", alpha=0.3)
> plt.show()
> ```
>
> The error often decays essentially exponentially in $N$ until it reaches a floor set by floating-point precision.

**#6 复指数形式与 FFT**

虽然 cardinal 形式既有用又稳定，但还有一个更基础的替代表达：把三角多项式写成复指数形式

$$
p(x)=\sum_{k=-n}^{n} c_k e^{ik\pi x}.
$$

它和实数形式之间通过 Euler 公式联系起来：

$$
e^{i\theta}=\cos(\theta)+i\sin(\theta),
$$

以及恒等式

$$
\cos\theta=\frac{e^{i\theta}+e^{-i\theta}}{2},
\qquad
\sin\theta=\frac{e^{i\theta}-e^{-i\theta}}{2i}.
$$

因此系数之间满足

$$
c_k=
\begin{cases}
\frac{a_0}{2}, & k=0,\\
\frac{1}{2}(a_k+i b_k), & k>0,\\
\overline{c_{-k}}, & k<0.
\end{cases}
$$

当数据为实数时，全实数形式看起来更自然，但复数形式往往能带来更简洁的公式，因此是标准做法.

$N=2n+1$ 个系数 $c_k$ 由 $[-1,1]$ 内 $N$ 个插值节点的条件决定. 把复指数函数在这些节点上取值，会得到一个 $N\times N$ 的线性系统

$$
\mathbf{F}\mathbf{c}=\mathbf{y},
\qquad
\mathbf{F}=\bigl[e^{is\pi t_r}\bigr]_{r=-n,\dots,n;\ s=-n,\dots,n}.
$$

在一个标量因子意义下，$\mathbf{F}$ 是酉矩阵，这意味着我们可以用一次矩阵-向量乘法在 $O(N^2)$ 代价下解出系数. 但 20 世纪一个重要的算法观察是：这个系统可以用 **快速 Fourier 变换 (fast Fourier transform, FFT)** 在 $O(N\log N)$ 代价下求解.

需要注意的是，不同实现的记号约定可能不同. 例如常见的 FFT 实现会把节点放在 $[0,2)$ 上，并按

$$
[c_0,c_1,\dots,c_n,c_{-n},\dots,c_{-1}]
$$

的顺序返回系数.

> **Demo:** Fourier coefficients via FFT (NumPy)
> We analyze a trigonometric polynomial by sampling it on equispaced nodes in $[0,2)$ and applying `np.fft.fft`.
>
> ```Python
> import numpy as np
>
> f = lambda x: 3.0 * np.cos(2.0 * np.pi * x) - np.exp(1j * np.pi * x)
>
> n = 4
> N = 2 * n + 1
> t = np.array([2.0 * j / N for j in range(N)])  # nodes in [0,2)
> y = f(t)
>
> c = np.fft.fft(y) / N
> freq = np.concatenate([np.arange(0, n + 1), -np.arange(n, 0, -1)])
>
> for k, ck in zip(freq, c):
>     print(k, np.round(ck, 6))
> ```
>
> The nonzero coefficients line up with the frequency content of the original function.

> **Note:** 光滑周期函数的 Fourier 系数通常会随频率指数衰减，而这种衰减率会影响插值误差的谱收敛速度. Fourier 分析在理论与计算上都有极其丰富的内容，这里只做最简短的引入.
