# 1-3-算法 (Algorithms)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记比较特殊，主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 从问题到算法**

一个理想化的数学问题 $f(x)$，在有限精度的计算机上通常只能通过有限步数的近似来实现. 把输入数据变换为结果的一整套指令，称为 **algorithm**. 在很多情况下，我们也可以把某个算法看成另一个数学函数，用 $\tilde f(x)$ 表示它.

即使是很简单的问题，也可能对应多种算法.

> **Example:** Suppose we want to find an algorithm that maps a given $x$ to the value of the polynomial
> $$
> f(x)=5x^3 + 4x^2 + 3x + 2.
> $$
> Representing $x^2$ as $(x)(x)$, we can find it with one multiplication. We can then find
> $$
> x^3=(x)(x^2)
> $$
> with one more multiplication. We can then apply all the coefficients (three more multiplications) and add all the terms (three additions), for a total of 8 arithmetic operations. There is a more efficient algorithm, however: organize the polynomial according to **Horner's algorithm**,
> $$
> f(x)=2 + x(3 + x(4 + 5x)).
> $$
> In this form you can see that evaluation takes only 3 additions and 3 multiplications.

把同一个多项式写成不同形式，会导致完全不同的运算次数. 当这样的计算会被重复很多次时，运算次数的节省往往就会变成真实的时间节省.

**#2 用代码表达算法**

算法的描述可以是数学、文字、以及计算机风格的指令的混合体. 这类指令常被称为 **pseudocode**，它在语法与严谨程度上可以非常多样. 这里我们用 **pseudocode** 来解释算法的轮廓，但细节通常会给出可运行的代码.

在代码的各种理想特性里，我们在 "正确性" 之后最强调的是 "清晰". 这里展示的程序并不追求总是最短、最快或最优雅；更重要的目标是配合数学推导来展示算法的核心思想，并在必要时提醒实现细节.

下面我们把 Horner 多项式求值法写成一个通用的函数. 对任意系数 $c_1,\dots,c_n$，令

$$
p(x)=c_1 + c_2 x + \cdots + c_n x^{n-1}.
$$

Horner 形式的等价写法是

$$
p(x)=(((c_n x + c_{n-1})x + c_{n-2})x + \cdots + c_2)x + c_1.
$$

如果系数按升幂顺序存放为向量 `c=[c1,c2,...,cn]`，那么这个等式直接给出一个从高次到低次的递推求值过程.

> **Demo:** Horner's rule for a general polynomial.
> ```Python
> def horner(c, x):
>     """Evaluate a polynomial with coefficients in ascending order in c."""
>     y = c[-1]
>     for ck in reversed(c[:-1]):
>         y = x * y + ck
>     return y
> ```
> Here `c[0]` is the constant term, and `c[-1]` is the coefficient of the highest power.

> **Note:** 代码解释.
> - 上面的实现里，`len(c)` 给出系数向量的长度，`c[k]` 访问第 $k$ 个元素.
> - 循环每次把当前的 `y` 乘上 `x`，再加上一个系数，正对应 Horner 形式里一层一层的括号.
> - Python 的序列下标从 0 开始，常数项是 `c[0]`，最高次项系数是 `c[-1]`；递推时可以按 `c[-2],c[-3],...,c[0]` 的顺序回推.
> - Python 里函数执行到末尾如果没有显式 `return`，则默认返回 `None`.

**#3 写自己的函数**

函数是组织计算过程的一种基本方式. 如果一组语句反复用于解决同一类问题，那么把它们包装成函数通常更清晰，也更容易复用. 函数可以写在 `.py` 源文件里，也可以在 Jupyter Notebook 里定义.

在 Python 里，函数定义通常从关键字 `def` 开始. 函数体内可以先计算中间量，再用 `return` 把结果返回给调用者. 例如，数学函数 $e^{\sin x}$ 可以写成下面这样的实现.

> **Demo:** Defining functions.
> ```Python
> import numpy as np
>
> def myfun(x):
>     s = np.sin(x)
>     return np.exp(s)
>
> # A compact equivalent definition.
> myfun2 = lambda x: np.exp(np.sin(x))
> ```
> Both `myfun` and `myfun2` represent the mathematical function $e^{\\sin x}$.

除了命名函数，我们也经常用 **anonymous functions** (也叫 **lambda functions**) 来把一个很简单的函数作为另一个函数的输入. 例如，在绘图时临时给出函数表达式.

> **Demo:** Using a lambda function.
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> f = lambda x: np.exp(np.sin(x))
> x = np.linspace(0.0, 6.0, 400)
> plt.plot(x, f(x))
> plt.show()
> ```

和多数语言一样，函数的输入参数以及在函数内部定义的变量，其作用域通常限制在函数内部. 但它们也可以访问外层作用域里已经存在的值. 例如，一个函数可能会依赖外部的参数 `c`.

> **Demo:** A function accessing an enclosing-scope variable.
> ```Python
> import numpy as np
>
> c = 1
> mycfun = lambda x: np.exp(c * np.sin(x))
> print(mycfun(3))   # returns exp(1*sin(3))
>
> c = 2
> print(mycfun(3))   # returns exp(2*sin(3))
> ```

关于函数还有很多细节，但到这里已经足够支撑我们继续阅读后续章节中的代码.
