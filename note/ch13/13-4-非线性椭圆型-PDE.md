# 13-4-非线性椭圆型 PDE (Nonlinear elliptic PDEs)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 非线性椭圆型 PDE**

许多非线性椭圆型 PDE 都会包含 Laplacian 算子. 例如，把 **10-1-两点边值问题** 中的微机械悬臂 (micromechanical deflector) 模型拓展到二维，可以得到如下 PDE：

> **Example:**
> A nonlinear elliptic PDE involving the Laplacian is
> $$
> \Delta u - \frac{\lambda}{(u+1)^2}=0,
> $$
> posed on a region $R$, with $u=0$ specified everywhere on the boundary.

更一般地，我们希望在矩形区域内部求解非线性方程

$$
\phi(x,y,u,u_x,u_y,u_{xx},u_{yy})=0,\qquad (x,y)\in R,
$$

其中

$$
R=[a,b]\times[c,d],
$$

并满足 Dirichlet 条件

$$
u(x,y)=g(x,y)\quad \text{on the boundary of }R.
$$

**#2 用 Chebyshev 配点构造非线性方程组**

为了尽可能少地使用未知量，我们对区域做 Chebyshev 离散. 核心思路是：在网格点上用离散近似把 PDE 与边界条件都写成配点方程. 当 PDE 是非线性时，这些配点方程也成为非线性方程组，需要用 quasi-Newton 迭代来求解. 下面给出一个实现框架.

> **Function:** elliptic
> **Newton-type solve for a nonlinear elliptic PDE (Chebyshev collocation)**
> ```Python
> import numpy as np
> from scipy.optimize import root
>
> def diffcheb(n, xspan):
>     k = np.arange(n + 1)
>     x = -np.cos(np.pi * k / n)  # nodes in [-1,1]
>
>     c = np.ones(n + 1)
>     c[0] = 2.0
>     c[-1] = 2.0
>     c = c * ((-1) ** k)
>
>     dX = x[:, None] - x[None, :]
>     D = (c[:, None] / c[None, :]) / (dX + np.eye(n + 1))
>     D = D - np.diag(D.sum(axis=1))
>
>     a, b = float(xspan[0]), float(xspan[1])
>     x = a + (b - a) * (x + 1.0) / 2.0
>     Dx = 2.0 * D / (b - a)
>     Dxx = Dx @ Dx
>     return x, Dx, Dxx
>
> def vec(A):
>     return np.asarray(A).reshape(-1, order="F")
>
> def unvec(z, shape):
>     return np.asarray(z).reshape(shape, order="F")
>
> def cheb_weights(n):
>     # Second-kind Chebyshev barycentric weights (up to a common factor).
>     w = np.ones(n + 1)
>     w[0] = 0.5
>     w[-1] = 0.5
>     w *= (-1.0) ** np.arange(n + 1)
>     return w
>
> def barycentric_eval(xnodes, fnodes, x, w):
>     xnodes = np.asarray(xnodes, dtype=float)
>     fnodes = np.asarray(fnodes, dtype=float)
>     w = np.asarray(w, dtype=float)
>
>     x = np.asarray(x, dtype=float)
>     scalar = (x.ndim == 0)
>     x_flat = x.reshape(1) if scalar else x.reshape(-1)
>
>     diff = x_flat[:, None] - xnodes[None, :]
>     hit = diff == 0.0
>     out = np.empty(x_flat.shape, dtype=float)
>     hit_rows = np.any(hit, axis=1)
>     if np.any(hit_rows):
>         out[hit_rows] = fnodes[np.argmax(hit[hit_rows], axis=1)]
>     if np.any(~hit_rows):
>         diff2 = diff[~hit_rows]
>         tmp = w / diff2
>         out[~hit_rows] = (tmp @ fnodes) / tmp.sum(axis=1)
>
>     return float(out[0]) if scalar else out.reshape(x.shape)
>
> def elliptic(phi, g, m, xspan, n, yspan, *, method="krylov"):
>     """Solve phi(x,y,u,ux,uy,uxx,uyy)=0 on a rectangle with Dirichlet boundary u=g."""
>     x, Dx, Dxx = diffcheb(m, xspan)
>     y, Dy, Dyy = diffcheb(n, yspan)
>     X, Y = np.meshgrid(x, y, indexing="ij")
>
>     isboundary = np.ones((m + 1, n + 1), dtype=bool)
>     isboundary[1:-1, 1:-1] = False
>     gb = g(X, Y)
>
>     def residual(uvec):
>         U = unvec(uvec, (m + 1, n + 1))
>         Ux = Dx @ U
>         Uxx = Dxx @ U
>         Uy = U @ Dy.T
>         Uyy = U @ Dyy.T
>         R = np.asarray(phi(X, Y, U, Ux, Uy, Uxx, Uyy), dtype=float)
>         R[isboundary] = U[isboundary] - gb[isboundary]
>         return vec(R)
>
>     u0 = vec(np.zeros((m + 1, n + 1)))
>     sol = root(residual, u0, method=method)
>     if not sol.success:
>         raise RuntimeError(sol.message)
>
>     U = unvec(sol.x, (m + 1, n + 1))
>     wx = cheb_weights(m)
>     wy = cheb_weights(n)
>
>     def u_eval(xi, eta):
>         v = np.array([barycentric_eval(x, U[:, j], xi, wx) for j in range(n + 1)], dtype=float)
>         return barycentric_eval(y, v, eta, wy)
>
>     u_eval.x = x
>     u_eval.y = y
>     u_eval.U = U
>     return u_eval
> ```
>
> > **Note:** 上面的 `root(..., method="krylov")` 是一种 Newton-Krylov 类型的 quasi-Newton 求解器. 如果想沿用本书的 Levenberg 迭代，可以复用 **4-6-拟 Newton 方法** 里的 `levenberg` 实现，把 `residual` 作为非线性系统来求根.

**#3 网格外评价 (off-grid evaluation)**

Chebyshev 网格在区域边界附近非常密集. 这使得即使网格不大，网格点上的数值解也可能很精确；但另一方面，如果我们像绘图例程那样用简单的分片插值去评价网格外点，误差可能会大到不可接受. 更合适的做法是使用 Chebyshev 谱方法的基础：全局多项式插值.

设 $\mathbf{U}$ 是 Chebyshev 网格上的解值矩阵，它定义了一个函数 $u(x,y)$. 对给定点 $(\xi,\eta)$，我们可以按列做插值：第 $j$ 列给出 $y=y_j$ 固定时，$u(x,y_j)$ 在所有 $x_i$ 上的离散值，因此我们能构造插值多项式 $p_j(x)$，并取

$$
v_j=p_j(\xi),\qquad j=1,\dots,n+1.
$$

这样得到的向量 $\mathbf{v}$ 就是 $u(\xi,y)$ 在 Chebyshev 节点 $y_0,\dots,y_n$ 上的离散值. 再在 $y$ 方向构造插值多项式 $q(y)$，最后得到

$$
u(\xi,\eta)=q(\eta).
$$

我们可以把这个过程理解为：每次通过 "在一个方向上评价插值多项式" 来降低一个维度.

> **Note:** 当我们要在更细网格上批量评价 $u(\xi,\eta)$ (例如用于绘图) 时，上面的逐点插值会重复计算许多相同的中间量. 更高效的实现可以复用同一组 $v_j$，从而同时处理多个 $\eta$.

**#4 Demo：MEMS 膜的挠度**

> **Demo:** Deflection of a MEMS membrane
> We solve $\Delta u - \lambda/(u+1)^2 = 0$ with homogeneous Dirichlet boundary values.
>
> ```Python
> import numpy as np
>
> lam = 1.5
> phi = lambda X, Y, U, Ux, Uy, Uxx, Uyy: Uxx + Uyy - lam / (U + 1.0) ** 2
> g = lambda X, Y: 0.0 * X
>
> u = elliptic(phi, g, m=15, xspan=(0.0, 2.5), n=8, yspan=(0.0, 1.0))
>
> # Check boundary values (off-grid evaluation).
> xs = np.linspace(0.0, 2.5, 100)
> err = np.max(np.abs([u(x, 0.0) - 0.0 for x in xs]))
> print("max |u(x,0)| on boundary:", err)
>
> # Sample interior values.
> xs2 = np.arange(0.5, 2.0 + 1e-12, 0.5)
> ys2 = np.arange(0.25, 0.75 + 1e-12, 0.25)
> T15 = np.array([[u(x, y) for y in ys2] for x in xs2])
> print(T15)
>
> # Refine the grid and compare.
> u_ref = elliptic(phi, g, m=25, xspan=(0.0, 2.5), n=14, yspan=(0.0, 1.0))
> T25 = np.array([[u_ref(x, y) for y in ys2] for x in xs2])
> print("max change after refinement:", float(np.max(np.abs(T25 - T15))))
> ```
>
> 如果我们确认 PDE 编码无误，那么主要误差来源就是离散截断误差. 一个直接的检验方法是略微加密网格，然后观察数值解的变化量.

**#5 Demo：稳态对流-扩散与 Allen-Cahn**

下面两个例子都是 "时间相关 PDE 的稳态极限"：把时间导数设为 0，就得到椭圆型方程.

> **Demo:** Steady advection-diffusion
> We solve $1-u_x-2u_y+\varepsilon\Delta u=0$ on $[-1,1]^2$ with homogeneous Dirichlet boundary values.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> eps = 0.05
> phi = lambda X, Y, U, Ux, Uy, Uxx, Uyy: 1.0 - Ux - 2.0 * Uy + eps * (Uxx + Uyy)
> g = lambda X, Y: 0.0 * X
>
> u = elliptic(phi, g, m=32, xspan=(-1.0, 1.0), n=32, yspan=(-1.0, 1.0))
> X, Y = np.meshgrid(u.x, u.y, indexing="ij")
> U = u.U
>
> plt.contourf(u.x, u.y, U.T, levels=24, cmap="viridis")
> plt.gca().set_aspect("equal", adjustable="box")
> plt.title("Steady advection-diffusion")
> plt.xlabel("x")
> plt.ylabel("y")
> plt.colorbar()
> plt.show()
> ```

> **Demo:** Steady Allen-Cahn
> We solve $u(1-u^2)+\varepsilon\Delta u=0$ on $[0,1]^2$ with a nontrivial Dirichlet boundary condition.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> eps = 0.05
> phi = lambda X, Y, U, Ux, Uy, Uxx, Uyy: U * (1.0 - U**2) + eps * (Uxx + Uyy)
> g = lambda X, Y: np.tanh(5.0 * (X + 2.0 * Y - 1.0))
>
> u = elliptic(phi, g, m=36, xspan=(0.0, 1.0), n=36, yspan=(0.0, 1.0))
> plt.contourf(u.x, u.y, u.U.T, levels=24, cmap="RdBu_r")
> plt.gca().set_aspect("equal", adjustable="box")
> plt.title("Steady Allen-Cahn")
> plt.xlabel("x")
> plt.ylabel("y")
> plt.colorbar()
> plt.show()
> ```
>
> > **Note:** 这些网格规模的非线性求解可能会比较慢；如果你只想先验证代码能跑通，可以先把 `m` 与 `n` 调小，再逐步加密网格.
