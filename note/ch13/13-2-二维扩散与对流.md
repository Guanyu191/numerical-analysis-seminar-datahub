# 13-2-二维扩散与对流 (Two-dimensional diffusion and advection)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 二维 PDE 的线法**

我们考虑如下形式的偏微分方程：

$$
u_t=\phi\!\left(u,u_x,u_y,u_{xx},u_{xy},u_{yy}\right),\qquad (x,y)\in[a,b]\times[c,d].
$$

这个 PDE 可能是抛物型或双曲型；两者最主要的差异之一，是对时间步长大小可能存在的限制. 为了让描述与实现尽量简单，这里只讨论两类边界条件：二维周期条件，或在矩形区域的所有边上都施加 Dirichlet 边界条件.

如 **13-1-张量积离散** 所述，我们用网格点 $(x_i,y_j)$ 离散矩形区域，其中 $i=0,\dots,m$，$j=0,\dots,n$. 把解半离散为一个矩阵 $\mathbf{U}(t)$，使得

$$
U_{ij}\approx u(x_i,y_j,t).
$$

此时，$u$ 的空间导数项可以直接用离散版本替换：例如用 $\mathbf{D}_x\mathbf{U}$ 近似 $u_x$，用 $\mathbf{U}\mathbf{D}_y^T$ 近似 $u_y$，等等.

**#2 矩阵与向量的形状**

我们的目标是得到一个可以交给 Runge-Kutta 或多步法求解器的 IVP. 这类求解器通常以向量作为未知量，而这里的未知量自然是矩阵形状. 不过我们可以在矩阵与向量表示之间轻松切换.

> **Definition:** `vec` and `unvec` operations
> Let $\mathbf{A}$ be an $m\times n$ matrix. Define the `vec` function as stacking the columns of $\mathbf{A}$ into a vector, i.e.,
> $$
> \operatorname{vec}(\mathbf{A})
> =
> \begin{bmatrix}
> A_{11}\\
> \vdots\\
> A_{m1}\\
> A_{12}\\
> \vdots\\
> A_{mn}
> \end{bmatrix}.
> $$
>
> Let $\mathbf{z}$ be a vector of length $mn$. Define the `unvec` function as the inverse of `vec`:
> $$
> \operatorname{unvec}(\mathbf{z})
> =
> \begin{bmatrix}
> z_1 & z_{m+1} & \cdots & z_{m(n-1)+1}\\
> z_2 & z_{m+2} & \cdots & z_{m(n-1)+2}\\
> \vdots & \vdots & & \vdots\\
> z_m & z_{2m} & \cdots & z_{mn}
> \end{bmatrix}.
> $$

> **Note:** 在 NumPy 里，`vec`/`unvec` 的关键是要使用列优先 (column-major) 顺序来 "按列堆叠"，因此常见写法是 `A.reshape(-1, order="F")` 与 `z.reshape((m,n), order="F")`.

> **Demo:** `vec`/`unvec` in NumPy
> ```Python
> import numpy as np
>
> rng = np.random.default_rng(0)
> m, n = 2, 3
> V = rng.integers(1, 10, size=(m, n))
>
> def vec(A):
>     return np.asarray(A).reshape(-1, order="F")
>
> def unvec(z, shape):
>     return np.asarray(z).reshape(shape, order="F")
>
> v = vec(V)
> print("V:\\n", V)
> print("vec(V):\\n", v)
> print("unvec(vec(V)):\\n", unvec(v, (m, n)))
> ```
>
> `unvec(vec(V))` 会返回原矩阵 `V`，因此 `unvec` 是 `vec` 的逆操作.

**#3 周期端点条件**

当边界条件是二维周期条件时，线法里的未知量就是数值解在网格上的取值矩阵 $\mathbf{U}(t)$. 对 IVP 求解器而言，$\mathbf{U}(t)$ 等价于向量

$$
\mathbf{u}(t)=\operatorname{vec}(\mathbf{U}(t)).
$$

> **Demo:** 2D heat equation with periodic boundary conditions
> We solve $u_t=0.1(u_{xx}+u_{yy})$ on $[-1,1]\times[-1,1]$ with periodic conditions in both directions.
>
> ```Python
> import numpy as np
> import scipy.sparse as sp
> from scipy.integrate import solve_ivp
> import matplotlib.pyplot as plt
>
> def diffper(n, xspan):
>     a, b = float(xspan[0]), float(xspan[1])
>     h = (b - a) / n
>     x = a + h * np.arange(n)
>
>     # First derivative: 2nd-order central difference with wrap-around.
>     dp = np.full(n - 1, 0.5 / h)
>     dm = np.full(n - 1, -0.5 / h)
>     Dx = sp.diags([dm, dp], offsets=[-1, 1], shape=(n, n), format="lil")
>     Dx[0, n - 1] = -1.0 / (2.0 * h)
>     Dx[n - 1, 0] = 1.0 / (2.0 * h)
>
>     # Second derivative: 3-point stencil with wrap-around.
>     d0 = np.full(n, -2.0 / h**2)
>     dp = np.full(n - 1, 1.0 / h**2)
>     Dxx = sp.diags([dp, d0, dp], offsets=[-1, 0, 1], shape=(n, n), format="lil")
>     Dxx[0, n - 1] = 1.0 / h**2
>     Dxx[n - 1, 0] = 1.0 / h**2
>
>     return x, Dx.tocsr(), Dxx.tocsr()
>
> def mtx(f, x, y):
>     X, Y = np.meshgrid(x, y, indexing="ij")
>     return f(X, Y)
>
> def vec(A):
>     return np.asarray(A).reshape(-1, order="F")
>
> def unvec(z, shape):
>     return np.asarray(z).reshape(shape, order="F")
>
> m = 60
> n = 25
> x, Dx, Dxx = diffper(m, (-1.0, 1.0))
> y, Dy, Dyy = diffper(n, (-1.0, 1.0))
>
> u_init = lambda x, y: np.sin(4.0 * np.pi * x) * np.exp(np.cos(np.pi * y))
> U0 = mtx(u_init, x, y)
>
> alpha = 0.1
> def rhs(t, u):
>     U = unvec(u, (m, n))
>     Uxx = Dxx @ U
>     Uyy = U @ Dyy.T
>     dUdt = alpha * (Uxx + Uyy)
>     return vec(dUdt)
>
> sol = solve_ivp(rhs, (0.0, 0.2), vec(U0), method="BDF", rtol=1e-6, atol=1e-9, dense_output=True)
> U_final = unvec(sol.sol(0.2), (m, n))
>
> M = np.max(np.abs(U0))
> fig, ax = plt.subplots(1, 2, figsize=(10, 4), constrained_layout=True)
> ax[0].contourf(x, y, U0.T, levels=24, cmap="RdBu_r", vmin=-M, vmax=M)
> ax[0].set_aspect("equal", adjustable="box")
> ax[0].set_title("t = 0")
> ax[0].set_xlabel("x")
> ax[0].set_ylabel("y")
>
> ax[1].contourf(x, y, U_final.T, levels=24, cmap="RdBu_r", vmin=-M, vmax=M)
> ax[1].set_aspect("equal", adjustable="box")
> ax[1].set_title("t = 0.2")
> ax[1].set_xlabel("x")
> ax[1].set_ylabel("y")
> plt.show()
> ```
>
> 注意初值也需要满足周期性；否则把网格首尾相接后，解在端点处会出现不可忽略的不连续或不光滑.

**#4 Dirichlet 条件**

在 **11-5-边界** 里，我们通过 "把边界值从未知量里移除" 来处理 Dirichlet 条件：半离散 ODE 只对内部节点的值演化；每次计算时间导数时，再把边界值补回去，以便应用空间微分矩阵. 二维情形的思路相同，只是我们同时要处理矩阵形状与边界条件.

设 $\mathbf{U}$ 表示一个 $(m+1)\times(n+1)$ 网格上的解，包括边界值. 定义

$$
\operatorname{pack}(\mathbf{U})=\operatorname{vec}\bigl(\mathbf{E}_x\,\mathbf{U}\,\mathbf{E}_y^T\bigr),
$$

其中 $\mathbf{E}_x\in\mathbb{R}^{(m-1)\times(m+1)}$ 用于删除第一行与最后一行，$\mathbf{E}_y\in\mathbb{R}^{(n-1)\times(n+1)}$ 类似，用于删除第一列与最后一列. 因而 $\mathbf{E}_x\mathbf{U}\mathbf{E}_y^T$ 只保留内部网格点的值，再由 `vec` 变成向量.

反过来，给定内部值向量 $\mathbf{w}$ (长度为 $(m-1)(n-1)$)，我们定义

$$
\operatorname{unpack}(\mathbf{w})=\mathbf{E}_x^T\,\operatorname{unvec}(\mathbf{w})\,\mathbf{E}_y,
$$

它先把向量重排为内部网格矩阵，再在四周各补上一层零边界. 若边界值是非齐次函数 $g(x,y)$，则需要在边界节点处评价 $g$，并把这些值写入网格函数矩阵的四条边上.

> **Note:** 我们也可以直接用数组切片来 "删边界 / 补边界". 用线性代数的写法 (乘以稀疏选择矩阵) 的好处之一是：当使用隐式 IVP 求解器、且需要 Jacobian 矩阵时，这种表达更容易被自动化工具利用稀疏结构，从而加速计算.

> **Demo:** Advection-diffusion with homogeneous Dirichlet boundary conditions
> We solve $u_t+u_x = 1 + \\varepsilon (u_{xx}+u_{yy})$ on $[-1,1]^2$, with $u=0$ on the boundary.
>
> ```Python
> import numpy as np
> import scipy.sparse as sp
> from scipy.integrate import solve_ivp
> import matplotlib.pyplot as plt
>
> def diffcheb(n, xspan):
>     k = np.arange(n + 1)
>     x = -np.cos(np.pi * k / n)
>
>     c = np.ones(n + 1)
>     c[0] = 2.0
>     c[-1] = 2.0
>     c = c * ((-1) ** k)
>
>     dX = x[:, None] - x[None, :]
>     D = (c[:, None] / c[None, :]) / (dX + np.eye(n + 1))
>     D = D - np.diag(D.sum(axis=1))
>
>     a, b = float(xspan[0]), float(xspan[1])
>     x = a + (b - a) * (x + 1.0) / 2.0
>     Dx = 2.0 * D / (b - a)
>     Dxx = Dx @ Dx
>     return x, Dx, Dxx
>
> def mtx(f, x, y):
>     X, Y = np.meshgrid(x, y, indexing="ij")
>     return f(X, Y)
>
> def vec(A):
>     return np.asarray(A).reshape(-1, order="F")
>
> def unvec(z, shape):
>     return np.asarray(z).reshape(shape, order="F")
>
> m, n = 50, 36
> x, Dx, Dxx = diffcheb(m, (-1.0, 1.0))
> y, Dy, Dyy = diffcheb(n, (-1.0, 1.0))
>
> U0 = mtx(lambda x, y: (1 + y) * (1 - x) ** 4 * (1 + x) ** 2 * (1 - y**4), x, y)
>
> Ex = sp.eye(m + 1, format="csr")[1:-1, :]  # (m-1) x (m+1)
> Ey = sp.eye(n + 1, format="csr")[1:-1, :]  # (n-1) x (n+1)
> N = (m - 1) * (n - 1)
>
> def pack(U):
>     return vec(Ex @ U @ Ey.T)
>
> def unpack(w):
>     return Ex.T @ unvec(w, (m - 1, n - 1)) @ Ey
>
> eps = 0.05
> def rhs(t, w):
>     U = unpack(w)
>     Ux = Dx @ U
>     Uxx = Dxx @ U
>     Uyy = U @ Dyy.T
>     dUdt = 1.0 - Ux + eps * (Uxx + Uyy)
>     return pack(dUdt)
>
> sol = solve_ivp(rhs, (0.0, 2.0), pack(U0), method="Radau", rtol=1e-6, atol=1e-9, dense_output=True)
> U_final = unpack(sol.sol(2.0))
>
> plt.contourf(x, y, U_final.T, levels=24, cmap="viridis", vmin=0, vmax=2)
> plt.gca().set_aspect("equal", adjustable="box")
> plt.title("Advection-diffusion, t = 2")
> plt.xlabel("x")
> plt.ylabel("y")
> plt.colorbar()
> plt.show()
> ```
>
> 在任意时刻 $t$，`sol.sol(t)` 给出内部网格点上的向量值；用同一个 `unpack` 就能把它还原为包含边界的网格矩阵.

**#5 波动方程**

波动方程会带来一点额外复杂度. 首先，把二维波动方程

$$
u_{tt}=c^2(u_{xx}+u_{yy})
$$

写成时间上一阶系统：

$$
\begin{aligned}
u_t&=v,\\
v_t&=c^2(u_{xx}+u_{yy}).
\end{aligned}
$$

现在网格未知量是一对矩阵 $(\mathbf{U}(t),\mathbf{V}(t))$. 一类典型边界条件是：在边界上规定 $u$，而不直接规定 $v$. 由于 $\mathbf{U}$ 的边界值已知，它们会从半离散 IVP 的未知量中被移除；而 $\mathbf{V}$ 则全部保留. 最终仍然需要把所有未知量打包成单一向量 $\mathbf{w}(t)$，交给 IVP 求解器.

> **Demo:** 2D wave equation with homogeneous Dirichlet boundary conditions
> We solve the wave equation with $c=1$ on $[-2,2]\times[-2,2]$, with $u=0$ on the boundary.
>
> ```Python
> import numpy as np
> import scipy.sparse as sp
> from scipy.integrate import solve_ivp
> import matplotlib.pyplot as plt
>
> def diffcheb(n, xspan):
>     k = np.arange(n + 1)
>     x = -np.cos(np.pi * k / n)
>
>     c = np.ones(n + 1)
>     c[0] = 2.0
>     c[-1] = 2.0
>     c = c * ((-1) ** k)
>
>     dX = x[:, None] - x[None, :]
>     D = (c[:, None] / c[None, :]) / (dX + np.eye(n + 1))
>     D = D - np.diag(D.sum(axis=1))
>
>     a, b = float(xspan[0]), float(xspan[1])
>     x = a + (b - a) * (x + 1.0) / 2.0
>     Dx = 2.0 * D / (b - a)
>     Dxx = Dx @ Dx
>     return x, Dx, Dxx
>
> def mtx(f, x, y):
>     X, Y = np.meshgrid(x, y, indexing="ij")
>     return f(X, Y)
>
> def vec(A):
>     return np.asarray(A).reshape(-1, order="F")
>
> def unvec(z, shape):
>     return np.asarray(z).reshape(shape, order="F")
>
> m = 40
> n = 40
> x, Dx, Dxx = diffcheb(m, (-2.0, 2.0))
> y, Dy, Dyy = diffcheb(n, (-2.0, 2.0))
>
> U0 = mtx(lambda x, y: (x + 0.2) * np.exp(-12.0 * (x**2 + y**2)), x, y)
> V0 = np.zeros_like(U0)
>
> Ex = sp.eye(m + 1, format="csr")[1:-1, :]
> Ey = sp.eye(n + 1, format="csr")[1:-1, :]
> N = (m - 1) * (n - 1)
>
> def pack(U, V):
>     return np.concatenate([vec(Ex @ U @ Ey.T), vec(V)])
>
> def unpack(w):
>     U = Ex.T @ unvec(w[:N], (m - 1, n - 1)) @ Ey
>     V = unvec(w[N:], (m + 1, n + 1))
>     return U, V
>
> c = 1.0
> def rhs(t, w):
>     U, V = unpack(w)
>     dUdt = V
>     dVdt = (c**2) * (Dxx @ U + U @ Dyy.T)
>     return pack(dUdt, dVdt)
>
> w0 = pack(U0, V0)
> sol = solve_ivp(rhs, (0.0, 4.0), w0, method="RK45", rtol=1e-6, atol=1e-9, dense_output=True)
>
> U_final, _ = unpack(sol.sol(4.0))
> plt.contourf(x, y, U_final.T, levels=24, cmap="RdBu_r", vmin=-0.1, vmax=0.1)
> plt.gca().set_aspect("equal", adjustable="box")
> plt.title("Wave equation, t = 4")
> plt.xlabel("x")
> plt.ylabel("y")
> plt.colorbar()
> plt.show()
> ```
>
> 由于这是双曲型问题，非刚性求解器通常会比刚性求解器更快.
