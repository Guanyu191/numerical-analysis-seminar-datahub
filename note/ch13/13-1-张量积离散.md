# 13-1-张量积离散 (Tensor-product discretizations)

这是一份数值计算学习笔记，参考了 Tobin A. Driscoll and Richard J. Braun 的教材 [*Fundamentals of Numerical Computation* (2023)](https://tobydriscoll.net/fnc-julia/home.html).

> 这份笔记主要是翻译了原文内容，并删改或重新表述部分内容，希望能进一步减少初学者的学习障碍.

**#1 张量积区域与张量积网格**

把一个区间拓展到二维时，最简单的区域是矩形. 我们用如下记号表示矩形：

$$
[a,b]\times[c,d]=\{(x,y)\in\mathbb{R}^2:\ a\le x\le b,\ c\le y\le d\}.
$$

这里的 $\times$ 称为张量积 (**tensor product**)，矩形是张量积区域 (**tensor-product domain**) 的基本例子. 张量积的含义是：每个变量都在一个固定集合上独立变化. 最简单的三维张量积区域是长方体 $[a,b]\times[c,d]\times[e,f]$. 当各维区间相同 (即正方形或立方体) 时，我们也会写 $[a,b]^2$ 或 $[a,b]^3$. 接下来我们只讨论二维.

二维张量积区域的离散非常直接.

> **Definition:** Tensor-product grid
> Given discretizations of two intervals,
> $$
> a=x_0<x_1<\cdots <x_m=b,\qquad c=y_0<y_1<\cdots <y_n=d,
> $$
> a tensor-product grid on $[a,b]\times[c,d]$ is the set
> $$
> \{(x_i,y_j):\ i=0,\dots,m,\ j=0,\dots,n\}.
> $$

**#2 网格上的函数与矩阵**

二维网格天然对应双重索引，这几乎不可避免地会让我们想到矩阵. 给定矩形上的函数 $f(x,y)$，我们可以把它在网格点处的取值收集成一个 $(m+1)\times(n+1)$ 矩阵 $\mathbf{F}$. 由于这种 "函数 $\to$ 矩阵" 的变换非常重要，我们给它一个名字：

$$
\mathbf{F}=\operatorname{mtx}(f)=\bigl[f(x_i,y_j)\bigr]_{i=0,\dots,m;\ j=0,\dots,n}.
$$

> **Note:** 这里容易混淆的一点是：矩阵的第一维在画图时通常对应垂直方向，而坐标 $x$ 在几何中对应水平方向. 因此，当我们把 $\operatorname{mtx}(f)$ 拿去做常见的等高线/曲面绘图时，经常需要转置，让 $x$ 沿列变化、$y$ 沿行变化.

> **Example:**
> Let $[0,2]$ be divided into $m=4$ equal pieces and $[1,3]$ be discretized into $n=2$ equal pieces. Then the grid points in $[0,2]\times[1,3]$ are $(i/2,\,1+j)$ for $i=0,1,2,3,4$ and $j=0,1,2$. If $f(x,y)=\sin(\pi xy)$, then $\operatorname{mtx}(f)$ is the matrix of all values $\sin(\pi x_i y_j)$.

> **Demo:** Building `mtx(f)` and plotting
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> def mtx(f, x, y):
>     X, Y = np.meshgrid(x, y, indexing="ij")  # x: rows, y: cols
>     return f(X, Y)
>
> f = lambda x, y: np.cos(np.pi * x * y - y)
>
> m = 60
> n = 50
> x = np.linspace(0.0, 2.0, m + 1)
> y = np.linspace(1.0, 3.0, n + 1)
> F = mtx(f, x, y)  # (m+1, n+1)
>
> # For plotting, we use F.T so that x goes along columns and y goes along rows.
> plt.contourf(x, y, F.T, levels=10, cmap="RdBu_r", vmin=-1, vmax=1)
> plt.xlabel("x")
> plt.ylabel("y")
> plt.title("Contour plot of f(x,y)")
> plt.colorbar()
> plt.gca().set_aspect("equal", adjustable="box")
> plt.show()
> ```
>
> > **Note:** `meshgrid(indexing="ij")` 对应这里的 `mtx(f)` 约定；如果使用 `indexing="xy"`，则得到的数组形状与绘图默认更接近，但就不再直接对应上面的 `mtx(f)` 定义.

**#3 参数化曲面与逻辑矩形**

张量积并不把我们限制在矩形上. 许多区域与曲面都可以通过参数化来表示：给定

$$
x=x(u,v),\qquad y=y(u,v),\qquad z=z(u,v),
$$

其中 $(u,v)$ 落在一个矩形里，那么这个曲面在逻辑上仍然是 "矩形" 的 (logically rectangular). 例如，单位圆盘可以用极坐标参数化：

$$
x=u\cos v,\qquad y=u\sin v,\qquad 0\le u<1,\ 0\le v\le 2\pi.
$$

单位球面也可以被参数化为

$$
\begin{aligned}
x&=\cos u\sin v,\\
y&=\sin u\sin v,\\
z&=\cos v,
\end{aligned}
\qquad 0\le u<2\pi,\ 0\le v\le \pi.
$$

> **Demo:** A polar function on the unit disk
> We start from a function given in polar form, e.g. $f(r,\theta)=1-r^4$, and build a grid in $(r,\theta)$ space.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> from mpl_toolkits.mplot3d import Axes3D  # noqa: F401
>
> r = np.linspace(0.0, 1.0, 41)
> th = np.linspace(0.0, 2.0 * np.pi, 81)
> R, TH = np.meshgrid(r, th, indexing="ij")
>
> F = 1.0 - R**4
> X = R * np.cos(TH)
> Y = R * np.sin(TH)
>
> fig = plt.figure()
> ax = fig.add_subplot(111, projection="3d")
> ax.plot_surface(X.T, Y.T, F.T, cmap="viridis", linewidth=0)
> ax.set_xlabel("x")
> ax.set_ylabel("y")
> ax.set_zlabel("f")
> ax.set_title("Function on the unit disk")
> plt.show()
> ```
>
> In such functions, all values along the line $r=0$ must be identical, and values at $\theta=0$ must match those at $\theta=2\pi$. Otherwise the interpretation as a disk is nonsensical. If the function is defined in terms of $x$ and $y$, then those can be defined in terms of $r$ and $\theta$ using the parameterization above.

> **Demo:** A function on the unit sphere (color as value)
> We plot $f(x,y,z)=xyz^3$ on the unit sphere, using color to represent the function values.
>
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
> from mpl_toolkits.mplot3d import Axes3D  # noqa: F401
>
> th = np.linspace(0.0, 2.0 * np.pi, 61)
> ph = np.linspace(0.0, np.pi, 51)
> TH, PH = np.meshgrid(th, ph, indexing="ij")
>
> X = np.cos(TH) * np.sin(PH)
> Y = np.sin(TH) * np.sin(PH)
> Z = np.cos(PH)
> F = X * Y * Z**3
>
> norm = (F - F.min()) / (F.max() - F.min() + 1e-15)
> colors = plt.cm.viridis(norm)
>
> fig = plt.figure()
> ax = fig.add_subplot(111, projection="3d")
> ax.plot_surface(X, Y, Z, facecolors=colors, rstride=1, cstride=1, linewidth=0, antialiased=False)
> ax.set_xlabel("x")
> ax.set_ylabel("y")
> ax.set_zlabel("z")
> ax.set_title("Function on the unit sphere: f(x,y,z)=xyz^3")
> plt.show()
> ```

**#4 二维偏导数的离散**

在一维的配点法里，我们用节点处的函数值向量来表示未知函数 $u(x)$，并用微分矩阵来离散导数. 二维情形也是同样思路：我们用网格上的取值矩阵 $\mathbf{U}=\operatorname{mtx}(u)$ 来表示 $u(x,y)$，并用微分矩阵构造偏导数 $\partial u/\partial x$ 与 $\partial u/\partial y$ 的离散类比.

先看 $\partial u/\partial x$. 在偏导数定义中，$y$ 被视为常数. 注意：在 $\mathbf{U}$ 的每一列里，$y$ 都是固定的，因此可以把某一列视为一个关于 $x$ 的离散函数，并像一维那样左乘一个一阶微分矩阵 $\mathbf{D}_x$. 对所有列一起做这件事，就是 $\mathbf{D}_x\mathbf{U}$. 因此有

$$
\operatorname{mtx}\!\left(\frac{\partial u}{\partial x}\right)\approx \mathbf{D}_x\,\operatorname{mtx}(u).
$$

这里不是严格等号：左边是精确偏导的离散取值，右边是有限差分近似.

再看 $\partial u/\partial y$. 现在被固定的是 $x$，而 $x$ 在 $\mathbf{U}$ 的每一行中固定. 若把 $\mathbf{U}$ 转置，那么行与列对换，$y$ 会在每一列中变化. 这就回到 $x$-导数的情形：左乘 $\mathbf{D}_y$，再把结果转置回来. 线性代数允许我们把 "转置-左乘-转置" 更紧凑地写成

$$
\operatorname{mtx}\!\left(\frac{\partial u}{\partial y}\right)\approx \operatorname{mtx}(u)\,\mathbf{D}_y^{T}.
$$

需要记住：$\mathbf{D}_x$ 基于 $x_0,\dots,x_m$，所以是 $(m+1)\times(m+1)$；$\mathbf{D}_y$ 基于 $y_0,\dots,y_n$，所以是 $(n+1)\times(n+1)$. 这恰好保证了上面的矩阵乘法在维度上匹配. 更细的一点是：如果在两维都使用等距网格，那么像 **5-4-有限差分** 里的一阶导数二阶精度差分公式那样出现的步长 $h$，在 $x$ 与 $y$ 两个方向上一般是不同的，这也会反映在 $\mathbf{D}_x$ 与 $\mathbf{D}_y$ 的系数中.

> **Demo:** Approximating partial derivatives by differentiation matrices
> ```Python
> import numpy as np
> import matplotlib.pyplot as plt
>
> def mtx(f, x, y):
>     X, Y = np.meshgrid(x, y, indexing="ij")
>     return f(X, Y)
>
> def diffmat2(n, xspan):
>     a, b = xspan
>     h = (b - a) / n
>     x = a + h * np.arange(n + 1)
>
>     D1 = np.zeros((n + 1, n + 1))
>     for i in range(1, n):
>         D1[i, i - 1] = -0.5 / h
>         D1[i, i + 1] = 0.5 / h
>     D1[0, 0:3] = np.array([-1.5, 2.0, -0.5]) / h
>     D1[n, n - 2 : n + 1] = np.array([0.5, -2.0, 1.5]) / h
>     return x, D1
>
> u = lambda x, y: np.sin(np.pi * x * y - y)
> ux = lambda x, y: np.pi * y * np.cos(np.pi * x * y - y)
> uy = lambda x, y: (np.pi * x - 1.0) * np.cos(np.pi * x * y - y)
>
> m = 80
> n = 60
> x, Dx = diffmat2(m, (0.0, 2.0))
> y, Dy = diffmat2(n, (1.0, 3.0))
>
> U = mtx(u, x, y)
> dUdx = Dx @ U
> dUdy = U @ Dy.T
>
> exact_uy = mtx(uy, x, y)
> rel = np.linalg.norm(exact_uy - dUdy) / np.linalg.norm(exact_uy)
> print("relative Frobenius error for uy:", rel)
>
> M = np.max(np.abs(dUdy))
> fig, ax = plt.subplots(1, 2, figsize=(10, 4), constrained_layout=True)
> ax[0].contourf(x, y, exact_uy.T, levels=12, cmap="RdBu_r", vmin=-M, vmax=M)
> ax[0].set_title("∂u/∂y (exact)")
> ax[0].set_xlabel("x")
> ax[0].set_ylabel("y")
> ax[1].contourf(x, y, dUdy.T, levels=12, cmap="RdBu_r", vmin=-M, vmax=M)
> ax[1].set_title("approximation")
> ax[1].set_xlabel("x")
> ax[1].set_ylabel("y")
> plt.show()
> ```
>
> To visual accuracy the two plots are nearly identical, though the discretization sizes here yield only a few correct digits.
